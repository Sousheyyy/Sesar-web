"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/trpc/[trpc]/route";
exports.ids = ["app/api/trpc/[trpc]/route"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "./action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "./request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "./static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&page=%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute.ts&appDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&page=%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute.ts&appDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_ilker_Desktop_sesar_web_app_api_trpc_trpc_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/trpc/[trpc]/route.ts */ \"(rsc)/./app/api/trpc/[trpc]/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/trpc/[trpc]/route\",\n        pathname: \"/api/trpc/[trpc]\",\n        filename: \"route\",\n        bundlePath: \"app/api/trpc/[trpc]/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\ilker\\\\Desktop\\\\sesar-web\\\\app\\\\api\\\\trpc\\\\[trpc]\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_ilker_Desktop_sesar_web_app_api_trpc_trpc_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/trpc/[trpc]/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZ0cnBjJTJGJTVCdHJwYyU1RCUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGdHJwYyUyRiU1QnRycGMlNUQlMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZ0cnBjJTJGJTVCdHJwYyU1RCUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNpbGtlciU1Q0Rlc2t0b3AlNUNzZXNhci13ZWIlNUNhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPUMlM0ElNUNVc2VycyU1Q2lsa2VyJTVDRGVza3RvcCU1Q3Nlc2FyLXdlYiZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD1zdGFuZGFsb25lJnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ3NCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VzYXItd2ViLz9lNTc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXGlsa2VyXFxcXERlc2t0b3BcXFxcc2VzYXItd2ViXFxcXGFwcFxcXFxhcGlcXFxcdHJwY1xcXFxbdHJwY11cXFxccm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS90cnBjL1t0cnBjXS9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3RycGMvW3RycGNdXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS90cnBjL1t0cnBjXS9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIkM6XFxcXFVzZXJzXFxcXGlsa2VyXFxcXERlc2t0b3BcXFxcc2VzYXItd2ViXFxcXGFwcFxcXFxhcGlcXFxcdHJwY1xcXFxbdHJwY11cXFxccm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL3RycGMvW3RycGNdL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&page=%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute.ts&appDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/trpc/[trpc]/route.ts":
/*!**************************************!*\
  !*** ./app/api/trpc/[trpc]/route.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ handler),\n/* harmony export */   POST: () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var _trpc_server_adapters_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @trpc/server/adapters/fetch */ \"(rsc)/./node_modules/@trpc/server/dist/adapters/fetch/index.mjs\");\n/* harmony import */ var _server_routers_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/server/routers/_app */ \"(rsc)/./server/routers/_app.ts\");\n/* harmony import */ var _server_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/server/context */ \"(rsc)/./server/context.ts\");\n\n\n\nconst handler = (req)=>(0,_trpc_server_adapters_fetch__WEBPACK_IMPORTED_MODULE_2__.fetchRequestHandler)({\n        endpoint: \"/api/trpc\",\n        req,\n        router: _server_routers_app__WEBPACK_IMPORTED_MODULE_0__.appRouter,\n        createContext: _server_context__WEBPACK_IMPORTED_MODULE_1__.createContext,\n        onError: ({ path, error })=>{\n            console.error(`tRPC Error on '${path}':`, error);\n        }\n    });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL3RycGMvW3RycGNdL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtFO0FBQ2hCO0FBQ0Q7QUFFakQsTUFBTUcsVUFBVSxDQUFDQyxNQUNiSixnRkFBbUJBLENBQUM7UUFDaEJLLFVBQVU7UUFDVkQ7UUFDQUUsUUFBUUwsMERBQVNBO1FBQ2pCQyxhQUFhQSw0REFBQUE7UUFDYkssU0FBUyxDQUFDLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFO1lBQ3JCQyxRQUFRRCxLQUFLLENBQUMsQ0FBQyxlQUFlLEVBQUVELEtBQUssRUFBRSxDQUFDLEVBQUVDO1FBQzlDO0lBQ0o7QUFFdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXNhci13ZWIvLi9hcHAvYXBpL3RycGMvW3RycGNdL3JvdXRlLnRzPzJiZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmV0Y2hSZXF1ZXN0SGFuZGxlciB9IGZyb20gXCJAdHJwYy9zZXJ2ZXIvYWRhcHRlcnMvZmV0Y2hcIjtcclxuaW1wb3J0IHsgYXBwUm91dGVyIH0gZnJvbSBcIkAvc2VydmVyL3JvdXRlcnMvX2FwcFwiO1xyXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcIkAvc2VydmVyL2NvbnRleHRcIjtcclxuXHJcbmNvbnN0IGhhbmRsZXIgPSAocmVxOiBSZXF1ZXN0KSA9PlxyXG4gICAgZmV0Y2hSZXF1ZXN0SGFuZGxlcih7XHJcbiAgICAgICAgZW5kcG9pbnQ6IFwiL2FwaS90cnBjXCIsXHJcbiAgICAgICAgcmVxLFxyXG4gICAgICAgIHJvdXRlcjogYXBwUm91dGVyLFxyXG4gICAgICAgIGNyZWF0ZUNvbnRleHQsXHJcbiAgICAgICAgb25FcnJvcjogKHsgcGF0aCwgZXJyb3IgfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGB0UlBDIEVycm9yIG9uICcke3BhdGh9JzpgLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuZXhwb3J0IHsgaGFuZGxlciBhcyBHRVQsIGhhbmRsZXIgYXMgUE9TVCB9O1xyXG4iXSwibmFtZXMiOlsiZmV0Y2hSZXF1ZXN0SGFuZGxlciIsImFwcFJvdXRlciIsImNyZWF0ZUNvbnRleHQiLCJoYW5kbGVyIiwicmVxIiwiZW5kcG9pbnQiLCJyb3V0ZXIiLCJvbkVycm9yIiwicGF0aCIsImVycm9yIiwiY29uc29sZSIsIkdFVCIsIlBPU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/trpc/[trpc]/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   auth: () => (/* binding */ auth)\n/* harmony export */ });\n/* harmony import */ var _lib_prisma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/prisma */ \"(rsc)/./lib/prisma.ts\");\n/* harmony import */ var _lib_supabase_server__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase/server */ \"(rsc)/./lib/supabase/server.ts\");\n\n\n/**\n * Unified auth function that works in Server Components and Route Handlers.\n * Bridges the gap between Supabase Auth and our Prisma User profiles.\n */ async function auth() {\n    const supabase = (0,_lib_supabase_server__WEBPACK_IMPORTED_MODULE_1__.createClient)();\n    try {\n        // Use getUser() to validate the auth token on the server\n        const { data: { user }, error } = await supabase.auth.getUser();\n        if (error || !user) {\n            return null;\n        }\n        const dbUser = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.user.findUnique({\n            where: {\n                id: user.id\n            }\n        });\n        if (!dbUser) {\n            // If user exists in Auth but not in Prisma, they might be being created by the trigger\n            // but we return null here to be safe, or we could return partial data.\n            return null;\n        }\n        return {\n            user: {\n                id: dbUser.id,\n                email: dbUser.email,\n                name: dbUser.name,\n                role: dbUser.role,\n                plan: dbUser.plan,\n                balance: Number(dbUser.balance),\n                tiktokHandle: dbUser.tiktokHandle\n            },\n            // Check session expiry if needed, or null if we rely on the token validity check we just did\n            expires: null\n        };\n    } catch (err) {\n        console.error(\"Auth helper error:\", err);\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvYXV0aC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0M7QUFDZTtBQUdyRDs7O0NBR0MsR0FDTSxlQUFlRTtJQUNwQixNQUFNQyxXQUFXRixrRUFBWUE7SUFFN0IsSUFBSTtRQUNGLHlEQUF5RDtRQUN6RCxNQUFNLEVBQUVHLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1ILFNBQVNELElBQUksQ0FBQ0ssT0FBTztRQUU3RCxJQUFJRCxTQUFTLENBQUNELE1BQU07WUFDbEIsT0FBTztRQUNUO1FBRUEsTUFBTUcsU0FBUyxNQUFNUiwrQ0FBTUEsQ0FBQ0ssSUFBSSxDQUFDSSxVQUFVLENBQUM7WUFDMUNDLE9BQU87Z0JBQUVDLElBQUlOLEtBQUtNLEVBQUU7WUFBQztRQUN2QjtRQUVBLElBQUksQ0FBQ0gsUUFBUTtZQUNYLHVGQUF1RjtZQUN2Rix1RUFBdUU7WUFDdkUsT0FBTztRQUNUO1FBRUEsT0FBTztZQUNMSCxNQUFNO2dCQUNKTSxJQUFJSCxPQUFPRyxFQUFFO2dCQUNiQyxPQUFPSixPQUFPSSxLQUFLO2dCQUNuQkMsTUFBTUwsT0FBT0ssSUFBSTtnQkFDakJDLE1BQU1OLE9BQU9NLElBQUk7Z0JBQ2pCQyxNQUFNUCxPQUFPTyxJQUFJO2dCQUNqQkMsU0FBU0MsT0FBT1QsT0FBT1EsT0FBTztnQkFDOUJFLGNBQWNWLE9BQU9VLFlBQVk7WUFDbkM7WUFDQSw2RkFBNkY7WUFDN0ZDLFNBQVM7UUFDWDtJQUNGLEVBQUUsT0FBT0MsS0FBSztRQUNaQyxRQUFRZixLQUFLLENBQUMsc0JBQXNCYztRQUNwQyxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nlc2FyLXdlYi8uL2xpYi9hdXRoLnRzP2JmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJpc21hIH0gZnJvbSBcIkAvbGliL3ByaXNtYVwiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkAvbGliL3N1cGFiYXNlL3NlcnZlclwiO1xuaW1wb3J0IHsgVXNlclJvbGUgfSBmcm9tIFwiQHByaXNtYS9jbGllbnRcIjtcblxuLyoqXG4gKiBVbmlmaWVkIGF1dGggZnVuY3Rpb24gdGhhdCB3b3JrcyBpbiBTZXJ2ZXIgQ29tcG9uZW50cyBhbmQgUm91dGUgSGFuZGxlcnMuXG4gKiBCcmlkZ2VzIHRoZSBnYXAgYmV0d2VlbiBTdXBhYmFzZSBBdXRoIGFuZCBvdXIgUHJpc21hIFVzZXIgcHJvZmlsZXMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRoKCkge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudCgpO1xuXG4gIHRyeSB7XG4gICAgLy8gVXNlIGdldFVzZXIoKSB0byB2YWxpZGF0ZSB0aGUgYXV0aCB0b2tlbiBvbiB0aGUgc2VydmVyXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuXG4gICAgaWYgKGVycm9yIHx8ICF1c2VyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBkYlVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgIHdoZXJlOiB7IGlkOiB1c2VyLmlkIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIWRiVXNlcikge1xuICAgICAgLy8gSWYgdXNlciBleGlzdHMgaW4gQXV0aCBidXQgbm90IGluIFByaXNtYSwgdGhleSBtaWdodCBiZSBiZWluZyBjcmVhdGVkIGJ5IHRoZSB0cmlnZ2VyXG4gICAgICAvLyBidXQgd2UgcmV0dXJuIG51bGwgaGVyZSB0byBiZSBzYWZlLCBvciB3ZSBjb3VsZCByZXR1cm4gcGFydGlhbCBkYXRhLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgaWQ6IGRiVXNlci5pZCxcbiAgICAgICAgZW1haWw6IGRiVXNlci5lbWFpbCxcbiAgICAgICAgbmFtZTogZGJVc2VyLm5hbWUsXG4gICAgICAgIHJvbGU6IGRiVXNlci5yb2xlIGFzIFVzZXJSb2xlLFxuICAgICAgICBwbGFuOiBkYlVzZXIucGxhbixcbiAgICAgICAgYmFsYW5jZTogTnVtYmVyKGRiVXNlci5iYWxhbmNlKSxcbiAgICAgICAgdGlrdG9rSGFuZGxlOiBkYlVzZXIudGlrdG9rSGFuZGxlLFxuICAgICAgfSxcbiAgICAgIC8vIENoZWNrIHNlc3Npb24gZXhwaXJ5IGlmIG5lZWRlZCwgb3IgbnVsbCBpZiB3ZSByZWx5IG9uIHRoZSB0b2tlbiB2YWxpZGl0eSBjaGVjayB3ZSBqdXN0IGRpZFxuICAgICAgZXhwaXJlczogbnVsbCxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQXV0aCBoZWxwZXIgZXJyb3I6XCIsIGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuXG5cblxuIl0sIm5hbWVzIjpbInByaXNtYSIsImNyZWF0ZUNsaWVudCIsImF1dGgiLCJzdXBhYmFzZSIsImRhdGEiLCJ1c2VyIiwiZXJyb3IiLCJnZXRVc2VyIiwiZGJVc2VyIiwiZmluZFVuaXF1ZSIsIndoZXJlIiwiaWQiLCJlbWFpbCIsIm5hbWUiLCJyb2xlIiwicGxhbiIsImJhbGFuY2UiLCJOdW1iZXIiLCJ0aWt0b2tIYW5kbGUiLCJleHBpcmVzIiwiZXJyIiwiY29uc29sZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/auth.ts\n");

/***/ }),

/***/ "(rsc)/./lib/cache-service.ts":
/*!******************************!*\
  !*** ./lib/cache-service.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CACHE_TTL: () => (/* binding */ CACHE_TTL),\n/* harmony export */   CacheService: () => (/* binding */ CacheService),\n/* harmony export */   cacheService: () => (/* binding */ cacheService),\n/* harmony export */   getCacheService: () => (/* binding */ getCacheService)\n/* harmony export */ });\n/* harmony import */ var _lib_prisma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/prisma */ \"(rsc)/./lib/prisma.ts\");\n// Cache Service for TikAPI Responses\n// Manages caching of music info and trending videos to optimize API usage\n\nclass CacheService {\n    /**\r\n   * Get cached data if available and not expired\r\n   */ async get(tiktokMusicId, cacheType) {\n        try {\n            const cache = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.findFirst({\n                where: {\n                    tiktokMusicId,\n                    cacheType,\n                    expiresAt: {\n                        gt: new Date()\n                    }\n                },\n                orderBy: {\n                    createdAt: \"desc\"\n                }\n            });\n            if (!cache) {\n                return null;\n            }\n            return cache.data;\n        } catch (error) {\n            console.error(\"Cache retrieval error:\", error);\n            return null;\n        }\n    }\n    /**\r\n   * Store data in cache with expiration\r\n   */ async set(tiktokMusicId, cacheType, data, ttlSeconds) {\n        try {\n            const expiresAt = new Date(Date.now() + ttlSeconds * 1000);\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.create({\n                data: {\n                    tiktokMusicId,\n                    cacheType,\n                    data,\n                    expiresAt\n                }\n            });\n        } catch (error) {\n            console.error(\"Cache storage error:\", error);\n        // Non-critical error - don't throw\n        }\n    }\n    /**\r\n   * Invalidate (delete) cache for a specific music ID and type\r\n   */ async invalidate(tiktokMusicId, cacheType) {\n        try {\n            const where = {\n                tiktokMusicId\n            };\n            if (cacheType) {\n                where.cacheType = cacheType;\n            }\n            await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.deleteMany({\n                where\n            });\n        } catch (error) {\n            console.error(\"Cache invalidation error:\", error);\n        }\n    }\n    /**\r\n   * Clean up expired cache entries\r\n   * Should be run periodically (e.g., daily cron job)\r\n   */ async cleanExpired() {\n        try {\n            const result = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.deleteMany({\n                where: {\n                    expiresAt: {\n                        lt: new Date()\n                    }\n                }\n            });\n            const count = result.count;\n            return count;\n        } catch (error) {\n            console.error(\"Cache cleanup error:\", error);\n            return 0;\n        }\n    }\n    /**\r\n   * Get cache statistics\r\n   */ async getStats() {\n        try {\n            // Reduce concurrent queries to avoid connection pool exhaustion\n            const total = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.count();\n            const [musicInfo, trendingVideos, expired] = await Promise.all([\n                _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.count({\n                    where: {\n                        cacheType: \"music_info\"\n                    }\n                }),\n                _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.count({\n                    where: {\n                        cacheType: \"trending_videos\"\n                    }\n                }),\n                _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.count({\n                    where: {\n                        expiresAt: {\n                            lt: new Date()\n                        }\n                    }\n                })\n            ]);\n            return {\n                totalEntries: total,\n                musicInfoCount: musicInfo,\n                trendingVideosCount: trendingVideos,\n                expiredCount: expired\n            };\n        } catch (error) {\n            console.error(\"Cache stats error:\", error);\n            return {\n                totalEntries: 0,\n                musicInfoCount: 0,\n                trendingVideosCount: 0,\n                expiredCount: 0\n            };\n        }\n    }\n    /**\r\n   * Check if cache exists and is valid\r\n   */ async exists(tiktokMusicId, cacheType) {\n        try {\n            const cache = await _lib_prisma__WEBPACK_IMPORTED_MODULE_0__.prisma.musicCache.findFirst({\n                where: {\n                    tiktokMusicId,\n                    cacheType,\n                    expiresAt: {\n                        gt: new Date()\n                    }\n                }\n            });\n            return cache !== null;\n        } catch (error) {\n            console.error(\"Cache exists check error:\", error);\n            return false;\n        }\n    }\n}\n// Lazy-load cache service to avoid blocking worker startup\nlet _cacheService = null;\nconst getCacheService = ()=>{\n    if (!_cacheService) {\n        _cacheService = new CacheService();\n    }\n    return _cacheService;\n};\n// Export as Proxy for backward compatibility\nconst cacheService = new Proxy({}, {\n    get (_target, prop) {\n        const service = getCacheService();\n        const value = service[prop];\n        if (typeof value === \"function\") {\n            return value.bind(service);\n        }\n        return value;\n    }\n});\n// Cache TTL constants (in seconds)\nconst CACHE_TTL = {\n    MUSIC_INFO: 24 * 60 * 60,\n    TRENDING_VIDEOS: 60 * 60,\n    VIDEO_VERIFICATION: 30 * 60,\n    USER_PROFILE: 24 * 60 * 60\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDMUIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nlc2FyLXdlYi8uL2xpYi9jYWNoZS1zZXJ2aWNlLnRzP2JkZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FjaGUgU2VydmljZSBmb3IgVGlrQVBJIFJlc3BvbnNlc1xyXG4vLyBNYW5hZ2VzIGNhY2hpbmcgb2YgbXVzaWMgaW5mbyBhbmQgdHJlbmRpbmcgdmlkZW9zIHRvIG9wdGltaXplIEFQSSB1c2FnZVxyXG5cclxuaW1wb3J0IHsgcHJpc21hIH0gZnJvbSBcIkAvbGliL3ByaXNtYVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDYWNoZUVudHJ5IHtcclxuICBkYXRhOiBhbnk7XHJcbiAgZXhwaXJlc0F0OiBEYXRlO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBDYWNoZVR5cGUgPSBcInRyZW5kaW5nX3ZpZGVvc1wiIHwgXCJtdXNpY19pbmZvXCIgfCBcInZpZGVvX3ZlcmlmaWNhdGlvblwiIHwgXCJ1c2VyX3Byb2ZpbGVcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBDYWNoZVNlcnZpY2Uge1xyXG4gIC8qKlxyXG4gICAqIEdldCBjYWNoZWQgZGF0YSBpZiBhdmFpbGFibGUgYW5kIG5vdCBleHBpcmVkXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0KFxyXG4gICAgdGlrdG9rTXVzaWNJZDogc3RyaW5nLFxyXG4gICAgY2FjaGVUeXBlOiBDYWNoZVR5cGVcclxuICApOiBQcm9taXNlPGFueSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgcHJpc21hLm11c2ljQ2FjaGUuZmluZEZpcnN0KHtcclxuICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgdGlrdG9rTXVzaWNJZCxcclxuICAgICAgICAgIGNhY2hlVHlwZSxcclxuICAgICAgICAgIGV4cGlyZXNBdDoge1xyXG4gICAgICAgICAgICBndDogbmV3IERhdGUoKSwgLy8gT25seSBnZXQgbm9uLWV4cGlyZWQgY2FjaGVcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvcmRlckJ5OiB7XHJcbiAgICAgICAgICBjcmVhdGVkQXQ6IFwiZGVzY1wiLCAvLyBHZXQgbW9zdCByZWNlbnRcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghY2FjaGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIHJldHVybiBjYWNoZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIHJldHJpZXZhbCBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3JlIGRhdGEgaW4gY2FjaGUgd2l0aCBleHBpcmF0aW9uXHJcbiAgICovXHJcbiAgYXN5bmMgc2V0KFxyXG4gICAgdGlrdG9rTXVzaWNJZDogc3RyaW5nLFxyXG4gICAgY2FjaGVUeXBlOiBDYWNoZVR5cGUsXHJcbiAgICBkYXRhOiBhbnksXHJcbiAgICB0dGxTZWNvbmRzOiBudW1iZXJcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IG5ldyBEYXRlKERhdGUubm93KCkgKyB0dGxTZWNvbmRzICogMTAwMCk7XHJcblxyXG4gICAgICBhd2FpdCBwcmlzbWEubXVzaWNDYWNoZS5jcmVhdGUoe1xyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgIHRpa3Rva011c2ljSWQsXHJcbiAgICAgICAgICBjYWNoZVR5cGUsXHJcbiAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgZXhwaXJlc0F0LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgc3RvcmFnZSBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICAvLyBOb24tY3JpdGljYWwgZXJyb3IgLSBkb24ndCB0aHJvd1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52YWxpZGF0ZSAoZGVsZXRlKSBjYWNoZSBmb3IgYSBzcGVjaWZpYyBtdXNpYyBJRCBhbmQgdHlwZVxyXG4gICAqL1xyXG4gIGFzeW5jIGludmFsaWRhdGUoXHJcbiAgICB0aWt0b2tNdXNpY0lkOiBzdHJpbmcsXHJcbiAgICBjYWNoZVR5cGU/OiBDYWNoZVR5cGVcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHdoZXJlOiBhbnkgPSB7IHRpa3Rva011c2ljSWQgfTtcclxuICAgICAgaWYgKGNhY2hlVHlwZSkge1xyXG4gICAgICAgIHdoZXJlLmNhY2hlVHlwZSA9IGNhY2hlVHlwZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXdhaXQgcHJpc21hLm11c2ljQ2FjaGUuZGVsZXRlTWFueSh7XHJcbiAgICAgICAgd2hlcmUsXHJcbiAgICAgIH0pO1xyXG5cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FjaGUgaW52YWxpZGF0aW9uIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCBleHBpcmVkIGNhY2hlIGVudHJpZXNcclxuICAgKiBTaG91bGQgYmUgcnVuIHBlcmlvZGljYWxseSAoZS5nLiwgZGFpbHkgY3JvbiBqb2IpXHJcbiAgICovXHJcbiAgYXN5bmMgY2xlYW5FeHBpcmVkKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEubXVzaWNDYWNoZS5kZWxldGVNYW55KHtcclxuICAgICAgICB3aGVyZToge1xyXG4gICAgICAgICAgZXhwaXJlc0F0OiB7XHJcbiAgICAgICAgICAgIGx0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0LmNvdW50O1xyXG5cclxuICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIGNsZWFudXAgZXJyb3I6XCIsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY2FjaGUgc3RhdGlzdGljc1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldFN0YXRzKCk6IFByb21pc2U8e1xyXG4gICAgdG90YWxFbnRyaWVzOiBudW1iZXI7XHJcbiAgICBtdXNpY0luZm9Db3VudDogbnVtYmVyO1xyXG4gICAgdHJlbmRpbmdWaWRlb3NDb3VudDogbnVtYmVyO1xyXG4gICAgZXhwaXJlZENvdW50OiBudW1iZXI7XHJcbiAgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gUmVkdWNlIGNvbmN1cnJlbnQgcXVlcmllcyB0byBhdm9pZCBjb25uZWN0aW9uIHBvb2wgZXhoYXVzdGlvblxyXG4gICAgICBjb25zdCB0b3RhbCA9IGF3YWl0IHByaXNtYS5tdXNpY0NhY2hlLmNvdW50KCk7XHJcbiAgICAgIGNvbnN0IFttdXNpY0luZm8sIHRyZW5kaW5nVmlkZW9zLCBleHBpcmVkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICBwcmlzbWEubXVzaWNDYWNoZS5jb3VudCh7IHdoZXJlOiB7IGNhY2hlVHlwZTogXCJtdXNpY19pbmZvXCIgfSB9KSxcclxuICAgICAgICBwcmlzbWEubXVzaWNDYWNoZS5jb3VudCh7IHdoZXJlOiB7IGNhY2hlVHlwZTogXCJ0cmVuZGluZ192aWRlb3NcIiB9IH0pLFxyXG4gICAgICAgIHByaXNtYS5tdXNpY0NhY2hlLmNvdW50KHtcclxuICAgICAgICAgIHdoZXJlOiB7IGV4cGlyZXNBdDogeyBsdDogbmV3IERhdGUoKSB9IH0sXHJcbiAgICAgICAgfSksXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbEVudHJpZXM6IHRvdGFsLFxyXG4gICAgICAgIG11c2ljSW5mb0NvdW50OiBtdXNpY0luZm8sXHJcbiAgICAgICAgdHJlbmRpbmdWaWRlb3NDb3VudDogdHJlbmRpbmdWaWRlb3MsXHJcbiAgICAgICAgZXhwaXJlZENvdW50OiBleHBpcmVkLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIHN0YXRzIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG90YWxFbnRyaWVzOiAwLFxyXG4gICAgICAgIG11c2ljSW5mb0NvdW50OiAwLFxyXG4gICAgICAgIHRyZW5kaW5nVmlkZW9zQ291bnQ6IDAsXHJcbiAgICAgICAgZXhwaXJlZENvdW50OiAwLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgY2FjaGUgZXhpc3RzIGFuZCBpcyB2YWxpZFxyXG4gICAqL1xyXG4gIGFzeW5jIGV4aXN0cyh0aWt0b2tNdXNpY0lkOiBzdHJpbmcsIGNhY2hlVHlwZTogQ2FjaGVUeXBlKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHByaXNtYS5tdXNpY0NhY2hlLmZpbmRGaXJzdCh7XHJcbiAgICAgICAgd2hlcmU6IHtcclxuICAgICAgICAgIHRpa3Rva011c2ljSWQsXHJcbiAgICAgICAgICBjYWNoZVR5cGUsXHJcbiAgICAgICAgICBleHBpcmVzQXQ6IHtcclxuICAgICAgICAgICAgZ3Q6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGNhY2hlICE9PSBudWxsO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkNhY2hlIGV4aXN0cyBjaGVjayBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBMYXp5LWxvYWQgY2FjaGUgc2VydmljZSB0byBhdm9pZCBibG9ja2luZyB3b3JrZXIgc3RhcnR1cFxyXG5sZXQgX2NhY2hlU2VydmljZTogQ2FjaGVTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0Q2FjaGVTZXJ2aWNlID0gKCkgPT4ge1xyXG4gIGlmICghX2NhY2hlU2VydmljZSkge1xyXG4gICAgX2NhY2hlU2VydmljZSA9IG5ldyBDYWNoZVNlcnZpY2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIF9jYWNoZVNlcnZpY2U7XHJcbn07XHJcblxyXG4vLyBFeHBvcnQgYXMgUHJveHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcclxuZXhwb3J0IGNvbnN0IGNhY2hlU2VydmljZSA9IG5ldyBQcm94eSh7fSBhcyBDYWNoZVNlcnZpY2UsIHtcclxuICBnZXQoX3RhcmdldCwgcHJvcCkge1xyXG4gICAgY29uc3Qgc2VydmljZSA9IGdldENhY2hlU2VydmljZSgpO1xyXG4gICAgY29uc3QgdmFsdWUgPSAoc2VydmljZSBhcyBhbnkpW3Byb3BdO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gdmFsdWUuYmluZChzZXJ2aWNlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9LFxyXG59KTtcclxuXHJcbi8vIENhY2hlIFRUTCBjb25zdGFudHMgKGluIHNlY29uZHMpXHJcbmV4cG9ydCBjb25zdCBDQUNIRV9UVEwgPSB7XHJcbiAgTVVTSUNfSU5GTzogMjQgKiA2MCAqIDYwLCAvLyAyNCBob3Vyc1xyXG4gIFRSRU5ESU5HX1ZJREVPUzogNjAgKiA2MCwgLy8gMSBob3VyXHJcbiAgVklERU9fVkVSSUZJQ0FUSU9OOiAzMCAqIDYwLCAvLyAzMCBtaW51dGVzXHJcbiAgVVNFUl9QUk9GSUxFOiAyNCAqIDYwICogNjAsIC8vIDI0IGhvdXJzXHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsicHJpc21hIiwiQ2FjaGVTZXJ2aWNlIiwiZ2V0IiwidGlrdG9rTXVzaWNJZCIsImNhY2hlVHlwZSIsImNhY2hlIiwibXVzaWNDYWNoZSIsImZpbmRGaXJzdCIsIndoZXJlIiwiZXhwaXJlc0F0IiwiZ3QiLCJEYXRlIiwib3JkZXJCeSIsImNyZWF0ZWRBdCIsImRhdGEiLCJlcnJvciIsImNvbnNvbGUiLCJzZXQiLCJ0dGxTZWNvbmRzIiwibm93IiwiY3JlYXRlIiwiaW52YWxpZGF0ZSIsImRlbGV0ZU1hbnkiLCJjbGVhbkV4cGlyZWQiLCJyZXN1bHQiLCJsdCIsImNvdW50IiwiZ2V0U3RhdHMiLCJ0b3RhbCIsIm11c2ljSW5mbyIsInRyZW5kaW5nVmlkZW9zIiwiZXhwaXJlZCIsIlByb21pc2UiLCJhbGwiLCJ0b3RhbEVudHJpZXMiLCJtdXNpY0luZm9Db3VudCIsInRyZW5kaW5nVmlkZW9zQ291bnQiLCJleHBpcmVkQ291bnQiLCJleGlzdHMiLCJfY2FjaGVTZXJ2aWNlIiwiZ2V0Q2FjaGVTZXJ2aWNlIiwiY2FjaGVTZXJ2aWNlIiwiUHJveHkiLCJfdGFyZ2V0IiwicHJvcCIsInNlcnZpY2UiLCJ2YWx1ZSIsImJpbmQiLCJDQUNIRV9UVEwiLCJNVVNJQ19JTkZPIiwiVFJFTkRJTkdfVklERU9TIiwiVklERU9fVkVSSUZJQ0FUSU9OIiwiVVNFUl9QUk9GSUxFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/cache-service.ts\n");

/***/ }),

/***/ "(rsc)/./lib/prisma.ts":
/*!***********************!*\
  !*** ./lib/prisma.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prisma: () => (/* binding */ prisma),\n/* harmony export */   withRetry: () => (/* binding */ withRetry)\n/* harmony export */ });\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ \"@prisma/client\");\n/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);\n\nconst globalForPrisma = globalThis;\nconst prisma = globalForPrisma.prisma ?? new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({\n    log:  true ? [\n        \"query\",\n        \"error\",\n        \"warn\"\n    ] : 0\n});\nif (true) {\n    globalForPrisma.prisma = prisma;\n}\nasync function withRetry(query, maxRetries = 2, delay = 500) {\n    for(let i = 0; i < maxRetries; i++){\n        try {\n            return await query();\n        } catch (error) {\n            if (i < maxRetries - 1) {\n                console.warn(`Database retry ${i + 1}/${maxRetries} due to: ${error.message}`);\n                await new Promise((resolve)=>setTimeout(resolve, delay * (i + 1)));\n                continue;\n            }\n            throw error;\n        }\n    }\n    throw new Error(\"Query failed after retries\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvcHJpc21hLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEM7QUFFOUMsTUFBTUMsa0JBQWtCQztBQUlqQixNQUFNQyxTQUFTRixnQkFBZ0JFLE1BQU0sSUFBSSxJQUFJSCx3REFBWUEsQ0FBQztJQUMvREksS0FBS0MsS0FBc0MsR0FBRztRQUFDO1FBQVM7UUFBUztLQUFPLEdBQUcsQ0FBUztBQUN0RixHQUFHO0FBRUgsSUFBSUEsSUFBcUMsRUFBRTtJQUN6Q0osZ0JBQWdCRSxNQUFNLEdBQUdBO0FBQzNCO0FBRU8sZUFBZUcsVUFDcEJDLEtBQXVCLEVBQ3ZCQyxhQUFhLENBQUMsRUFDZEMsUUFBUSxHQUFHO0lBRVgsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFlBQVlFLElBQUs7UUFDbkMsSUFBSTtZQUNGLE9BQU8sTUFBTUg7UUFDZixFQUFFLE9BQU9JLE9BQVk7WUFDbkIsSUFBSUQsSUFBSUYsYUFBYSxHQUFHO2dCQUN0QkksUUFBUUMsSUFBSSxDQUFDLENBQUMsZUFBZSxFQUFFSCxJQUFJLEVBQUUsQ0FBQyxFQUFFRixXQUFXLFNBQVMsRUFBRUcsTUFBTUcsT0FBTyxDQUFDLENBQUM7Z0JBQzdFLE1BQU0sSUFBSUMsUUFBUSxDQUFDQyxVQUFZQyxXQUFXRCxTQUFTUCxRQUFTQyxDQUFBQSxJQUFJO2dCQUNoRTtZQUNGO1lBQ0EsTUFBTUM7UUFDUjtJQUNGO0lBQ0EsTUFBTSxJQUFJTyxNQUFNO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VzYXItd2ViLy4vbGliL3ByaXNtYS50cz85ODIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaXNtYUNsaWVudCB9IGZyb20gXCJAcHJpc21hL2NsaWVudFwiO1xyXG5cclxuY29uc3QgZ2xvYmFsRm9yUHJpc21hID0gZ2xvYmFsVGhpcyBhcyB1bmtub3duIGFzIHtcclxuICBwcmlzbWE6IFByaXNtYUNsaWVudCB8IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBwcmlzbWEgPSBnbG9iYWxGb3JQcmlzbWEucHJpc21hID8/IG5ldyBQcmlzbWFDbGllbnQoe1xyXG4gIGxvZzogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IFtcInF1ZXJ5XCIsIFwiZXJyb3JcIiwgXCJ3YXJuXCJdIDogW1wiZXJyb3JcIl0sXHJcbn0pO1xyXG5cclxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xyXG4gIGdsb2JhbEZvclByaXNtYS5wcmlzbWEgPSBwcmlzbWE7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoUmV0cnk8VD4oXHJcbiAgcXVlcnk6ICgpID0+IFByb21pc2U8VD4sXHJcbiAgbWF4UmV0cmllcyA9IDIsXHJcbiAgZGVsYXkgPSA1MDBcclxuKTogUHJvbWlzZTxUPiB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhSZXRyaWVzOyBpKyspIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCBxdWVyeSgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBpZiAoaSA8IG1heFJldHJpZXMgLSAxKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBEYXRhYmFzZSByZXRyeSAke2kgKyAxfS8ke21heFJldHJpZXN9IGR1ZSB0bzogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5ICogKGkgKyAxKSkpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeSBmYWlsZWQgYWZ0ZXIgcmV0cmllc1wiKTtcclxufSJdLCJuYW1lcyI6WyJQcmlzbWFDbGllbnQiLCJnbG9iYWxGb3JQcmlzbWEiLCJnbG9iYWxUaGlzIiwicHJpc21hIiwibG9nIiwicHJvY2VzcyIsIndpdGhSZXRyeSIsInF1ZXJ5IiwibWF4UmV0cmllcyIsImRlbGF5IiwiaSIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJtZXNzYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/prisma.ts\n");

/***/ }),

/***/ "(rsc)/./lib/supabase/server.ts":
/*!********************************!*\
  !*** ./lib/supabase/server.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-helpers-nextjs */ \"(rsc)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"(rsc)/./node_modules/next/dist/api/headers.js\");\n\n\nconst createClient = ()=>(0,_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__.createServerComponentClient)({\n        cookies: next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc3VwYWJhc2Uvc2VydmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEU7QUFDckM7QUFFaEMsTUFBTUUsZUFBZSxJQUMxQkYsMEZBQTJCQSxDQUFDO1FBQzFCQyxPQUFPQSxtREFBQUE7SUFDVCxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VzYXItd2ViLy4vbGliL3N1cGFiYXNlL3NlcnZlci50cz82NjI1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlcnZlckNvbXBvbmVudENsaWVudCB9IGZyb20gXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqc1wiO1xyXG5pbXBvcnQgeyBjb29raWVzIH0gZnJvbSBcIm5leHQvaGVhZGVyc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9ICgpID0+XHJcbiAgY3JlYXRlU2VydmVyQ29tcG9uZW50Q2xpZW50KHtcclxuICAgIGNvb2tpZXMsXHJcbiAgfSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiY3JlYXRlU2VydmVyQ29tcG9uZW50Q2xpZW50IiwiY29va2llcyIsImNyZWF0ZUNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/supabase/server.ts\n");

/***/ }),

/***/ "(rsc)/./lib/tiktok-scraper.ts":
/*!*******************************!*\
  !*** ./lib/tiktok-scraper.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TikTokScraperService: () => (/* binding */ TikTokScraperService),\n/* harmony export */   getTikTokScraper: () => (/* binding */ getTikTokScraper),\n/* harmony export */   tiktokScraper: () => (/* binding */ tiktokScraper)\n/* harmony export */ });\n/* harmony import */ var _cache_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cache-service */ \"(rsc)/./lib/cache-service.ts\");\n/* harmony import */ var _url_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-utils */ \"(rsc)/./lib/url-utils.ts\");\n// TikTok Scraper Service\n// This service integrates with TikAPI for fast, low-latency video verification\n// and music metadata fetching\n\n\nclass TikTokScraperService {\n    constructor(){\n        this.baseUrl = \"https://api.tikapi.io\";\n        this.apiKey = process.env.TIK_API_KEY;\n    }\n    /**\r\n   * Fetch detailed music information with statistics\r\n   * Uses /public/music/info endpoint with caching\r\n   */ async fetchMusicInfo(musicId, useCache = true) {\n        try {\n            // Check cache first if enabled\n            if (useCache) {\n                const cached = await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.get(musicId, \"music_info\");\n                if (cached) {\n                    return cached;\n                }\n            }\n            // If no API key, return mock data\n            if (!this.apiKey) {\n                console.warn(\"⚠️ No TIK_API_KEY found, using mock data\");\n                return this.getMockMusicInfo(musicId);\n            }\n            // Fetch from TikAPI\n            const response = await fetch(`${this.baseUrl}/public/music/info?id=${musicId}`, {\n                method: \"GET\",\n                headers: {\n                    \"X-API-KEY\": this.apiKey\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(`TikAPI error: ${response.statusText} - ${JSON.stringify(errorData)}`);\n            }\n            const data = await response.json();\n            if (!data || !data.musicInfo || !data.musicInfo.music) {\n                throw new Error(\"No music info returned from TikAPI\");\n            }\n            const musicData = data.musicInfo.music;\n            const statsData = data.musicInfo.stats || {};\n            // Construct proper TikTok music URL with song name\n            const songTitle = (musicData.title || \"song\").toLowerCase().replace(/[^a-z0-9\\s-]/g, \"\") // Remove special characters\n            .replace(/\\s+/g, \"-\") // Replace spaces with hyphens\n            .replace(/-+/g, \"-\") // Replace multiple hyphens with single\n            .trim();\n            const musicInfo = {\n                musicId: musicData.id || musicId,\n                title: musicData.title || \"Unknown Song\",\n                authorName: musicData.authorName || \"Unknown Artist\",\n                duration: musicData.duration || 30,\n                coverImage: musicData.coverLarge || musicData.coverMedium || musicData.coverThumb,\n                videoCount: statsData.videoCount || null,\n                tiktokUrl: `https://www.tiktok.com/music/${songTitle}-${musicData.id || musicId}`,\n                isValid: true\n            };\n            // Cache the result\n            if (useCache) {\n                await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.set(musicId, \"music_info\", musicInfo, _cache_service__WEBPACK_IMPORTED_MODULE_0__.CACHE_TTL.MUSIC_INFO);\n            }\n            return musicInfo;\n        } catch (error) {\n            console.error(\"TikAPI music info fetch error:\", error);\n            // Return mock data on error\n            return this.getMockMusicInfo(musicId);\n        }\n    }\n    /**\r\n   * Fetch trending videos/posts using a specific music\r\n   * Uses /public/music endpoint with caching\r\n   */ async fetchMusicPosts(musicId, limit = 10, useCache = true) {\n        try {\n            // Check cache first if enabled\n            if (useCache) {\n                const cached = await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.get(musicId, \"trending_videos\");\n                if (cached) {\n                    return cached;\n                }\n            }\n            // If no API key, return mock data\n            if (!this.apiKey) {\n                console.warn(\"⚠️ No TIK_API_KEY found, using mock data\");\n                return this.getMockMusicPosts(musicId, limit);\n            }\n            // Fetch from TikAPI\n            const response = await fetch(`${this.baseUrl}/public/music?id=${musicId}&count=${limit}`, {\n                method: \"GET\",\n                headers: {\n                    \"X-API-KEY\": this.apiKey\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(`TikAPI error: ${response.statusText} - ${JSON.stringify(errorData)}`);\n            }\n            const data = await response.json();\n            if (!data || !data.itemList) {\n                throw new Error(\"No music posts returned from TikAPI\");\n            }\n            const posts = data.itemList.map((item)=>({\n                    videoId: item.id,\n                    videoUrl: `https://www.tiktok.com/@${item.author?.uniqueId}/video/${item.id}`,\n                    author: {\n                        uniqueId: item.author?.uniqueId || \"\",\n                        nickname: item.author?.nickname || \"\",\n                        avatarThumb: item.author?.avatarThumb\n                    },\n                    stats: {\n                        playCount: item.stats?.playCount || 0,\n                        diggCount: item.stats?.diggCount || 0,\n                        commentCount: item.stats?.commentCount || 0,\n                        shareCount: item.stats?.shareCount || 0\n                    },\n                    desc: item.desc || \"\",\n                    createTime: item.createTime || Date.now() / 1000,\n                    coverImage: item.video?.cover || item.video?.dynamicCover\n                }));\n            // Cache the result\n            if (useCache) {\n                await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.set(musicId, \"trending_videos\", posts, _cache_service__WEBPACK_IMPORTED_MODULE_0__.CACHE_TTL.TRENDING_VIDEOS);\n            }\n            return posts;\n        } catch (error) {\n            console.error(\"TikAPI music posts fetch error:\", error);\n            // Return mock data on error\n            return this.getMockMusicPosts(musicId, limit);\n        }\n    }\n    /**\r\n   * Fetch song details from TikTok music link or video link\r\n   * Enhanced to use /public/music/info for richer metadata\r\n   */ async fetchSongDetails(tiktokUrl) {\n        try {\n            // Extract music ID from URL using centralized utility\n            const musicId = (0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.extractTikTokMusicId)(tiktokUrl);\n            if (!musicId) {\n                throw new Error((0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.getExtractionErrorMessage)(tiktokUrl, \"music\"));\n            }\n            // If we have a music ID, use the enhanced endpoint\n            if (this.apiKey) {\n                try {\n                    const musicInfo = await this.fetchMusicInfo(musicId, true);\n                    return {\n                        title: musicInfo.title,\n                        duration: musicInfo.duration,\n                        coverImage: musicInfo.coverImage,\n                        tiktokUrl: musicInfo.tiktokUrl,\n                        authorName: musicInfo.authorName,\n                        isValid: musicInfo.isValid\n                    };\n                } catch (apiError) {\n                    console.warn(\"⚠️ Enhanced fetch failed, trying fallback:\", apiError);\n                }\n            }\n            // Fallback to original method for video URLs or if enhanced method fails\n            if (this.apiKey) {\n                try {\n                    return await this.scrapeSongWithTikAPI(tiktokUrl);\n                } catch (apiError) {\n                    console.warn(\"⚠️ TikAPI failed, falling back to mock data:\", apiError);\n                    return this.getMockSongData(tiktokUrl);\n                }\n            }\n            // Otherwise, return mock data for development\n            console.warn(\"⚠️ No TIK_API_KEY found, using mock data for development\");\n            return this.getMockSongData(tiktokUrl);\n        } catch (error) {\n            console.error(\"TikTok song fetch error:\", error);\n            // Even if something goes wrong, return mock data instead of failing\n            console.warn(\"⚠️ Unexpected error, using mock data\");\n            return this.getMockSongData(tiktokUrl);\n        }\n    }\n    /**\r\n   * Verify a TikTok video and extract metadata\r\n   * Uses caching to reduce TikAPI calls (30min TTL)\r\n   */ async verifyVideo(tiktokUrl) {\n        try {\n            // Extract video ID from URL using centralized utility\n            // Note: The video ID is also extracted in route handlers for validation, \n            // but we do it here again to be self-contained. \n            const videoId = (0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.extractTikTokVideoId)(tiktokUrl);\n            if (!videoId) {\n                throw new Error((0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.getExtractionErrorMessage)(tiktokUrl, \"video\"));\n            }\n            // Check cache first\n            const cached = await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.get(videoId, \"video_verification\");\n            if (cached) {\n                return cached;\n            }\n            // If API token is available, try real scraping\n            if (this.apiKey) {\n                try {\n                    const videoData = await this.scrapeWithTikAPI(tiktokUrl);\n                    // Cache the result\n                    await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.set(videoId, \"video_verification\", videoData, _cache_service__WEBPACK_IMPORTED_MODULE_0__.CACHE_TTL.VIDEO_VERIFICATION);\n                    return videoData;\n                } catch (apiError) {\n                    console.warn(\"⚠️ TikAPI failed, falling back to mock data:\", apiError);\n                    return this.getMockData(videoId);\n                }\n            }\n            // Otherwise, return mock data for development\n            console.warn(\"⚠️ No TIK_API_KEY found, using mock data for development\");\n            return this.getMockData(videoId);\n        } catch (error) {\n            console.error(\"TikTok verification error:\", error);\n            throw error;\n        }\n    }\n    /**\r\n   * Scrape video data using TikAPI\r\n   */ async scrapeWithTikAPI(tiktokUrl) {\n        try {\n            // Extract video ID from URL using centralized utility\n            const videoId = (0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.extractTikTokVideoId)(tiktokUrl);\n            if (!videoId) {\n                throw new Error((0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.getExtractionErrorMessage)(tiktokUrl, \"video\"));\n            }\n            const response = await fetch(`${this.baseUrl}/public/video?id=${videoId}`, {\n                method: \"GET\",\n                headers: {\n                    \"X-API-KEY\": this.apiKey\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(`TikAPI error: ${response.statusText} - ${JSON.stringify(errorData)}`);\n            }\n            const data = await response.json();\n            if (!data || !data.itemInfo || !data.itemInfo.itemStruct) {\n                throw new Error(\"No video data returned from TikAPI\");\n            }\n            const videoData = data.itemInfo.itemStruct;\n            const stats = videoData.stats || {};\n            const musicData = videoData.music || {};\n            const authorStats = videoData.authorStats || {};\n            const author = videoData.author || {};\n            return {\n                videoId: videoData.id || \"\",\n                views: stats.playCount || 0,\n                likes: stats.diggCount || 0,\n                comments: stats.commentCount || 0,\n                shares: stats.shareCount || 0,\n                duration: videoData.video?.duration || 0,\n                soundId: musicData.id,\n                soundName: musicData.title || musicData.authorName,\n                creatorFollowers: authorStats.followerCount || 0,\n                creatorUsername: author.uniqueId || undefined,\n                isValid: true\n            };\n        } catch (error) {\n            console.error(\"TikAPI scraping error:\", error);\n            throw new Error(`Failed to verify video with TikAPI: ${error.message}`);\n        }\n    }\n    /**\r\n   * Scrape song data using TikAPI\r\n   */ async scrapeSongWithTikAPI(tiktokUrl) {\n        try {\n            // Check if it's a music URL or video URL using centralized utility\n            const musicId = (0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.extractTikTokMusicId)(tiktokUrl);\n            if (musicId) {\n                // Direct music URL - fetch music details\n                return await this.fetchMusicById(musicId);\n            } else {\n                // Video URL - extract music from video\n                return await this.fetchMusicFromVideo(tiktokUrl);\n            }\n        } catch (error) {\n            console.error(\"TikAPI song scraping error:\", error);\n            throw new Error(`Failed to fetch song details from TikAPI: ${error.message}`);\n        }\n    }\n    /**\r\n   * Fetch music details by music ID\r\n   */ async fetchMusicById(musicId) {\n        try {\n            const response = await fetch(`${this.baseUrl}/public/music/info?id=${musicId}`, {\n                method: \"GET\",\n                headers: {\n                    \"X-API-KEY\": this.apiKey\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(`TikAPI error: ${response.statusText} - ${JSON.stringify(errorData)}`);\n            }\n            const data = await response.json();\n            if (!data || !data.musicInfo || !data.musicInfo.music) {\n                throw new Error(\"No music data returned from TikAPI\");\n            }\n            const musicData = data.musicInfo.music;\n            // Construct proper TikTok music URL with song name\n            const songTitle = (musicData.title || \"song\").toLowerCase().replace(/[^a-z0-9\\s-]/g, \"\") // Remove special characters\n            .replace(/\\s+/g, \"-\") // Replace spaces with hyphens\n            .replace(/-+/g, \"-\") // Replace multiple hyphens with single\n            .trim();\n            return {\n                title: musicData.title || \"Unknown Song\",\n                duration: musicData.duration || 30,\n                coverImage: musicData.coverLarge || musicData.coverMedium || musicData.coverThumb,\n                tiktokUrl: `https://www.tiktok.com/music/${songTitle}-${musicData.id}`,\n                authorName: musicData.authorName,\n                isValid: true\n            };\n        } catch (error) {\n            console.error(\"TikAPI music fetch error:\", error);\n            throw new Error(`Failed to fetch music by ID: ${error.message}`);\n        }\n    }\n    /**\r\n   * Extract music from video\r\n   */ async fetchMusicFromVideo(tiktokUrl) {\n        try {\n            // Extract video ID from URL using centralized utility\n            const videoId = (0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.extractTikTokVideoId)(tiktokUrl);\n            if (!videoId) {\n                throw new Error((0,_url_utils__WEBPACK_IMPORTED_MODULE_1__.getExtractionErrorMessage)(tiktokUrl, \"video\"));\n            }\n            const response = await fetch(`${this.baseUrl}/public/video?id=${videoId}`, {\n                method: \"GET\",\n                headers: {\n                    \"X-API-KEY\": this.apiKey\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(`TikAPI error: ${response.statusText} - ${JSON.stringify(errorData)}`);\n            }\n            const data = await response.json();\n            if (!data || !data.itemInfo || !data.itemInfo.itemStruct) {\n                throw new Error(\"No video data returned from TikAPI\");\n            }\n            const videoData = data.itemInfo.itemStruct;\n            const musicData = videoData.music || {};\n            // Construct proper TikTok music URL with song name\n            const songTitle = (musicData.title || \"song\").toLowerCase().replace(/[^a-z0-9\\s-]/g, \"\") // Remove special characters\n            .replace(/\\s+/g, \"-\") // Replace spaces with hyphens\n            .replace(/-+/g, \"-\") // Replace multiple hyphens with single\n            .trim();\n            return {\n                title: musicData.title || \"Unknown Song\",\n                duration: musicData.duration || 30,\n                coverImage: musicData.coverLarge || musicData.coverMedium || musicData.coverThumb,\n                tiktokUrl: `https://www.tiktok.com/music/${songTitle}-${musicData.id}`,\n                authorName: musicData.authorName,\n                isValid: true\n            };\n        } catch (error) {\n            console.error(\"TikAPI video-to-music fetch error:\", error);\n            throw new Error(`Failed to extract music from video: ${error.message}`);\n        }\n    }\n    /**\r\n   * Get mock song data for development (when no API key is available)\r\n   */ getMockSongData(tiktokUrl) {\n        // Attempt to extract some valid-looking ID or name from URL for better mock data\n        const urlParts = tiktokUrl.split(\"/\");\n        const lastPart = urlParts[urlParts.length - 1] || \"dataset\";\n        return {\n            title: `Song from ${lastPart.substring(0, 15)}...`,\n            duration: 60,\n            coverImage: undefined,\n            tiktokUrl: tiktokUrl,\n            authorName: \"Unknown Artist (Mock)\",\n            isValid: true\n        };\n    }\n    /**\r\n   * Get mock data for development (when no API key is available)\r\n   */ getMockData(videoId) {\n        return {\n            videoId,\n            views: Math.floor(Math.random() * 10000) + 1000,\n            likes: Math.floor(Math.random() * 1000) + 100,\n            comments: Math.floor(Math.random() * 100) + 10,\n            shares: Math.floor(Math.random() * 500) + 50,\n            duration: 25,\n            soundId: \"mock-sound-id\",\n            soundName: \"Mock Song Name\",\n            creatorFollowers: Math.floor(Math.random() * 50000) + 5000,\n            creatorUsername: \"mockuser\",\n            isValid: true\n        };\n    }\n    /**\r\n   * Get mock music info for development\r\n   */ getMockMusicInfo(musicId) {\n        return {\n            musicId,\n            title: \"Mock Song Title\",\n            authorName: \"Mock Artist\",\n            duration: 30,\n            coverImage: undefined,\n            videoCount: Math.floor(Math.random() * 50000) + 5000,\n            tiktokUrl: `https://www.tiktok.com/music/mock-song-title-${musicId}`,\n            isValid: true\n        };\n    }\n    /**\r\n   * Get mock music posts for development\r\n   */ getMockMusicPosts(musicId, limit) {\n        const posts = [];\n        for(let i = 0; i < limit; i++){\n            posts.push({\n                videoId: `mock-video-${i}-${Date.now()}`,\n                videoUrl: `https://www.tiktok.com/@mockuser${i}/video/123456789${i}`,\n                author: {\n                    uniqueId: `mockuser${i}`,\n                    nickname: `Mock Creator ${i + 1}`,\n                    avatarThumb: undefined\n                },\n                stats: {\n                    playCount: Math.floor(Math.random() * 500000) + 10000,\n                    diggCount: Math.floor(Math.random() * 50000) + 1000,\n                    commentCount: Math.floor(Math.random() * 5000) + 100,\n                    shareCount: Math.floor(Math.random() * 10000) + 500\n                },\n                desc: `Mock video description for trending video ${i + 1} using this music`,\n                createTime: Date.now() / 1000 - Math.floor(Math.random() * 86400 * 7),\n                coverImage: undefined\n            });\n        }\n        return posts;\n    }\n    /**\r\n   * Verify if video uses the correct song\r\n   */ verifySong(videoData, expectedSongTitle) {\n        if (!videoData.soundName) {\n            return false;\n        }\n        // Simple string matching (can be improved with fuzzy matching)\n        return videoData.soundName.toLowerCase().includes(expectedSongTitle.toLowerCase()) || expectedSongTitle.toLowerCase().includes(videoData.soundName.toLowerCase());\n    }\n    /**\r\n   * Update submission with video data\r\n   */ async updateSubmissionData(submissionId, videoData) {\n        const { prisma } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/prisma */ \"(rsc)/./lib/prisma.ts\"));\n        return await prisma.submission.update({\n            where: {\n                id: submissionId\n            },\n            data: {\n                tiktokVideoId: videoData.videoId,\n                lastViewCount: videoData.views,\n                lastLikeCount: videoData.likes,\n                lastCommentCount: videoData.comments,\n                lastShareCount: videoData.shares,\n                videoDuration: videoData.duration,\n                creatorFollowers: videoData.creatorFollowers,\n                verified: true,\n                verifiedAt: new Date(),\n                lastCheckedAt: new Date()\n            }\n        });\n    }\n    /**\r\n   * Check TikTok user profile by username\r\n   * Uses /public/check endpoint from TikAPI with caching (24h TTL)\r\n   */ async checkUserProfile(username) {\n        try {\n            // Remove @ if present\n            const cleanUsername = username.replace(/^@/, \"\");\n            // Validate username format (alphanumeric, underscores, no spaces)\n            if (!/^[a-zA-Z0-9._]+$/.test(cleanUsername)) {\n                throw new Error(\"Invalid TikTok username format\");\n            }\n            // Check cache first\n            const cached = await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.get(cleanUsername, \"user_profile\");\n            if (cached) {\n                return cached;\n            }\n            // If no API key, return mock data\n            if (!this.apiKey) {\n                console.warn(\"⚠️ No TIK_API_KEY found, using mock data\");\n                return this.getMockUserProfile(cleanUsername);\n            }\n            // Fetch from TikAPI\n            const response = await fetch(`${this.baseUrl}/public/check?username=${encodeURIComponent(cleanUsername)}`, {\n                method: \"GET\",\n                headers: {\n                    \"X-API-KEY\": this.apiKey\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                // Handle specific error cases\n                if (response.status === 404 || errorData.message?.includes(\"not found\")) {\n                    throw new Error(\"TikTok user not found\");\n                }\n                if (response.status === 429 || errorData.message?.includes(\"rate limit\")) {\n                    throw new Error(\"Rate limit exceeded. Please try again later.\");\n                }\n                throw new Error(`TikAPI error: ${response.statusText} - ${JSON.stringify(errorData)}`);\n            }\n            const data = await response.json();\n            if (!data || !data.userInfo || !data.userInfo.user) {\n                throw new Error(\"No user data returned from TikAPI\");\n            }\n            const userData = data.userInfo.user;\n            const stats = data.userInfo.stats || {};\n            const profile = {\n                uniqueId: userData.uniqueId || cleanUsername,\n                nickname: userData.nickname || cleanUsername,\n                avatar: userData.avatarThumb || userData.avatarMedium,\n                avatarLarger: userData.avatarLarger || userData.avatarMedium,\n                signature: userData.signature || \"\",\n                followerCount: stats.followerCount ?? 0,\n                followingCount: stats.followingCount ?? 0,\n                videoCount: stats.videoCount ?? 0,\n                heartCount: stats.heartCount ?? 0,\n                isVerified: userData.verified || false,\n                isPrivate: userData.privateAccount || false,\n                isValid: true\n            };\n            // Cache the result\n            await _cache_service__WEBPACK_IMPORTED_MODULE_0__.cacheService.set(cleanUsername, \"user_profile\", profile, _cache_service__WEBPACK_IMPORTED_MODULE_0__.CACHE_TTL.USER_PROFILE);\n            return profile;\n        } catch (error) {\n            console.error(\"TikAPI user profile check error:\", error);\n            // If it's a validation error or not found, throw it\n            if (error.message?.includes(\"Invalid\") || error.message?.includes(\"not found\")) {\n                throw error;\n            }\n            // For other errors, return mock data\n            console.warn(\"⚠️ Error fetching user profile, using mock data\");\n            return this.getMockUserProfile(username.replace(/^@/, \"\"));\n        }\n    }\n    /**\r\n   * Get mock user profile data for development\r\n   */ getMockUserProfile(username) {\n        return {\n            uniqueId: username,\n            nickname: `${username} (Mock)`,\n            avatar: `https://api.dicebear.com/9.x/avataaars/png?seed=${username}`,\n            avatarLarger: `https://api.dicebear.com/9.x/avataaars/png?seed=${username}`,\n            signature: \"This is mock profile data for development\",\n            followerCount: Math.floor(Math.random() * 100000) + 1000,\n            followingCount: Math.floor(Math.random() * 1000) + 100,\n            videoCount: Math.floor(Math.random() * 500) + 10,\n            heartCount: Math.floor(Math.random() * 1000000) + 10000,\n            isVerified: false,\n            isPrivate: false,\n            isValid: true\n        };\n    }\n}\n// Lazy-load TikTok scraper to avoid blocking worker startup\nlet _tiktokScraper = null;\nconst getTikTokScraper = ()=>{\n    if (!_tiktokScraper) {\n        _tiktokScraper = new TikTokScraperService();\n    }\n    return _tiktokScraper;\n};\n// Export as Proxy for backward compatibility\nconst tiktokScraper = new Proxy({}, {\n    get (_target, prop) {\n        const service = getTikTokScraper();\n        const value = service[prop];\n        if (typeof value === \"function\") {\n            return value.bind(service);\n        }\n        return value;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLENBQUMsR0FBMkI7SUFDakU5SSxLQUFJK0ksT0FBTyxFQUFFQyxJQUFJO1FBQ2YsTUFBTUMsVUFBVUw7UUFDaEIsTUFBTU0sUUFBUSxPQUFnQixDQUFDRixLQUFLO1FBQ3BDLElBQUksT0FBT0UsVUFBVSxZQUFZO1lBQy9CLE9BQU9BLE1BQU1DLElBQUksQ0FBQ0Y7UUFDcEI7UUFDQSxPQUFPQztJQUNUO0FBQ0YsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3Nlc2FyLXdlYi8uL2xpYi90aWt0b2stc2NyYXBlci50cz81NWYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRpa1RvayBTY3JhcGVyIFNlcnZpY2VcclxuLy8gVGhpcyBzZXJ2aWNlIGludGVncmF0ZXMgd2l0aCBUaWtBUEkgZm9yIGZhc3QsIGxvdy1sYXRlbmN5IHZpZGVvIHZlcmlmaWNhdGlvblxyXG4vLyBhbmQgbXVzaWMgbWV0YWRhdGEgZmV0Y2hpbmdcclxuXHJcbmltcG9ydCB7IGNhY2hlU2VydmljZSwgQ0FDSEVfVFRMIH0gZnJvbSBcIi4vY2FjaGUtc2VydmljZVwiO1xyXG5pbXBvcnQge1xyXG4gIGV4dHJhY3RUaWtUb2tNdXNpY0lkLFxyXG4gIGV4dHJhY3RUaWtUb2tWaWRlb0lkLFxyXG4gIHZhbGlkYXRlVGlrVG9rVXJsLFxyXG4gIGdldEV4dHJhY3Rpb25FcnJvck1lc3NhZ2UsXHJcbn0gZnJvbSBcIi4vdXJsLXV0aWxzXCI7XHJcblxyXG5pbnRlcmZhY2UgVGlrVG9rVmlkZW9EYXRhIHtcclxuICB2aWRlb0lkOiBzdHJpbmc7XHJcbiAgdmlld3M6IG51bWJlcjtcclxuICBsaWtlczogbnVtYmVyO1xyXG4gIGNvbW1lbnRzOiBudW1iZXI7XHJcbiAgc2hhcmVzOiBudW1iZXI7XHJcbiAgZHVyYXRpb246IG51bWJlcjtcclxuICBzb3VuZElkPzogc3RyaW5nO1xyXG4gIHNvdW5kTmFtZT86IHN0cmluZztcclxuICBjcmVhdG9yRm9sbG93ZXJzPzogbnVtYmVyO1xyXG4gIGNyZWF0b3JVc2VybmFtZT86IHN0cmluZzsgLy8gVGlrVG9rIHVzZXJuYW1lICh1bmlxdWVJZCkgb2YgdGhlIHZpZGVvIGNyZWF0b3JcclxuICBpc1ZhbGlkOiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVGlrVG9rU29uZ0RhdGEge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgZHVyYXRpb246IG51bWJlcjtcclxuICBjb3ZlckltYWdlPzogc3RyaW5nO1xyXG4gIHRpa3Rva1VybDogc3RyaW5nO1xyXG4gIGF1dGhvck5hbWU/OiBzdHJpbmc7XHJcbiAgaXNWYWxpZDogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFRpa1Rva011c2ljSW5mbyB7XHJcbiAgbXVzaWNJZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgYXV0aG9yTmFtZTogc3RyaW5nO1xyXG4gIGR1cmF0aW9uOiBudW1iZXI7XHJcbiAgY292ZXJJbWFnZT86IHN0cmluZztcclxuICB2aWRlb0NvdW50PzogbnVtYmVyOyAvLyBOdW1iZXIgb2YgdmlkZW9zIHVzaW5nIHRoaXMgbXVzaWMgKGZyb20gVGlrQVBJKVxyXG4gIHRpa3Rva1VybDogc3RyaW5nO1xyXG4gIGlzVmFsaWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBUaWtUb2tNdXNpY1Bvc3Qge1xyXG4gIHZpZGVvSWQ6IHN0cmluZztcclxuICB2aWRlb1VybDogc3RyaW5nO1xyXG4gIGF1dGhvcjoge1xyXG4gICAgdW5pcXVlSWQ6IHN0cmluZztcclxuICAgIG5pY2tuYW1lOiBzdHJpbmc7XHJcbiAgICBhdmF0YXJUaHVtYj86IHN0cmluZztcclxuICB9O1xyXG4gIHN0YXRzOiB7XHJcbiAgICBwbGF5Q291bnQ6IG51bWJlcjtcclxuICAgIGRpZ2dDb3VudDogbnVtYmVyO1xyXG4gICAgY29tbWVudENvdW50OiBudW1iZXI7XHJcbiAgICBzaGFyZUNvdW50OiBudW1iZXI7XHJcbiAgfTtcclxuICBkZXNjOiBzdHJpbmc7XHJcbiAgY3JlYXRlVGltZTogbnVtYmVyO1xyXG4gIGNvdmVySW1hZ2U/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUaWtUb2tVc2VyUHJvZmlsZSB7XHJcbiAgdW5pcXVlSWQ6IHN0cmluZztcclxuICBuaWNrbmFtZTogc3RyaW5nO1xyXG4gIGF2YXRhcj86IHN0cmluZztcclxuICBhdmF0YXJMYXJnZXI/OiBzdHJpbmc7XHJcbiAgc2lnbmF0dXJlPzogc3RyaW5nOyAvLyBCaW9cclxuICBmb2xsb3dlckNvdW50PzogbnVtYmVyO1xyXG4gIGZvbGxvd2luZ0NvdW50PzogbnVtYmVyO1xyXG4gIHZpZGVvQ291bnQ/OiBudW1iZXI7XHJcbiAgaGVhcnRDb3VudD86IG51bWJlcjsgLy8gVG90YWwgbGlrZXNcclxuICBpc1ZlcmlmaWVkPzogYm9vbGVhbjtcclxuICBpc1ByaXZhdGU/OiBib29sZWFuO1xyXG4gIGlzVmFsaWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUaWtUb2tTY3JhcGVyU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICBwcml2YXRlIGJhc2VVcmw6IHN0cmluZyA9IFwiaHR0cHM6Ly9hcGkudGlrYXBpLmlvXCI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5hcGlLZXkgPSBwcm9jZXNzLmVudi5USUtfQVBJX0tFWTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZldGNoIGRldGFpbGVkIG11c2ljIGluZm9ybWF0aW9uIHdpdGggc3RhdGlzdGljc1xyXG4gICAqIFVzZXMgL3B1YmxpYy9tdXNpYy9pbmZvIGVuZHBvaW50IHdpdGggY2FjaGluZ1xyXG4gICAqL1xyXG4gIGFzeW5jIGZldGNoTXVzaWNJbmZvKG11c2ljSWQ6IHN0cmluZywgdXNlQ2FjaGU6IGJvb2xlYW4gPSB0cnVlKTogUHJvbWlzZTxUaWtUb2tNdXNpY0luZm8+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0IGlmIGVuYWJsZWRcclxuICAgICAgaWYgKHVzZUNhY2hlKSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldChtdXNpY0lkLCBcIm11c2ljX2luZm9cIik7XHJcbiAgICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGNhY2hlZCBhcyBUaWtUb2tNdXNpY0luZm87XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBubyBBUEkga2V5LCByZXR1cm4gbW9jayBkYXRhXHJcbiAgICAgIGlmICghdGhpcy5hcGlLZXkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gVElLX0FQSV9LRVkgZm91bmQsIHVzaW5nIG1vY2sgZGF0YVwiKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb2NrTXVzaWNJbmZvKG11c2ljSWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGZXRjaCBmcm9tIFRpa0FQSVxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vcHVibGljL211c2ljL2luZm8/aWQ9JHttdXNpY0lkfWAsIHtcclxuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgXCJYLUFQSS1LRVlcIjogdGhpcy5hcGlLZXksXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGlrQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtKU09OLnN0cmluZ2lmeShlcnJvckRhdGEpfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLm11c2ljSW5mbyB8fCAhZGF0YS5tdXNpY0luZm8ubXVzaWMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtdXNpYyBpbmZvIHJldHVybmVkIGZyb20gVGlrQVBJXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBtdXNpY0RhdGEgPSBkYXRhLm11c2ljSW5mby5tdXNpYztcclxuICAgICAgY29uc3Qgc3RhdHNEYXRhID0gZGF0YS5tdXNpY0luZm8uc3RhdHMgfHwge307XHJcblxyXG4gICAgICAvLyBDb25zdHJ1Y3QgcHJvcGVyIFRpa1RvayBtdXNpYyBVUkwgd2l0aCBzb25nIG5hbWVcclxuICAgICAgY29uc3Qgc29uZ1RpdGxlID0gKG11c2ljRGF0YS50aXRsZSB8fCBcInNvbmdcIikudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIC5yZXBsYWNlKC9bXmEtejAtOVxccy1dL2csICcnKSAvLyBSZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzXHJcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJy0nKSAgICAgICAgICAvLyBSZXBsYWNlIHNwYWNlcyB3aXRoIGh5cGhlbnNcclxuICAgICAgICAucmVwbGFjZSgvLSsvZywgJy0nKSAgICAgICAgICAgIC8vIFJlcGxhY2UgbXVsdGlwbGUgaHlwaGVucyB3aXRoIHNpbmdsZVxyXG4gICAgICAgIC50cmltKCk7XHJcblxyXG4gICAgICBjb25zdCBtdXNpY0luZm86IFRpa1Rva011c2ljSW5mbyA9IHtcclxuICAgICAgICBtdXNpY0lkOiBtdXNpY0RhdGEuaWQgfHwgbXVzaWNJZCxcclxuICAgICAgICB0aXRsZTogbXVzaWNEYXRhLnRpdGxlIHx8IFwiVW5rbm93biBTb25nXCIsXHJcbiAgICAgICAgYXV0aG9yTmFtZTogbXVzaWNEYXRhLmF1dGhvck5hbWUgfHwgXCJVbmtub3duIEFydGlzdFwiLFxyXG4gICAgICAgIGR1cmF0aW9uOiBtdXNpY0RhdGEuZHVyYXRpb24gfHwgMzAsXHJcbiAgICAgICAgY292ZXJJbWFnZTogbXVzaWNEYXRhLmNvdmVyTGFyZ2UgfHwgbXVzaWNEYXRhLmNvdmVyTWVkaXVtIHx8IG11c2ljRGF0YS5jb3ZlclRodW1iLFxyXG4gICAgICAgIHZpZGVvQ291bnQ6IHN0YXRzRGF0YS52aWRlb0NvdW50IHx8IG51bGwsIC8vIFRpa0FQSSBvbmx5IHByb3ZpZGVzIHZpZGVvQ291bnQsIG5vdCBwbGF5Q291bnRcclxuICAgICAgICB0aWt0b2tVcmw6IGBodHRwczovL3d3dy50aWt0b2suY29tL211c2ljLyR7c29uZ1RpdGxlfS0ke211c2ljRGF0YS5pZCB8fCBtdXNpY0lkfWAsXHJcbiAgICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRcclxuICAgICAgaWYgKHVzZUNhY2hlKSB7XHJcbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChtdXNpY0lkLCBcIm11c2ljX2luZm9cIiwgbXVzaWNJbmZvLCBDQUNIRV9UVEwuTVVTSUNfSU5GTyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtdXNpY0luZm87XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaWtBUEkgbXVzaWMgaW5mbyBmZXRjaCBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICAvLyBSZXR1cm4gbW9jayBkYXRhIG9uIGVycm9yXHJcbiAgICAgIHJldHVybiB0aGlzLmdldE1vY2tNdXNpY0luZm8obXVzaWNJZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGZXRjaCB0cmVuZGluZyB2aWRlb3MvcG9zdHMgdXNpbmcgYSBzcGVjaWZpYyBtdXNpY1xyXG4gICAqIFVzZXMgL3B1YmxpYy9tdXNpYyBlbmRwb2ludCB3aXRoIGNhY2hpbmdcclxuICAgKi9cclxuICBhc3luYyBmZXRjaE11c2ljUG9zdHMobXVzaWNJZDogc3RyaW5nLCBsaW1pdDogbnVtYmVyID0gMTAsIHVzZUNhY2hlOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8VGlrVG9rTXVzaWNQb3N0W10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0IGlmIGVuYWJsZWRcclxuICAgICAgaWYgKHVzZUNhY2hlKSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldChtdXNpY0lkLCBcInRyZW5kaW5nX3ZpZGVvc1wiKTtcclxuICAgICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gY2FjaGVkIGFzIFRpa1Rva011c2ljUG9zdFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgbm8gQVBJIGtleSwgcmV0dXJuIG1vY2sgZGF0YVxyXG4gICAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIE5vIFRJS19BUElfS0VZIGZvdW5kLCB1c2luZyBtb2NrIGRhdGFcIik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9ja011c2ljUG9zdHMobXVzaWNJZCwgbGltaXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGZXRjaCBmcm9tIFRpa0FQSVxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vcHVibGljL211c2ljP2lkPSR7bXVzaWNJZH0mY291bnQ9JHtsaW1pdH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIFwiWC1BUEktS0VZXCI6IHRoaXMuYXBpS2V5LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpa0FQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3JEYXRhKX1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5pdGVtTGlzdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG11c2ljIHBvc3RzIHJldHVybmVkIGZyb20gVGlrQVBJXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwb3N0czogVGlrVG9rTXVzaWNQb3N0W10gPSBkYXRhLml0ZW1MaXN0Lm1hcCgoaXRlbTogYW55KSA9PiAoe1xyXG4gICAgICAgIHZpZGVvSWQ6IGl0ZW0uaWQsXHJcbiAgICAgICAgdmlkZW9Vcmw6IGBodHRwczovL3d3dy50aWt0b2suY29tL0Ake2l0ZW0uYXV0aG9yPy51bmlxdWVJZH0vdmlkZW8vJHtpdGVtLmlkfWAsXHJcbiAgICAgICAgYXV0aG9yOiB7XHJcbiAgICAgICAgICB1bmlxdWVJZDogaXRlbS5hdXRob3I/LnVuaXF1ZUlkIHx8IFwiXCIsXHJcbiAgICAgICAgICBuaWNrbmFtZTogaXRlbS5hdXRob3I/Lm5pY2tuYW1lIHx8IFwiXCIsXHJcbiAgICAgICAgICBhdmF0YXJUaHVtYjogaXRlbS5hdXRob3I/LmF2YXRhclRodW1iLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhdHM6IHtcclxuICAgICAgICAgIHBsYXlDb3VudDogaXRlbS5zdGF0cz8ucGxheUNvdW50IHx8IDAsXHJcbiAgICAgICAgICBkaWdnQ291bnQ6IGl0ZW0uc3RhdHM/LmRpZ2dDb3VudCB8fCAwLFxyXG4gICAgICAgICAgY29tbWVudENvdW50OiBpdGVtLnN0YXRzPy5jb21tZW50Q291bnQgfHwgMCxcclxuICAgICAgICAgIHNoYXJlQ291bnQ6IGl0ZW0uc3RhdHM/LnNoYXJlQ291bnQgfHwgMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc2M6IGl0ZW0uZGVzYyB8fCBcIlwiLFxyXG4gICAgICAgIGNyZWF0ZVRpbWU6IGl0ZW0uY3JlYXRlVGltZSB8fCBEYXRlLm5vdygpIC8gMTAwMCxcclxuICAgICAgICBjb3ZlckltYWdlOiBpdGVtLnZpZGVvPy5jb3ZlciB8fCBpdGVtLnZpZGVvPy5keW5hbWljQ292ZXIsXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRcclxuICAgICAgaWYgKHVzZUNhY2hlKSB7XHJcbiAgICAgICAgYXdhaXQgY2FjaGVTZXJ2aWNlLnNldChtdXNpY0lkLCBcInRyZW5kaW5nX3ZpZGVvc1wiLCBwb3N0cywgQ0FDSEVfVFRMLlRSRU5ESU5HX1ZJREVPUyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwb3N0cztcclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlRpa0FQSSBtdXNpYyBwb3N0cyBmZXRjaCBlcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICAvLyBSZXR1cm4gbW9jayBkYXRhIG9uIGVycm9yXHJcbiAgICAgIHJldHVybiB0aGlzLmdldE1vY2tNdXNpY1Bvc3RzKG11c2ljSWQsIGxpbWl0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZldGNoIHNvbmcgZGV0YWlscyBmcm9tIFRpa1RvayBtdXNpYyBsaW5rIG9yIHZpZGVvIGxpbmtcclxuICAgKiBFbmhhbmNlZCB0byB1c2UgL3B1YmxpYy9tdXNpYy9pbmZvIGZvciByaWNoZXIgbWV0YWRhdGFcclxuICAgKi9cclxuICBhc3luYyBmZXRjaFNvbmdEZXRhaWxzKHRpa3Rva1VybDogc3RyaW5nKTogUHJvbWlzZTxUaWtUb2tTb25nRGF0YT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gRXh0cmFjdCBtdXNpYyBJRCBmcm9tIFVSTCB1c2luZyBjZW50cmFsaXplZCB1dGlsaXR5XHJcbiAgICAgIGNvbnN0IG11c2ljSWQgPSBleHRyYWN0VGlrVG9rTXVzaWNJZCh0aWt0b2tVcmwpO1xyXG5cclxuICAgICAgaWYgKCFtdXNpY0lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEV4dHJhY3Rpb25FcnJvck1lc3NhZ2UodGlrdG9rVXJsLCAnbXVzaWMnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBtdXNpYyBJRCwgdXNlIHRoZSBlbmhhbmNlZCBlbmRwb2ludFxyXG4gICAgICBpZiAodGhpcy5hcGlLZXkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgbXVzaWNJbmZvID0gYXdhaXQgdGhpcy5mZXRjaE11c2ljSW5mbyhtdXNpY0lkLCB0cnVlKTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpdGxlOiBtdXNpY0luZm8udGl0bGUsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBtdXNpY0luZm8uZHVyYXRpb24sXHJcbiAgICAgICAgICAgIGNvdmVySW1hZ2U6IG11c2ljSW5mby5jb3ZlckltYWdlLFxyXG4gICAgICAgICAgICB0aWt0b2tVcmw6IG11c2ljSW5mby50aWt0b2tVcmwsXHJcbiAgICAgICAgICAgIGF1dGhvck5hbWU6IG11c2ljSW5mby5hdXRob3JOYW1lLFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiBtdXNpY0luZm8uaXNWYWxpZCxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBjYXRjaCAoYXBpRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBFbmhhbmNlZCBmZXRjaCBmYWlsZWQsIHRyeWluZyBmYWxsYmFjazpcIiwgYXBpRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmFsbGJhY2sgdG8gb3JpZ2luYWwgbWV0aG9kIGZvciB2aWRlbyBVUkxzIG9yIGlmIGVuaGFuY2VkIG1ldGhvZCBmYWlsc1xyXG4gICAgICBpZiAodGhpcy5hcGlLZXkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2NyYXBlU29uZ1dpdGhUaWtBUEkodGlrdG9rVXJsKTtcclxuICAgICAgICB9IGNhdGNoIChhcGlFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIFRpa0FQSSBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBtb2NrIGRhdGE6XCIsIGFwaUVycm9yKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE1vY2tTb25nRGF0YSh0aWt0b2tVcmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gbW9jayBkYXRhIGZvciBkZXZlbG9wbWVudFxyXG4gICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gVElLX0FQSV9LRVkgZm91bmQsIHVzaW5nIG1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcIik7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE1vY2tTb25nRGF0YSh0aWt0b2tVcmwpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlRpa1RvayBzb25nIGZldGNoIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIC8vIEV2ZW4gaWYgc29tZXRoaW5nIGdvZXMgd3JvbmcsIHJldHVybiBtb2NrIGRhdGEgaW5zdGVhZCBvZiBmYWlsaW5nXHJcbiAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBVbmV4cGVjdGVkIGVycm9yLCB1c2luZyBtb2NrIGRhdGFcIik7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE1vY2tTb25nRGF0YSh0aWt0b2tVcmwpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVmVyaWZ5IGEgVGlrVG9rIHZpZGVvIGFuZCBleHRyYWN0IG1ldGFkYXRhXHJcbiAgICogVXNlcyBjYWNoaW5nIHRvIHJlZHVjZSBUaWtBUEkgY2FsbHMgKDMwbWluIFRUTClcclxuICAgKi9cclxuICBhc3luYyB2ZXJpZnlWaWRlbyh0aWt0b2tVcmw6IHN0cmluZyk6IFByb21pc2U8VGlrVG9rVmlkZW9EYXRhPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBFeHRyYWN0IHZpZGVvIElEIGZyb20gVVJMIHVzaW5nIGNlbnRyYWxpemVkIHV0aWxpdHlcclxuICAgICAgLy8gTm90ZTogVGhlIHZpZGVvIElEIGlzIGFsc28gZXh0cmFjdGVkIGluIHJvdXRlIGhhbmRsZXJzIGZvciB2YWxpZGF0aW9uLCBcclxuICAgICAgLy8gYnV0IHdlIGRvIGl0IGhlcmUgYWdhaW4gdG8gYmUgc2VsZi1jb250YWluZWQuIFxyXG4gICAgICBjb25zdCB2aWRlb0lkID0gZXh0cmFjdFRpa1Rva1ZpZGVvSWQodGlrdG9rVXJsKTtcclxuXHJcbiAgICAgIGlmICghdmlkZW9JZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFeHRyYWN0aW9uRXJyb3JNZXNzYWdlKHRpa3Rva1VybCwgJ3ZpZGVvJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxyXG4gICAgICBjb25zdCBjYWNoZWQgPSBhd2FpdCBjYWNoZVNlcnZpY2UuZ2V0KHZpZGVvSWQsIFwidmlkZW9fdmVyaWZpY2F0aW9uXCIpO1xyXG4gICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZCBhcyBUaWtUb2tWaWRlb0RhdGE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIEFQSSB0b2tlbiBpcyBhdmFpbGFibGUsIHRyeSByZWFsIHNjcmFwaW5nXHJcbiAgICAgIGlmICh0aGlzLmFwaUtleSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB2aWRlb0RhdGEgPSBhd2FpdCB0aGlzLnNjcmFwZVdpdGhUaWtBUEkodGlrdG9rVXJsKTtcclxuXHJcbiAgICAgICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XHJcbiAgICAgICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KFxyXG4gICAgICAgICAgICB2aWRlb0lkLFxyXG4gICAgICAgICAgICBcInZpZGVvX3ZlcmlmaWNhdGlvblwiLFxyXG4gICAgICAgICAgICB2aWRlb0RhdGEsXHJcbiAgICAgICAgICAgIENBQ0hFX1RUTC5WSURFT19WRVJJRklDQVRJT05cclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHZpZGVvRGF0YTtcclxuICAgICAgICB9IGNhdGNoIChhcGlFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIFRpa0FQSSBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBtb2NrIGRhdGE6XCIsIGFwaUVycm9yKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE1vY2tEYXRhKHZpZGVvSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gbW9jayBkYXRhIGZvciBkZXZlbG9wbWVudFxyXG4gICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTm8gVElLX0FQSV9LRVkgZm91bmQsIHVzaW5nIG1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcIik7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldE1vY2tEYXRhKHZpZGVvSWQpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlRpa1RvayB2ZXJpZmljYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogU2NyYXBlIHZpZGVvIGRhdGEgdXNpbmcgVGlrQVBJXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBzY3JhcGVXaXRoVGlrQVBJKHRpa3Rva1VybDogc3RyaW5nKTogUHJvbWlzZTxUaWtUb2tWaWRlb0RhdGE+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEV4dHJhY3QgdmlkZW8gSUQgZnJvbSBVUkwgdXNpbmcgY2VudHJhbGl6ZWQgdXRpbGl0eVxyXG4gICAgICBjb25zdCB2aWRlb0lkID0gZXh0cmFjdFRpa1Rva1ZpZGVvSWQodGlrdG9rVXJsKTtcclxuICAgICAgaWYgKCF2aWRlb0lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldEV4dHJhY3Rpb25FcnJvck1lc3NhZ2UodGlrdG9rVXJsLCAndmlkZW8nKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9wdWJsaWMvdmlkZW8/aWQ9JHt2aWRlb0lkfWAsIHtcclxuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgXCJYLUFQSS1LRVlcIjogdGhpcy5hcGlLZXkhLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpa0FQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3JEYXRhKX1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5pdGVtSW5mbyB8fCAhZGF0YS5pdGVtSW5mby5pdGVtU3RydWN0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gZGF0YSByZXR1cm5lZCBmcm9tIFRpa0FQSVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdmlkZW9EYXRhID0gZGF0YS5pdGVtSW5mby5pdGVtU3RydWN0O1xyXG4gICAgICBjb25zdCBzdGF0cyA9IHZpZGVvRGF0YS5zdGF0cyB8fCB7fTtcclxuICAgICAgY29uc3QgbXVzaWNEYXRhID0gdmlkZW9EYXRhLm11c2ljIHx8IHt9O1xyXG4gICAgICBjb25zdCBhdXRob3JTdGF0cyA9IHZpZGVvRGF0YS5hdXRob3JTdGF0cyB8fCB7fTtcclxuICAgICAgY29uc3QgYXV0aG9yID0gdmlkZW9EYXRhLmF1dGhvciB8fCB7fTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdmlkZW9JZDogdmlkZW9EYXRhLmlkIHx8IFwiXCIsXHJcbiAgICAgICAgdmlld3M6IHN0YXRzLnBsYXlDb3VudCB8fCAwLFxyXG4gICAgICAgIGxpa2VzOiBzdGF0cy5kaWdnQ291bnQgfHwgMCxcclxuICAgICAgICBjb21tZW50czogc3RhdHMuY29tbWVudENvdW50IHx8IDAsXHJcbiAgICAgICAgc2hhcmVzOiBzdGF0cy5zaGFyZUNvdW50IHx8IDAsXHJcbiAgICAgICAgZHVyYXRpb246IHZpZGVvRGF0YS52aWRlbz8uZHVyYXRpb24gfHwgMCxcclxuICAgICAgICBzb3VuZElkOiBtdXNpY0RhdGEuaWQsXHJcbiAgICAgICAgc291bmROYW1lOiBtdXNpY0RhdGEudGl0bGUgfHwgbXVzaWNEYXRhLmF1dGhvck5hbWUsXHJcbiAgICAgICAgY3JlYXRvckZvbGxvd2VyczogYXV0aG9yU3RhdHMuZm9sbG93ZXJDb3VudCB8fCAwLFxyXG4gICAgICAgIGNyZWF0b3JVc2VybmFtZTogYXV0aG9yLnVuaXF1ZUlkIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiVGlrQVBJIHNjcmFwaW5nIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHZlcmlmeSB2aWRlbyB3aXRoIFRpa0FQSTogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NyYXBlIHNvbmcgZGF0YSB1c2luZyBUaWtBUElcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHNjcmFwZVNvbmdXaXRoVGlrQVBJKHRpa3Rva1VybDogc3RyaW5nKTogUHJvbWlzZTxUaWtUb2tTb25nRGF0YT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIG11c2ljIFVSTCBvciB2aWRlbyBVUkwgdXNpbmcgY2VudHJhbGl6ZWQgdXRpbGl0eVxyXG4gICAgICBjb25zdCBtdXNpY0lkID0gZXh0cmFjdFRpa1Rva011c2ljSWQodGlrdG9rVXJsKTtcclxuXHJcbiAgICAgIGlmIChtdXNpY0lkKSB7XHJcbiAgICAgICAgLy8gRGlyZWN0IG11c2ljIFVSTCAtIGZldGNoIG11c2ljIGRldGFpbHNcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaE11c2ljQnlJZChtdXNpY0lkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBWaWRlbyBVUkwgLSBleHRyYWN0IG11c2ljIGZyb20gdmlkZW9cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaE11c2ljRnJvbVZpZGVvKHRpa3Rva1VybCk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlRpa0FQSSBzb25nIHNjcmFwaW5nIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHNvbmcgZGV0YWlscyBmcm9tIFRpa0FQSTogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmV0Y2ggbXVzaWMgZGV0YWlscyBieSBtdXNpYyBJRFxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hNdXNpY0J5SWQobXVzaWNJZDogc3RyaW5nKTogUHJvbWlzZTxUaWtUb2tTb25nRGF0YT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L3B1YmxpYy9tdXNpYy9pbmZvP2lkPSR7bXVzaWNJZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIFwiWC1BUEktS0VZXCI6IHRoaXMuYXBpS2V5ISxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaWtBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gLSAke0pTT04uc3RyaW5naWZ5KGVycm9yRGF0YSl9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubXVzaWNJbmZvIHx8ICFkYXRhLm11c2ljSW5mby5tdXNpYykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG11c2ljIGRhdGEgcmV0dXJuZWQgZnJvbSBUaWtBUElcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG11c2ljRGF0YSA9IGRhdGEubXVzaWNJbmZvLm11c2ljO1xyXG5cclxuICAgICAgLy8gQ29uc3RydWN0IHByb3BlciBUaWtUb2sgbXVzaWMgVVJMIHdpdGggc29uZyBuYW1lXHJcbiAgICAgIGNvbnN0IHNvbmdUaXRsZSA9IChtdXNpY0RhdGEudGl0bGUgfHwgXCJzb25nXCIpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAucmVwbGFjZSgvW15hLXowLTlcXHMtXS9nLCAnJykgLy8gUmVtb3ZlIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICctJykgICAgICAgICAgLy8gUmVwbGFjZSBzcGFjZXMgd2l0aCBoeXBoZW5zXHJcbiAgICAgICAgLnJlcGxhY2UoLy0rL2csICctJykgICAgICAgICAgICAvLyBSZXBsYWNlIG11bHRpcGxlIGh5cGhlbnMgd2l0aCBzaW5nbGVcclxuICAgICAgICAudHJpbSgpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0aXRsZTogbXVzaWNEYXRhLnRpdGxlIHx8IFwiVW5rbm93biBTb25nXCIsXHJcbiAgICAgICAgZHVyYXRpb246IG11c2ljRGF0YS5kdXJhdGlvbiB8fCAzMCxcclxuICAgICAgICBjb3ZlckltYWdlOiBtdXNpY0RhdGEuY292ZXJMYXJnZSB8fCBtdXNpY0RhdGEuY292ZXJNZWRpdW0gfHwgbXVzaWNEYXRhLmNvdmVyVGh1bWIsXHJcbiAgICAgICAgdGlrdG9rVXJsOiBgaHR0cHM6Ly93d3cudGlrdG9rLmNvbS9tdXNpYy8ke3NvbmdUaXRsZX0tJHttdXNpY0RhdGEuaWR9YCxcclxuICAgICAgICBhdXRob3JOYW1lOiBtdXNpY0RhdGEuYXV0aG9yTmFtZSxcclxuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiVGlrQVBJIG11c2ljIGZldGNoIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG11c2ljIGJ5IElEOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0IG11c2ljIGZyb20gdmlkZW9cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGZldGNoTXVzaWNGcm9tVmlkZW8odGlrdG9rVXJsOiBzdHJpbmcpOiBQcm9taXNlPFRpa1Rva1NvbmdEYXRhPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBFeHRyYWN0IHZpZGVvIElEIGZyb20gVVJMIHVzaW5nIGNlbnRyYWxpemVkIHV0aWxpdHlcclxuICAgICAgY29uc3QgdmlkZW9JZCA9IGV4dHJhY3RUaWtUb2tWaWRlb0lkKHRpa3Rva1VybCk7XHJcbiAgICAgIGlmICghdmlkZW9JZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFeHRyYWN0aW9uRXJyb3JNZXNzYWdlKHRpa3Rva1VybCwgJ3ZpZGVvJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vcHVibGljL3ZpZGVvP2lkPSR7dmlkZW9JZH1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIFwiWC1BUEktS0VZXCI6IHRoaXMuYXBpS2V5ISxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaWtBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0gLSAke0pTT04uc3RyaW5naWZ5KGVycm9yRGF0YSl9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuaXRlbUluZm8gfHwgIWRhdGEuaXRlbUluZm8uaXRlbVN0cnVjdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGRhdGEgcmV0dXJuZWQgZnJvbSBUaWtBUElcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHZpZGVvRGF0YSA9IGRhdGEuaXRlbUluZm8uaXRlbVN0cnVjdDtcclxuICAgICAgY29uc3QgbXVzaWNEYXRhID0gdmlkZW9EYXRhLm11c2ljIHx8IHt9O1xyXG5cclxuICAgICAgLy8gQ29uc3RydWN0IHByb3BlciBUaWtUb2sgbXVzaWMgVVJMIHdpdGggc29uZyBuYW1lXHJcbiAgICAgIGNvbnN0IHNvbmdUaXRsZSA9IChtdXNpY0RhdGEudGl0bGUgfHwgXCJzb25nXCIpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAucmVwbGFjZSgvW15hLXowLTlcXHMtXS9nLCAnJykgLy8gUmVtb3ZlIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG4gICAgICAgIC5yZXBsYWNlKC9cXHMrL2csICctJykgICAgICAgICAgLy8gUmVwbGFjZSBzcGFjZXMgd2l0aCBoeXBoZW5zXHJcbiAgICAgICAgLnJlcGxhY2UoLy0rL2csICctJykgICAgICAgICAgICAvLyBSZXBsYWNlIG11bHRpcGxlIGh5cGhlbnMgd2l0aCBzaW5nbGVcclxuICAgICAgICAudHJpbSgpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0aXRsZTogbXVzaWNEYXRhLnRpdGxlIHx8IFwiVW5rbm93biBTb25nXCIsXHJcbiAgICAgICAgZHVyYXRpb246IG11c2ljRGF0YS5kdXJhdGlvbiB8fCAzMCxcclxuICAgICAgICBjb3ZlckltYWdlOiBtdXNpY0RhdGEuY292ZXJMYXJnZSB8fCBtdXNpY0RhdGEuY292ZXJNZWRpdW0gfHwgbXVzaWNEYXRhLmNvdmVyVGh1bWIsXHJcbiAgICAgICAgdGlrdG9rVXJsOiBgaHR0cHM6Ly93d3cudGlrdG9rLmNvbS9tdXNpYy8ke3NvbmdUaXRsZX0tJHttdXNpY0RhdGEuaWR9YCxcclxuICAgICAgICBhdXRob3JOYW1lOiBtdXNpY0RhdGEuYXV0aG9yTmFtZSxcclxuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiVGlrQVBJIHZpZGVvLXRvLW11c2ljIGZldGNoIGVycm9yOlwiLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4dHJhY3QgbXVzaWMgZnJvbSB2aWRlbzogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG1vY2sgc29uZyBkYXRhIGZvciBkZXZlbG9wbWVudCAod2hlbiBubyBBUEkga2V5IGlzIGF2YWlsYWJsZSlcclxuICAgKi9cclxuICBwcml2YXRlIGdldE1vY2tTb25nRGF0YSh0aWt0b2tVcmw6IHN0cmluZyk6IFRpa1Rva1NvbmdEYXRhIHtcclxuICAgIC8vIEF0dGVtcHQgdG8gZXh0cmFjdCBzb21lIHZhbGlkLWxvb2tpbmcgSUQgb3IgbmFtZSBmcm9tIFVSTCBmb3IgYmV0dGVyIG1vY2sgZGF0YVxyXG4gICAgY29uc3QgdXJsUGFydHMgPSB0aWt0b2tVcmwuc3BsaXQoJy8nKTtcclxuICAgIGNvbnN0IGxhc3RQYXJ0ID0gdXJsUGFydHNbdXJsUGFydHMubGVuZ3RoIC0gMV0gfHwgXCJkYXRhc2V0XCI7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGl0bGU6IGBTb25nIGZyb20gJHtsYXN0UGFydC5zdWJzdHJpbmcoMCwgMTUpfS4uLmAsXHJcbiAgICAgIGR1cmF0aW9uOiA2MCwgLy8gRGVmYXVsdCA2MHMgZm9yIG1vY2tcclxuICAgICAgY292ZXJJbWFnZTogdW5kZWZpbmVkLFxyXG4gICAgICB0aWt0b2tVcmw6IHRpa3Rva1VybCxcclxuICAgICAgYXV0aG9yTmFtZTogXCJVbmtub3duIEFydGlzdCAoTW9jaylcIixcclxuICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgbW9jayBkYXRhIGZvciBkZXZlbG9wbWVudCAod2hlbiBubyBBUEkga2V5IGlzIGF2YWlsYWJsZSlcclxuICAgKi9cclxuICBwcml2YXRlIGdldE1vY2tEYXRhKHZpZGVvSWQ6IHN0cmluZyk6IFRpa1Rva1ZpZGVvRGF0YSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB2aWRlb0lkLFxyXG4gICAgICB2aWV3czogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApICsgMTAwMCxcclxuICAgICAgbGlrZXM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApICsgMTAwLFxyXG4gICAgICBjb21tZW50czogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKSArIDEwLFxyXG4gICAgICBzaGFyZXM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMCkgKyA1MCxcclxuICAgICAgZHVyYXRpb246IDI1LCAvLyAyNSBzZWNvbmRzXHJcbiAgICAgIHNvdW5kSWQ6IFwibW9jay1zb3VuZC1pZFwiLFxyXG4gICAgICBzb3VuZE5hbWU6IFwiTW9jayBTb25nIE5hbWVcIixcclxuICAgICAgY3JlYXRvckZvbGxvd2VyczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNTAwMDApICsgNTAwMCxcclxuICAgICAgY3JlYXRvclVzZXJuYW1lOiBcIm1vY2t1c2VyXCIsXHJcbiAgICAgIGlzVmFsaWQ6IHRydWUsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG1vY2sgbXVzaWMgaW5mbyBmb3IgZGV2ZWxvcG1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIGdldE1vY2tNdXNpY0luZm8obXVzaWNJZDogc3RyaW5nKTogVGlrVG9rTXVzaWNJbmZvIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG11c2ljSWQsXHJcbiAgICAgIHRpdGxlOiBcIk1vY2sgU29uZyBUaXRsZVwiLFxyXG4gICAgICBhdXRob3JOYW1lOiBcIk1vY2sgQXJ0aXN0XCIsXHJcbiAgICAgIGR1cmF0aW9uOiAzMCxcclxuICAgICAgY292ZXJJbWFnZTogdW5kZWZpbmVkLCAvLyBObyBwbGFjZWhvbGRlciBpbWFnZSBmb3IgbW9jayBkYXRhXHJcbiAgICAgIHZpZGVvQ291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMDAwKSArIDUwMDAsIC8vIFRpa0FQSSBvbmx5IHByb3ZpZGVzIHZpZGVvQ291bnRcclxuICAgICAgdGlrdG9rVXJsOiBgaHR0cHM6Ly93d3cudGlrdG9rLmNvbS9tdXNpYy9tb2NrLXNvbmctdGl0bGUtJHttdXNpY0lkfWAsXHJcbiAgICAgIGlzVmFsaWQ6IHRydWUsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG1vY2sgbXVzaWMgcG9zdHMgZm9yIGRldmVsb3BtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRNb2NrTXVzaWNQb3N0cyhtdXNpY0lkOiBzdHJpbmcsIGxpbWl0OiBudW1iZXIpOiBUaWtUb2tNdXNpY1Bvc3RbXSB7XHJcbiAgICBjb25zdCBwb3N0czogVGlrVG9rTXVzaWNQb3N0W10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcclxuICAgICAgcG9zdHMucHVzaCh7XHJcbiAgICAgICAgdmlkZW9JZDogYG1vY2stdmlkZW8tJHtpfS0ke0RhdGUubm93KCl9YCxcclxuICAgICAgICB2aWRlb1VybDogYGh0dHBzOi8vd3d3LnRpa3Rvay5jb20vQG1vY2t1c2VyJHtpfS92aWRlby8xMjM0NTY3ODkke2l9YCxcclxuICAgICAgICBhdXRob3I6IHtcclxuICAgICAgICAgIHVuaXF1ZUlkOiBgbW9ja3VzZXIke2l9YCxcclxuICAgICAgICAgIG5pY2tuYW1lOiBgTW9jayBDcmVhdG9yICR7aSArIDF9YCxcclxuICAgICAgICAgIGF2YXRhclRodW1iOiB1bmRlZmluZWQsIC8vIE5vIHBsYWNlaG9sZGVyIGltYWdlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGF0czoge1xyXG4gICAgICAgICAgcGxheUNvdW50OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDAwMDApICsgMTAwMDAsXHJcbiAgICAgICAgICBkaWdnQ291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMDAwKSArIDEwMDAsXHJcbiAgICAgICAgICBjb21tZW50Q291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwMDApICsgMTAwLFxyXG4gICAgICAgICAgc2hhcmVDb3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApICsgNTAwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzYzogYE1vY2sgdmlkZW8gZGVzY3JpcHRpb24gZm9yIHRyZW5kaW5nIHZpZGVvICR7aSArIDF9IHVzaW5nIHRoaXMgbXVzaWNgLFxyXG4gICAgICAgIGNyZWF0ZVRpbWU6IERhdGUubm93KCkgLyAxMDAwIC0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogODY0MDAgKiA3KSxcclxuICAgICAgICBjb3ZlckltYWdlOiB1bmRlZmluZWQsIC8vIE5vIHBsYWNlaG9sZGVyIGltYWdlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb3N0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZlcmlmeSBpZiB2aWRlbyB1c2VzIHRoZSBjb3JyZWN0IHNvbmdcclxuICAgKi9cclxuICB2ZXJpZnlTb25nKHZpZGVvRGF0YTogVGlrVG9rVmlkZW9EYXRhLCBleHBlY3RlZFNvbmdUaXRsZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIXZpZGVvRGF0YS5zb3VuZE5hbWUpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpbXBsZSBzdHJpbmcgbWF0Y2hpbmcgKGNhbiBiZSBpbXByb3ZlZCB3aXRoIGZ1enp5IG1hdGNoaW5nKVxyXG4gICAgcmV0dXJuIHZpZGVvRGF0YS5zb3VuZE5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhleHBlY3RlZFNvbmdUaXRsZS50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICBleHBlY3RlZFNvbmdUaXRsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZpZGVvRGF0YS5zb3VuZE5hbWUudG9Mb3dlckNhc2UoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgc3VibWlzc2lvbiB3aXRoIHZpZGVvIGRhdGFcclxuICAgKi9cclxuICBhc3luYyB1cGRhdGVTdWJtaXNzaW9uRGF0YShzdWJtaXNzaW9uSWQ6IHN0cmluZywgdmlkZW9EYXRhOiBUaWtUb2tWaWRlb0RhdGEpIHtcclxuICAgIGNvbnN0IHsgcHJpc21hIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9wcmlzbWFcIik7XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IHByaXNtYS5zdWJtaXNzaW9uLnVwZGF0ZSh7XHJcbiAgICAgIHdoZXJlOiB7IGlkOiBzdWJtaXNzaW9uSWQgfSxcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIHRpa3Rva1ZpZGVvSWQ6IHZpZGVvRGF0YS52aWRlb0lkLFxyXG4gICAgICAgIGxhc3RWaWV3Q291bnQ6IHZpZGVvRGF0YS52aWV3cyxcclxuICAgICAgICBsYXN0TGlrZUNvdW50OiB2aWRlb0RhdGEubGlrZXMsXHJcbiAgICAgICAgbGFzdENvbW1lbnRDb3VudDogdmlkZW9EYXRhLmNvbW1lbnRzLFxyXG4gICAgICAgIGxhc3RTaGFyZUNvdW50OiB2aWRlb0RhdGEuc2hhcmVzLFxyXG4gICAgICAgIHZpZGVvRHVyYXRpb246IHZpZGVvRGF0YS5kdXJhdGlvbixcclxuICAgICAgICBjcmVhdG9yRm9sbG93ZXJzOiB2aWRlb0RhdGEuY3JlYXRvckZvbGxvd2VycyxcclxuICAgICAgICB2ZXJpZmllZDogdHJ1ZSxcclxuICAgICAgICB2ZXJpZmllZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIGxhc3RDaGVja2VkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIFRpa1RvayB1c2VyIHByb2ZpbGUgYnkgdXNlcm5hbWVcclxuICAgKiBVc2VzIC9wdWJsaWMvY2hlY2sgZW5kcG9pbnQgZnJvbSBUaWtBUEkgd2l0aCBjYWNoaW5nICgyNGggVFRMKVxyXG4gICAqL1xyXG4gIGFzeW5jIGNoZWNrVXNlclByb2ZpbGUodXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8VGlrVG9rVXNlclByb2ZpbGU+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFJlbW92ZSBAIGlmIHByZXNlbnRcclxuICAgICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnJlcGxhY2UoL15ALywgXCJcIik7XHJcblxyXG4gICAgICAvLyBWYWxpZGF0ZSB1c2VybmFtZSBmb3JtYXQgKGFscGhhbnVtZXJpYywgdW5kZXJzY29yZXMsIG5vIHNwYWNlcylcclxuICAgICAgaWYgKCEvXlthLXpBLVowLTkuX10rJC8udGVzdChjbGVhblVzZXJuYW1lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVGlrVG9rIHVzZXJuYW1lIGZvcm1hdFwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcclxuICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2FjaGVTZXJ2aWNlLmdldChjbGVhblVzZXJuYW1lLCBcInVzZXJfcHJvZmlsZVwiKTtcclxuICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQgYXMgVGlrVG9rVXNlclByb2ZpbGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIG5vIEFQSSBrZXksIHJldHVybiBtb2NrIGRhdGFcclxuICAgICAgaWYgKCF0aGlzLmFwaUtleSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIuKaoO+4jyBObyBUSUtfQVBJX0tFWSBmb3VuZCwgdXNpbmcgbW9jayBkYXRhXCIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vY2tVc2VyUHJvZmlsZShjbGVhblVzZXJuYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmV0Y2ggZnJvbSBUaWtBUElcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L3B1YmxpYy9jaGVjaz91c2VybmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudChjbGVhblVzZXJuYW1lKX1gLCB7XHJcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgIFwiWC1BUEktS0VZXCI6IHRoaXMuYXBpS2V5LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIGVycm9yIGNhc2VzXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0IHx8IGVycm9yRGF0YS5tZXNzYWdlPy5pbmNsdWRlcyhcIm5vdCBmb3VuZFwiKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGlrVG9rIHVzZXIgbm90IGZvdW5kXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkgfHwgZXJyb3JEYXRhLm1lc3NhZ2U/LmluY2x1ZGVzKFwicmF0ZSBsaW1pdFwiKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmF0ZSBsaW1pdCBleGNlZWRlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpa0FQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3JEYXRhKX1gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS51c2VySW5mbyB8fCAhZGF0YS51c2VySW5mby51c2VyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXNlciBkYXRhIHJldHVybmVkIGZyb20gVGlrQVBJXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGRhdGEudXNlckluZm8udXNlcjtcclxuICAgICAgY29uc3Qgc3RhdHMgPSBkYXRhLnVzZXJJbmZvLnN0YXRzIHx8IHt9O1xyXG5cclxuICAgICAgY29uc3QgcHJvZmlsZTogVGlrVG9rVXNlclByb2ZpbGUgPSB7XHJcbiAgICAgICAgdW5pcXVlSWQ6IHVzZXJEYXRhLnVuaXF1ZUlkIHx8IGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgbmlja25hbWU6IHVzZXJEYXRhLm5pY2tuYW1lIHx8IGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgYXZhdGFyOiB1c2VyRGF0YS5hdmF0YXJUaHVtYiB8fCB1c2VyRGF0YS5hdmF0YXJNZWRpdW0sXHJcbiAgICAgICAgYXZhdGFyTGFyZ2VyOiB1c2VyRGF0YS5hdmF0YXJMYXJnZXIgfHwgdXNlckRhdGEuYXZhdGFyTWVkaXVtLFxyXG4gICAgICAgIHNpZ25hdHVyZTogdXNlckRhdGEuc2lnbmF0dXJlIHx8IFwiXCIsXHJcbiAgICAgICAgZm9sbG93ZXJDb3VudDogc3RhdHMuZm9sbG93ZXJDb3VudCA/PyAwLFxyXG4gICAgICAgIGZvbGxvd2luZ0NvdW50OiBzdGF0cy5mb2xsb3dpbmdDb3VudCA/PyAwLFxyXG4gICAgICAgIHZpZGVvQ291bnQ6IHN0YXRzLnZpZGVvQ291bnQgPz8gMCxcclxuICAgICAgICBoZWFydENvdW50OiBzdGF0cy5oZWFydENvdW50ID8/IDAsXHJcbiAgICAgICAgaXNWZXJpZmllZDogdXNlckRhdGEudmVyaWZpZWQgfHwgZmFsc2UsXHJcbiAgICAgICAgaXNQcml2YXRlOiB1c2VyRGF0YS5wcml2YXRlQWNjb3VudCB8fCBmYWxzZSxcclxuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxyXG4gICAgICBhd2FpdCBjYWNoZVNlcnZpY2Uuc2V0KFxyXG4gICAgICAgIGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgXCJ1c2VyX3Byb2ZpbGVcIixcclxuICAgICAgICBwcm9maWxlLFxyXG4gICAgICAgIENBQ0hFX1RUTC5VU0VSX1BST0ZJTEVcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBwcm9maWxlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiVGlrQVBJIHVzZXIgcHJvZmlsZSBjaGVjayBlcnJvcjpcIiwgZXJyb3IpO1xyXG5cclxuICAgICAgLy8gSWYgaXQncyBhIHZhbGlkYXRpb24gZXJyb3Igb3Igbm90IGZvdW5kLCB0aHJvdyBpdFxyXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoXCJJbnZhbGlkXCIpIHx8IGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKFwibm90IGZvdW5kXCIpKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZvciBvdGhlciBlcnJvcnMsIHJldHVybiBtb2NrIGRhdGFcclxuICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIEVycm9yIGZldGNoaW5nIHVzZXIgcHJvZmlsZSwgdXNpbmcgbW9jayBkYXRhXCIpO1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRNb2NrVXNlclByb2ZpbGUodXNlcm5hbWUucmVwbGFjZSgvXkAvLCBcIlwiKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgbW9jayB1c2VyIHByb2ZpbGUgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIGdldE1vY2tVc2VyUHJvZmlsZSh1c2VybmFtZTogc3RyaW5nKTogVGlrVG9rVXNlclByb2ZpbGUge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdW5pcXVlSWQ6IHVzZXJuYW1lLFxyXG4gICAgICBuaWNrbmFtZTogYCR7dXNlcm5hbWV9IChNb2NrKWAsXHJcbiAgICAgIGF2YXRhcjogYGh0dHBzOi8vYXBpLmRpY2ViZWFyLmNvbS85LngvYXZhdGFhYXJzL3BuZz9zZWVkPSR7dXNlcm5hbWV9YCxcclxuICAgICAgYXZhdGFyTGFyZ2VyOiBgaHR0cHM6Ly9hcGkuZGljZWJlYXIuY29tLzkueC9hdmF0YWFhcnMvcG5nP3NlZWQ9JHt1c2VybmFtZX1gLFxyXG4gICAgICBzaWduYXR1cmU6IFwiVGhpcyBpcyBtb2NrIHByb2ZpbGUgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcIixcclxuICAgICAgZm9sbG93ZXJDb3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKSArIDEwMDAsXHJcbiAgICAgIGZvbGxvd2luZ0NvdW50OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSArIDEwMCxcclxuICAgICAgdmlkZW9Db3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNTAwKSArIDEwLFxyXG4gICAgICBoZWFydENvdW50OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKSArIDEwMDAwLFxyXG4gICAgICBpc1ZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgaXNQcml2YXRlOiBmYWxzZSxcclxuICAgICAgaXNWYWxpZDogdHJ1ZSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBMYXp5LWxvYWQgVGlrVG9rIHNjcmFwZXIgdG8gYXZvaWQgYmxvY2tpbmcgd29ya2VyIHN0YXJ0dXBcclxubGV0IF90aWt0b2tTY3JhcGVyOiBUaWtUb2tTY3JhcGVyU2VydmljZSB8IG51bGwgPSBudWxsO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRpa1Rva1NjcmFwZXIgPSAoKSA9PiB7XHJcbiAgaWYgKCFfdGlrdG9rU2NyYXBlcikge1xyXG4gICAgX3Rpa3Rva1NjcmFwZXIgPSBuZXcgVGlrVG9rU2NyYXBlclNlcnZpY2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIF90aWt0b2tTY3JhcGVyO1xyXG59O1xyXG5cclxuLy8gRXhwb3J0IGFzIFByb3h5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcbmV4cG9ydCBjb25zdCB0aWt0b2tTY3JhcGVyID0gbmV3IFByb3h5KHt9IGFzIFRpa1Rva1NjcmFwZXJTZXJ2aWNlLCB7XHJcbiAgZ2V0KF90YXJnZXQsIHByb3ApIHtcclxuICAgIGNvbnN0IHNlcnZpY2UgPSBnZXRUaWtUb2tTY3JhcGVyKCk7XHJcbiAgICBjb25zdCB2YWx1ZSA9IChzZXJ2aWNlIGFzIGFueSlbcHJvcF07XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZS5iaW5kKHNlcnZpY2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IHR5cGUgeyBUaWtUb2tWaWRlb0RhdGEsIFRpa1Rva1NvbmdEYXRhLCBUaWtUb2tNdXNpY0luZm8sIFRpa1Rva011c2ljUG9zdCwgVGlrVG9rVXNlclByb2ZpbGUgfTtcclxuIl0sIm5hbWVzIjpbImNhY2hlU2VydmljZSIsIkNBQ0hFX1RUTCIsImV4dHJhY3RUaWtUb2tNdXNpY0lkIiwiZXh0cmFjdFRpa1Rva1ZpZGVvSWQiLCJnZXRFeHRyYWN0aW9uRXJyb3JNZXNzYWdlIiwiVGlrVG9rU2NyYXBlclNlcnZpY2UiLCJjb25zdHJ1Y3RvciIsImJhc2VVcmwiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiVElLX0FQSV9LRVkiLCJmZXRjaE11c2ljSW5mbyIsIm11c2ljSWQiLCJ1c2VDYWNoZSIsImNhY2hlZCIsImdldCIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0TW9ja011c2ljSW5mbyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJFcnJvciIsInN0YXR1c1RleHQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsIm11c2ljSW5mbyIsIm11c2ljIiwibXVzaWNEYXRhIiwic3RhdHNEYXRhIiwic3RhdHMiLCJzb25nVGl0bGUiLCJ0aXRsZSIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsInRyaW0iLCJpZCIsImF1dGhvck5hbWUiLCJkdXJhdGlvbiIsImNvdmVySW1hZ2UiLCJjb3ZlckxhcmdlIiwiY292ZXJNZWRpdW0iLCJjb3ZlclRodW1iIiwidmlkZW9Db3VudCIsInRpa3Rva1VybCIsImlzVmFsaWQiLCJzZXQiLCJNVVNJQ19JTkZPIiwiZXJyb3IiLCJmZXRjaE11c2ljUG9zdHMiLCJsaW1pdCIsImdldE1vY2tNdXNpY1Bvc3RzIiwiaXRlbUxpc3QiLCJwb3N0cyIsIm1hcCIsIml0ZW0iLCJ2aWRlb0lkIiwidmlkZW9VcmwiLCJhdXRob3IiLCJ1bmlxdWVJZCIsIm5pY2tuYW1lIiwiYXZhdGFyVGh1bWIiLCJwbGF5Q291bnQiLCJkaWdnQ291bnQiLCJjb21tZW50Q291bnQiLCJzaGFyZUNvdW50IiwiZGVzYyIsImNyZWF0ZVRpbWUiLCJEYXRlIiwibm93IiwidmlkZW8iLCJjb3ZlciIsImR5bmFtaWNDb3ZlciIsIlRSRU5ESU5HX1ZJREVPUyIsImZldGNoU29uZ0RldGFpbHMiLCJhcGlFcnJvciIsInNjcmFwZVNvbmdXaXRoVGlrQVBJIiwiZ2V0TW9ja1NvbmdEYXRhIiwidmVyaWZ5VmlkZW8iLCJ2aWRlb0RhdGEiLCJzY3JhcGVXaXRoVGlrQVBJIiwiVklERU9fVkVSSUZJQ0FUSU9OIiwiZ2V0TW9ja0RhdGEiLCJpdGVtSW5mbyIsIml0ZW1TdHJ1Y3QiLCJhdXRob3JTdGF0cyIsInZpZXdzIiwibGlrZXMiLCJjb21tZW50cyIsInNoYXJlcyIsInNvdW5kSWQiLCJzb3VuZE5hbWUiLCJjcmVhdG9yRm9sbG93ZXJzIiwiZm9sbG93ZXJDb3VudCIsImNyZWF0b3JVc2VybmFtZSIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJmZXRjaE11c2ljQnlJZCIsImZldGNoTXVzaWNGcm9tVmlkZW8iLCJ1cmxQYXJ0cyIsInNwbGl0IiwibGFzdFBhcnQiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJpIiwicHVzaCIsInZlcmlmeVNvbmciLCJleHBlY3RlZFNvbmdUaXRsZSIsImluY2x1ZGVzIiwidXBkYXRlU3VibWlzc2lvbkRhdGEiLCJzdWJtaXNzaW9uSWQiLCJwcmlzbWEiLCJzdWJtaXNzaW9uIiwidXBkYXRlIiwid2hlcmUiLCJ0aWt0b2tWaWRlb0lkIiwibGFzdFZpZXdDb3VudCIsImxhc3RMaWtlQ291bnQiLCJsYXN0Q29tbWVudENvdW50IiwibGFzdFNoYXJlQ291bnQiLCJ2aWRlb0R1cmF0aW9uIiwidmVyaWZpZWQiLCJ2ZXJpZmllZEF0IiwibGFzdENoZWNrZWRBdCIsImNoZWNrVXNlclByb2ZpbGUiLCJ1c2VybmFtZSIsImNsZWFuVXNlcm5hbWUiLCJ0ZXN0IiwiZ2V0TW9ja1VzZXJQcm9maWxlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3RhdHVzIiwidXNlckluZm8iLCJ1c2VyIiwidXNlckRhdGEiLCJwcm9maWxlIiwiYXZhdGFyIiwiYXZhdGFyTWVkaXVtIiwiYXZhdGFyTGFyZ2VyIiwic2lnbmF0dXJlIiwiZm9sbG93aW5nQ291bnQiLCJoZWFydENvdW50IiwiaXNWZXJpZmllZCIsImlzUHJpdmF0ZSIsInByaXZhdGVBY2NvdW50IiwiVVNFUl9QUk9GSUxFIiwiX3Rpa3Rva1NjcmFwZXIiLCJnZXRUaWtUb2tTY3JhcGVyIiwidGlrdG9rU2NyYXBlciIsIlByb3h5IiwiX3RhcmdldCIsInByb3AiLCJzZXJ2aWNlIiwidmFsdWUiLCJiaW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/tiktok-scraper.ts\n");

/***/ }),

/***/ "(rsc)/./lib/url-utils.ts":
/*!**************************!*\
  !*** ./lib/url-utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractTikTokId: () => (/* binding */ extractTikTokId),\n/* harmony export */   extractTikTokMusicId: () => (/* binding */ extractTikTokMusicId),\n/* harmony export */   extractTikTokUsernameFromUrl: () => (/* binding */ extractTikTokUsernameFromUrl),\n/* harmony export */   extractTikTokVideoId: () => (/* binding */ extractTikTokVideoId),\n/* harmony export */   getExtractionErrorMessage: () => (/* binding */ getExtractionErrorMessage),\n/* harmony export */   normalizeTikTokUrl: () => (/* binding */ normalizeTikTokUrl),\n/* harmony export */   validateTikTokUrl: () => (/* binding */ validateTikTokUrl)\n/* harmony export */ });\n/**\n * TikTok URL Utilities\n * Centralized utilities for extracting and validating TikTok video and music IDs\n */ /**\n * Result of URL validation\n */ /**\n * Normalize a TikTok URL by removing trailing slashes, fragments, etc.\n * @param url - The URL to normalize\n * @returns Normalized URL string\n */ function normalizeTikTokUrl(url) {\n    try {\n        // Trim whitespace\n        let normalized = url.trim();\n        // Remove trailing slashes\n        normalized = normalized.replace(/\\/+$/, \"\");\n        // Remove URL fragments (#section)\n        normalized = normalized.split(\"#\")[0];\n        return normalized;\n    } catch (error) {\n        return url;\n    }\n}\n/**\n * Extract TikTok music ID from a URL\n * Supports formats:\n * - https://www.tiktok.com/music/Song-Name-7565543138765392652\n * - https://www.tiktok.com/music/original-sound-1234567890\n * - https://vm.tiktok.com/ABC123/\n * - ?musicId=1234567890\n * \n * @param url - The TikTok music URL\n * @returns Music ID (numeric string) or short link, null if extraction fails\n */ function extractTikTokMusicId(url) {\n    try {\n        // Normalize URL\n        const normalized = normalizeTikTokUrl(url);\n        // Pattern 1: Full music URLs - /music/song-name-[ID]\n        // Handles: https://www.tiktok.com/music/Khim-10s-7565543138765392652\n        const musicUrlPattern = /\\/music\\/[^\\/\\?#]+-(\\d+)/i;\n        const musicMatch = normalized.match(musicUrlPattern);\n        if (musicMatch && musicMatch[1]) {\n            const id = musicMatch[1];\n            // Validate ID (TikTok IDs are typically 10-20 digits)\n            if (id.length >= 6 && id.length <= 25) {\n                return id;\n            } else {\n                console.warn(\"⚠️ Music ID length unusual:\", id.length, \"digits\");\n                return id; // Return anyway but log warning\n            }\n        }\n        // Pattern 2: Query parameter - ?musicId=1234567890\n        const queryPattern = /[?&]musicId=(\\d+)/i;\n        const queryMatch = normalized.match(queryPattern);\n        if (queryMatch && queryMatch[1]) {\n            const id = queryMatch[1];\n            return id;\n        }\n        // Pattern 3: Short links - vm.tiktok.com/ABC or vt.tiktok.com/ABC\n        // TikAPI can resolve these directly\n        const shortLinkPattern = /(v[mt]\\.tiktok\\.com\\/[A-Za-z0-9]+)/i;\n        const shortMatch = normalized.match(shortLinkPattern);\n        if (shortMatch && shortMatch[1]) {\n            const shortLink = shortMatch[1];\n            return shortLink;\n        }\n        console.warn(\"❌ Failed to extract Music ID from:\", url);\n        return null;\n    } catch (error) {\n        console.error(\"Error extracting music ID:\", error);\n        return null;\n    }\n}\n/**\n * Extract TikTok video ID from a URL\n * Supports formats:\n * - https://www.tiktok.com/@username/video/7003402629929913605\n * - https://vt.tiktok.com/ZSabcdefg/\n * - https://vm.tiktok.com/ZMabcdefg/\n * \n * @param url - The TikTok video URL\n * @returns Video ID (numeric string) or short link, null if extraction fails\n */ function extractTikTokVideoId(url) {\n    try {\n        // Normalize URL\n        const normalized = normalizeTikTokUrl(url);\n        // Pattern 1: Full video URLs - /@username/video/[ID]\n        // Handles: https://www.tiktok.com/@hayleybuix/video/7003402629929913605\n        const videoUrlPattern = /\\/video\\/(\\d+)/i;\n        const videoMatch = normalized.match(videoUrlPattern);\n        if (videoMatch && videoMatch[1]) {\n            const id = videoMatch[1];\n            // Validate ID (TikTok IDs are typically 10-20 digits)\n            if (id.length >= 6 && id.length <= 25) {\n                return id;\n            } else {\n                console.warn(\"⚠️ Video ID length unusual:\", id.length, \"digits\");\n                return id; // Return anyway but log warning\n            }\n        }\n        // Pattern 2: Short links - vm.tiktok.com/ABC or vt.tiktok.com/ABC\n        // TikAPI can resolve these directly\n        const shortLinkPattern = /(v[mt]\\.tiktok\\.com\\/[A-Za-z0-9]+)/i;\n        const shortMatch = normalized.match(shortLinkPattern);\n        if (shortMatch && shortMatch[1]) {\n            const shortLink = shortMatch[1];\n            return shortLink;\n        }\n        console.warn(\"❌ Failed to extract Video ID from:\", url);\n        return null;\n    } catch (error) {\n        console.error(\"Error extracting video ID:\", error);\n        return null;\n    }\n}\n/**\n * Validate a TikTok URL and determine its type\n * @param url - The URL to validate\n * @returns Validation result with type information\n */ function validateTikTokUrl(url) {\n    try {\n        // Check if URL contains tiktok.com\n        if (!url.includes(\"tiktok.com\")) {\n            return {\n                isValid: false,\n                type: \"unknown\",\n                error: \"URL must be from tiktok.com\"\n            };\n        }\n        // Try to extract music ID\n        const musicId = extractTikTokMusicId(url);\n        if (musicId) {\n            return {\n                isValid: true,\n                type: musicId.includes(\"tiktok.com\") ? \"shortlink\" : \"music\"\n            };\n        }\n        // Try to extract video ID\n        const videoId = extractTikTokVideoId(url);\n        if (videoId) {\n            return {\n                isValid: true,\n                type: videoId.includes(\"tiktok.com\") ? \"shortlink\" : \"video\"\n            };\n        }\n        // Could not extract any ID\n        return {\n            isValid: false,\n            type: \"unknown\",\n            error: \"Could not extract ID from URL. Expected format: https://www.tiktok.com/music/... or @user/video/...\"\n        };\n    } catch (error) {\n        return {\n            isValid: false,\n            type: \"unknown\",\n            error: `URL validation error: ${error}`\n        };\n    }\n}\n/**\n * Extract ID with full metadata\n * @param url - The TikTok URL\n * @param type - The expected type ('music' or 'video')\n * @returns Extraction result with metadata\n */ function extractTikTokId(url, type) {\n    const originalUrl = url;\n    const extractFn = type === \"music\" ? extractTikTokMusicId : extractTikTokVideoId;\n    const id = extractFn(url);\n    if (!id) {\n        return {\n            id: \"\",\n            type,\n            originalUrl,\n            isValid: false,\n            error: `Failed to extract ${type} ID from URL. Check URL format.`\n        };\n    }\n    return {\n        id,\n        type: id.includes(\"tiktok.com\") ? \"shortlink\" : type,\n        originalUrl,\n        isValid: true\n    };\n}\n/**\n * Extract TikTok username from a video URL\n * Supports formats:\n * - https://www.tiktok.com/@username/video/7003402629929913605\n * \n * Note: Short links (vm.tiktok.com, vt.tiktok.com) cannot extract username from URL\n * and will return null. Use the API response creatorUsername field instead.\n * \n * @param url - The TikTok video URL\n * @returns Username (without @) or null if extraction fails\n */ function extractTikTokUsernameFromUrl(url) {\n    try {\n        // Normalize URL\n        const normalized = normalizeTikTokUrl(url);\n        // Pattern: /@username/video/ or /@username/\n        // Handles: https://www.tiktok.com/@hayleybuix/video/7003402629929913605\n        const usernamePattern = /\\/@([a-zA-Z0-9._]+)/i;\n        const usernameMatch = normalized.match(usernamePattern);\n        if (usernameMatch && usernameMatch[1]) {\n            const username = usernameMatch[1];\n            // Validate username format (alphanumeric, underscores, dots, no spaces)\n            if (/^[a-zA-Z0-9._]+$/.test(username)) {\n                return username.toLowerCase().trim();\n            }\n        }\n        // Short links don't contain username in URL\n        if (/v[mt]\\.tiktok\\.com/i.test(normalized)) {\n            return null;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error extracting username from URL:\", error);\n        return null;\n    }\n}\n/**\n * Get user-friendly error message for failed extraction\n * @param url - The URL that failed\n * @param type - The expected type\n * @returns User-friendly error message\n */ function getExtractionErrorMessage(url, type) {\n    if (!url.includes(\"tiktok.com\")) {\n        return \"Please provide a valid TikTok URL\";\n    }\n    if (type === \"music\") {\n        return \"Music ID not found. Please use a URL format like: https://www.tiktok.com/music/Song-Name-1234567890\";\n    }\n    return \"Video ID not found. Please use a URL format like: https://www.tiktok.com/@username/video/1234567890\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvdXJsLXV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFRDs7Q0FFQyxHQWtCRDs7OztDQUlDLEdBQ00sU0FBU0EsbUJBQW1CQyxHQUFXO0lBQzVDLElBQUk7UUFDRixrQkFBa0I7UUFDbEIsSUFBSUMsYUFBYUQsSUFBSUUsSUFBSTtRQUV6QiwwQkFBMEI7UUFDMUJELGFBQWFBLFdBQVdFLE9BQU8sQ0FBQyxRQUFRO1FBRXhDLGtDQUFrQztRQUNsQ0YsYUFBYUEsV0FBV0csS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBRXJDLE9BQU9IO0lBQ1QsRUFBRSxPQUFPSSxPQUFPO1FBQ2QsT0FBT0w7SUFDVDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLFNBQVNNLHFCQUFxQk4sR0FBVztJQUM5QyxJQUFJO1FBR0YsZ0JBQWdCO1FBQ2hCLE1BQU1DLGFBQWFGLG1CQUFtQkM7UUFFdEMscURBQXFEO1FBQ3JELHFFQUFxRTtRQUNyRSxNQUFNTyxrQkFBa0I7UUFDeEIsTUFBTUMsYUFBYVAsV0FBV1EsS0FBSyxDQUFDRjtRQUNwQyxJQUFJQyxjQUFjQSxVQUFVLENBQUMsRUFBRSxFQUFFO1lBQy9CLE1BQU1FLEtBQUtGLFVBQVUsQ0FBQyxFQUFFO1lBR3hCLHNEQUFzRDtZQUN0RCxJQUFJRSxHQUFHQyxNQUFNLElBQUksS0FBS0QsR0FBR0MsTUFBTSxJQUFJLElBQUk7Z0JBQ3JDLE9BQU9EO1lBQ1QsT0FBTztnQkFDTEUsUUFBUUMsSUFBSSxDQUFDLCtCQUErQkgsR0FBR0MsTUFBTSxFQUFFO2dCQUN2RCxPQUFPRCxJQUFJLGdDQUFnQztZQUM3QztRQUNGO1FBRUEsbURBQW1EO1FBQ25ELE1BQU1JLGVBQWU7UUFDckIsTUFBTUMsYUFBYWQsV0FBV1EsS0FBSyxDQUFDSztRQUNwQyxJQUFJQyxjQUFjQSxVQUFVLENBQUMsRUFBRSxFQUFFO1lBQy9CLE1BQU1MLEtBQUtLLFVBQVUsQ0FBQyxFQUFFO1lBRXhCLE9BQU9MO1FBQ1Q7UUFFQSxrRUFBa0U7UUFDbEUsb0NBQW9DO1FBQ3BDLE1BQU1NLG1CQUFtQjtRQUN6QixNQUFNQyxhQUFhaEIsV0FBV1EsS0FBSyxDQUFDTztRQUNwQyxJQUFJQyxjQUFjQSxVQUFVLENBQUMsRUFBRSxFQUFFO1lBQy9CLE1BQU1DLFlBQVlELFVBQVUsQ0FBQyxFQUFFO1lBRS9CLE9BQU9DO1FBQ1Q7UUFFQU4sUUFBUUMsSUFBSSxDQUFDLHNDQUFzQ2I7UUFDbkQsT0FBTztJQUNULEVBQUUsT0FBT0ssT0FBTztRQUNkTyxRQUFRUCxLQUFLLENBQUMsOEJBQThCQTtRQUM1QyxPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNNLFNBQVNjLHFCQUFxQm5CLEdBQVc7SUFDOUMsSUFBSTtRQUdGLGdCQUFnQjtRQUNoQixNQUFNQyxhQUFhRixtQkFBbUJDO1FBRXRDLHFEQUFxRDtRQUNyRCx3RUFBd0U7UUFDeEUsTUFBTW9CLGtCQUFrQjtRQUN4QixNQUFNQyxhQUFhcEIsV0FBV1EsS0FBSyxDQUFDVztRQUNwQyxJQUFJQyxjQUFjQSxVQUFVLENBQUMsRUFBRSxFQUFFO1lBQy9CLE1BQU1YLEtBQUtXLFVBQVUsQ0FBQyxFQUFFO1lBR3hCLHNEQUFzRDtZQUN0RCxJQUFJWCxHQUFHQyxNQUFNLElBQUksS0FBS0QsR0FBR0MsTUFBTSxJQUFJLElBQUk7Z0JBQ3JDLE9BQU9EO1lBQ1QsT0FBTztnQkFDTEUsUUFBUUMsSUFBSSxDQUFDLCtCQUErQkgsR0FBR0MsTUFBTSxFQUFFO2dCQUN2RCxPQUFPRCxJQUFJLGdDQUFnQztZQUM3QztRQUNGO1FBRUEsa0VBQWtFO1FBQ2xFLG9DQUFvQztRQUNwQyxNQUFNTSxtQkFBbUI7UUFDekIsTUFBTUMsYUFBYWhCLFdBQVdRLEtBQUssQ0FBQ087UUFDcEMsSUFBSUMsY0FBY0EsVUFBVSxDQUFDLEVBQUUsRUFBRTtZQUMvQixNQUFNQyxZQUFZRCxVQUFVLENBQUMsRUFBRTtZQUUvQixPQUFPQztRQUNUO1FBRUFOLFFBQVFDLElBQUksQ0FBQyxzQ0FBc0NiO1FBQ25ELE9BQU87SUFDVCxFQUFFLE9BQU9LLE9BQU87UUFDZE8sUUFBUVAsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sU0FBU2lCLGtCQUFrQnRCLEdBQVc7SUFDM0MsSUFBSTtRQUNGLG1DQUFtQztRQUNuQyxJQUFJLENBQUNBLElBQUl1QixRQUFRLENBQUMsZUFBZTtZQUMvQixPQUFPO2dCQUNMQyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNOcEIsT0FBTztZQUNUO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTXFCLFVBQVVwQixxQkFBcUJOO1FBQ3JDLElBQUkwQixTQUFTO1lBQ1gsT0FBTztnQkFDTEYsU0FBUztnQkFDVEMsTUFBTUMsUUFBUUgsUUFBUSxDQUFDLGdCQUFnQixjQUFjO1lBQ3ZEO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTUksVUFBVVIscUJBQXFCbkI7UUFDckMsSUFBSTJCLFNBQVM7WUFDWCxPQUFPO2dCQUNMSCxTQUFTO2dCQUNUQyxNQUFNRSxRQUFRSixRQUFRLENBQUMsZ0JBQWdCLGNBQWM7WUFDdkQ7UUFDRjtRQUVBLDJCQUEyQjtRQUMzQixPQUFPO1lBQ0xDLFNBQVM7WUFDVEMsTUFBTTtZQUNOcEIsT0FBTztRQUNUO0lBQ0YsRUFBRSxPQUFPQSxPQUFPO1FBQ2QsT0FBTztZQUNMbUIsU0FBUztZQUNUQyxNQUFNO1lBQ05wQixPQUFPLENBQUMsc0JBQXNCLEVBQUVBLE1BQU0sQ0FBQztRQUN6QztJQUNGO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVN1QixnQkFDZDVCLEdBQVcsRUFDWHlCLElBQXVCO0lBRXZCLE1BQU1JLGNBQWM3QjtJQUVwQixNQUFNOEIsWUFBWUwsU0FBUyxVQUFVbkIsdUJBQXVCYTtJQUM1RCxNQUFNVCxLQUFLb0IsVUFBVTlCO0lBRXJCLElBQUksQ0FBQ1UsSUFBSTtRQUNQLE9BQU87WUFDTEEsSUFBSTtZQUNKZTtZQUNBSTtZQUNBTCxTQUFTO1lBQ1RuQixPQUFPLENBQUMsa0JBQWtCLEVBQUVvQixLQUFLLCtCQUErQixDQUFDO1FBQ25FO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xmO1FBQ0FlLE1BQU1mLEdBQUdhLFFBQVEsQ0FBQyxnQkFBZ0IsY0FBY0U7UUFDaERJO1FBQ0FMLFNBQVM7SUFDWDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLFNBQVNPLDZCQUE2Qi9CLEdBQVc7SUFDdEQsSUFBSTtRQUNGLGdCQUFnQjtRQUNoQixNQUFNQyxhQUFhRixtQkFBbUJDO1FBRXRDLDRDQUE0QztRQUM1Qyx3RUFBd0U7UUFDeEUsTUFBTWdDLGtCQUFrQjtRQUN4QixNQUFNQyxnQkFBZ0JoQyxXQUFXUSxLQUFLLENBQUN1QjtRQUV2QyxJQUFJQyxpQkFBaUJBLGFBQWEsQ0FBQyxFQUFFLEVBQUU7WUFDckMsTUFBTUMsV0FBV0QsYUFBYSxDQUFDLEVBQUU7WUFDakMsd0VBQXdFO1lBQ3hFLElBQUksbUJBQW1CRSxJQUFJLENBQUNELFdBQVc7Z0JBQ3JDLE9BQU9BLFNBQVNFLFdBQVcsR0FBR2xDLElBQUk7WUFDcEM7UUFDRjtRQUVBLDRDQUE0QztRQUM1QyxJQUFJLHNCQUFzQmlDLElBQUksQ0FBQ2xDLGFBQWE7WUFDMUMsT0FBTztRQUNUO1FBRUEsT0FBTztJQUNULEVBQUUsT0FBT0ksT0FBTztRQUNkTyxRQUFRUCxLQUFLLENBQUMsdUNBQXVDQTtRQUNyRCxPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU2dDLDBCQUNkckMsR0FBVyxFQUNYeUIsSUFBdUI7SUFFdkIsSUFBSSxDQUFDekIsSUFBSXVCLFFBQVEsQ0FBQyxlQUFlO1FBQy9CLE9BQU87SUFDVDtJQUVBLElBQUlFLFNBQVMsU0FBUztRQUNwQixPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXNhci13ZWIvLi9saWIvdXJsLXV0aWxzLnRzP2NjZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaWtUb2sgVVJMIFV0aWxpdGllc1xuICogQ2VudHJhbGl6ZWQgdXRpbGl0aWVzIGZvciBleHRyYWN0aW5nIGFuZCB2YWxpZGF0aW5nIFRpa1RvayB2aWRlbyBhbmQgbXVzaWMgSURzXG4gKi9cblxuLyoqXG4gKiBSZXN1bHQgb2YgVVJMIHZhbGlkYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUaWtUb2tVcmxWYWxpZGF0aW9uIHtcbiAgaXNWYWxpZDogYm9vbGVhbjtcbiAgdHlwZTogJ3ZpZGVvJyB8ICdtdXNpYycgfCAnc2hvcnRsaW5rJyB8ICd1bmtub3duJztcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVzdWx0IG9mIElEIGV4dHJhY3Rpb24gd2l0aCBtZXRhZGF0YVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RlZElkIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogJ3ZpZGVvJyB8ICdtdXNpYycgfCAnc2hvcnRsaW5rJztcbiAgb3JpZ2luYWxVcmw6IHN0cmluZztcbiAgaXNWYWxpZDogYm9vbGVhbjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgVGlrVG9rIFVSTCBieSByZW1vdmluZyB0cmFpbGluZyBzbGFzaGVzLCBmcmFnbWVudHMsIGV0Yy5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMgTm9ybWFsaXplZCBVUkwgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVUaWtUb2tVcmwodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIC8vIFRyaW0gd2hpdGVzcGFjZVxuICAgIGxldCBub3JtYWxpemVkID0gdXJsLnRyaW0oKTtcblxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG5cbiAgICAvLyBSZW1vdmUgVVJMIGZyYWdtZW50cyAoI3NlY3Rpb24pXG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQuc3BsaXQoJyMnKVswXTtcblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IFRpa1RvayBtdXNpYyBJRCBmcm9tIGEgVVJMXG4gKiBTdXBwb3J0cyBmb3JtYXRzOlxuICogLSBodHRwczovL3d3dy50aWt0b2suY29tL211c2ljL1NvbmctTmFtZS03NTY1NTQzMTM4NzY1MzkyNjUyXG4gKiAtIGh0dHBzOi8vd3d3LnRpa3Rvay5jb20vbXVzaWMvb3JpZ2luYWwtc291bmQtMTIzNDU2Nzg5MFxuICogLSBodHRwczovL3ZtLnRpa3Rvay5jb20vQUJDMTIzL1xuICogLSA/bXVzaWNJZD0xMjM0NTY3ODkwXG4gKiBcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVGlrVG9rIG11c2ljIFVSTFxuICogQHJldHVybnMgTXVzaWMgSUQgKG51bWVyaWMgc3RyaW5nKSBvciBzaG9ydCBsaW5rLCBudWxsIGlmIGV4dHJhY3Rpb24gZmFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUaWtUb2tNdXNpY0lkKHVybDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIHRyeSB7XG5cblxuICAgIC8vIE5vcm1hbGl6ZSBVUkxcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplVGlrVG9rVXJsKHVybCk7XG5cbiAgICAvLyBQYXR0ZXJuIDE6IEZ1bGwgbXVzaWMgVVJMcyAtIC9tdXNpYy9zb25nLW5hbWUtW0lEXVxuICAgIC8vIEhhbmRsZXM6IGh0dHBzOi8vd3d3LnRpa3Rvay5jb20vbXVzaWMvS2hpbS0xMHMtNzU2NTU0MzEzODc2NTM5MjY1MlxuICAgIGNvbnN0IG11c2ljVXJsUGF0dGVybiA9IC9cXC9tdXNpY1xcL1teXFwvXFw/I10rLShcXGQrKS9pO1xuICAgIGNvbnN0IG11c2ljTWF0Y2ggPSBub3JtYWxpemVkLm1hdGNoKG11c2ljVXJsUGF0dGVybik7XG4gICAgaWYgKG11c2ljTWF0Y2ggJiYgbXVzaWNNYXRjaFsxXSkge1xuICAgICAgY29uc3QgaWQgPSBtdXNpY01hdGNoWzFdO1xuXG5cbiAgICAgIC8vIFZhbGlkYXRlIElEIChUaWtUb2sgSURzIGFyZSB0eXBpY2FsbHkgMTAtMjAgZGlnaXRzKVxuICAgICAgaWYgKGlkLmxlbmd0aCA+PSA2ICYmIGlkLmxlbmd0aCA8PSAyNSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gTXVzaWMgSUQgbGVuZ3RoIHVudXN1YWw6XCIsIGlkLmxlbmd0aCwgXCJkaWdpdHNcIik7XG4gICAgICAgIHJldHVybiBpZDsgLy8gUmV0dXJuIGFueXdheSBidXQgbG9nIHdhcm5pbmdcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXR0ZXJuIDI6IFF1ZXJ5IHBhcmFtZXRlciAtID9tdXNpY0lkPTEyMzQ1Njc4OTBcbiAgICBjb25zdCBxdWVyeVBhdHRlcm4gPSAvWz8mXW11c2ljSWQ9KFxcZCspL2k7XG4gICAgY29uc3QgcXVlcnlNYXRjaCA9IG5vcm1hbGl6ZWQubWF0Y2gocXVlcnlQYXR0ZXJuKTtcbiAgICBpZiAocXVlcnlNYXRjaCAmJiBxdWVyeU1hdGNoWzFdKSB7XG4gICAgICBjb25zdCBpZCA9IHF1ZXJ5TWF0Y2hbMV07XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvLyBQYXR0ZXJuIDM6IFNob3J0IGxpbmtzIC0gdm0udGlrdG9rLmNvbS9BQkMgb3IgdnQudGlrdG9rLmNvbS9BQkNcbiAgICAvLyBUaWtBUEkgY2FuIHJlc29sdmUgdGhlc2UgZGlyZWN0bHlcbiAgICBjb25zdCBzaG9ydExpbmtQYXR0ZXJuID0gLyh2W210XVxcLnRpa3Rva1xcLmNvbVxcL1tBLVphLXowLTldKykvaTtcbiAgICBjb25zdCBzaG9ydE1hdGNoID0gbm9ybWFsaXplZC5tYXRjaChzaG9ydExpbmtQYXR0ZXJuKTtcbiAgICBpZiAoc2hvcnRNYXRjaCAmJiBzaG9ydE1hdGNoWzFdKSB7XG4gICAgICBjb25zdCBzaG9ydExpbmsgPSBzaG9ydE1hdGNoWzFdO1xuXG4gICAgICByZXR1cm4gc2hvcnRMaW5rO1xuICAgIH1cblxuICAgIGNvbnNvbGUud2FybihcIuKdjCBGYWlsZWQgdG8gZXh0cmFjdCBNdXNpYyBJRCBmcm9tOlwiLCB1cmwpO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleHRyYWN0aW5nIG11c2ljIElEOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IFRpa1RvayB2aWRlbyBJRCBmcm9tIGEgVVJMXG4gKiBTdXBwb3J0cyBmb3JtYXRzOlxuICogLSBodHRwczovL3d3dy50aWt0b2suY29tL0B1c2VybmFtZS92aWRlby83MDAzNDAyNjI5OTI5OTEzNjA1XG4gKiAtIGh0dHBzOi8vdnQudGlrdG9rLmNvbS9aU2FiY2RlZmcvXG4gKiAtIGh0dHBzOi8vdm0udGlrdG9rLmNvbS9aTWFiY2RlZmcvXG4gKiBcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVGlrVG9rIHZpZGVvIFVSTFxuICogQHJldHVybnMgVmlkZW8gSUQgKG51bWVyaWMgc3RyaW5nKSBvciBzaG9ydCBsaW5rLCBudWxsIGlmIGV4dHJhY3Rpb24gZmFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUaWtUb2tWaWRlb0lkKHVybDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIHRyeSB7XG5cblxuICAgIC8vIE5vcm1hbGl6ZSBVUkxcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplVGlrVG9rVXJsKHVybCk7XG5cbiAgICAvLyBQYXR0ZXJuIDE6IEZ1bGwgdmlkZW8gVVJMcyAtIC9AdXNlcm5hbWUvdmlkZW8vW0lEXVxuICAgIC8vIEhhbmRsZXM6IGh0dHBzOi8vd3d3LnRpa3Rvay5jb20vQGhheWxleWJ1aXgvdmlkZW8vNzAwMzQwMjYyOTkyOTkxMzYwNVxuICAgIGNvbnN0IHZpZGVvVXJsUGF0dGVybiA9IC9cXC92aWRlb1xcLyhcXGQrKS9pO1xuICAgIGNvbnN0IHZpZGVvTWF0Y2ggPSBub3JtYWxpemVkLm1hdGNoKHZpZGVvVXJsUGF0dGVybik7XG4gICAgaWYgKHZpZGVvTWF0Y2ggJiYgdmlkZW9NYXRjaFsxXSkge1xuICAgICAgY29uc3QgaWQgPSB2aWRlb01hdGNoWzFdO1xuXG5cbiAgICAgIC8vIFZhbGlkYXRlIElEIChUaWtUb2sgSURzIGFyZSB0eXBpY2FsbHkgMTAtMjAgZGlnaXRzKVxuICAgICAgaWYgKGlkLmxlbmd0aCA+PSA2ICYmIGlkLmxlbmd0aCA8PSAyNSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCLimqDvuI8gVmlkZW8gSUQgbGVuZ3RoIHVudXN1YWw6XCIsIGlkLmxlbmd0aCwgXCJkaWdpdHNcIik7XG4gICAgICAgIHJldHVybiBpZDsgLy8gUmV0dXJuIGFueXdheSBidXQgbG9nIHdhcm5pbmdcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXR0ZXJuIDI6IFNob3J0IGxpbmtzIC0gdm0udGlrdG9rLmNvbS9BQkMgb3IgdnQudGlrdG9rLmNvbS9BQkNcbiAgICAvLyBUaWtBUEkgY2FuIHJlc29sdmUgdGhlc2UgZGlyZWN0bHlcbiAgICBjb25zdCBzaG9ydExpbmtQYXR0ZXJuID0gLyh2W210XVxcLnRpa3Rva1xcLmNvbVxcL1tBLVphLXowLTldKykvaTtcbiAgICBjb25zdCBzaG9ydE1hdGNoID0gbm9ybWFsaXplZC5tYXRjaChzaG9ydExpbmtQYXR0ZXJuKTtcbiAgICBpZiAoc2hvcnRNYXRjaCAmJiBzaG9ydE1hdGNoWzFdKSB7XG4gICAgICBjb25zdCBzaG9ydExpbmsgPSBzaG9ydE1hdGNoWzFdO1xuXG4gICAgICByZXR1cm4gc2hvcnRMaW5rO1xuICAgIH1cblxuICAgIGNvbnNvbGUud2FybihcIuKdjCBGYWlsZWQgdG8gZXh0cmFjdCBWaWRlbyBJRCBmcm9tOlwiLCB1cmwpO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleHRyYWN0aW5nIHZpZGVvIElEOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhIFRpa1RvayBVUkwgYW5kIGRldGVybWluZSBpdHMgdHlwZVxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIFZhbGlkYXRpb24gcmVzdWx0IHdpdGggdHlwZSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUaWtUb2tVcmwodXJsOiBzdHJpbmcpOiBUaWtUb2tVcmxWYWxpZGF0aW9uIHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiBVUkwgY29udGFpbnMgdGlrdG9rLmNvbVxuICAgIGlmICghdXJsLmluY2x1ZGVzKCd0aWt0b2suY29tJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB0eXBlOiAndW5rbm93bicsXG4gICAgICAgIGVycm9yOiAnVVJMIG11c3QgYmUgZnJvbSB0aWt0b2suY29tJyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgbXVzaWMgSURcbiAgICBjb25zdCBtdXNpY0lkID0gZXh0cmFjdFRpa1Rva011c2ljSWQodXJsKTtcbiAgICBpZiAobXVzaWNJZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogbXVzaWNJZC5pbmNsdWRlcygndGlrdG9rLmNvbScpID8gJ3Nob3J0bGluaycgOiAnbXVzaWMnLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gZXh0cmFjdCB2aWRlbyBJRFxuICAgIGNvbnN0IHZpZGVvSWQgPSBleHRyYWN0VGlrVG9rVmlkZW9JZCh1cmwpO1xuICAgIGlmICh2aWRlb0lkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICB0eXBlOiB2aWRlb0lkLmluY2x1ZGVzKCd0aWt0b2suY29tJykgPyAnc2hvcnRsaW5rJyA6ICd2aWRlbycsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENvdWxkIG5vdCBleHRyYWN0IGFueSBJRFxuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIHR5cGU6ICd1bmtub3duJyxcbiAgICAgIGVycm9yOiAnQ291bGQgbm90IGV4dHJhY3QgSUQgZnJvbSBVUkwuIEV4cGVjdGVkIGZvcm1hdDogaHR0cHM6Ly93d3cudGlrdG9rLmNvbS9tdXNpYy8uLi4gb3IgQHVzZXIvdmlkZW8vLi4uJyxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIHR5cGU6ICd1bmtub3duJyxcbiAgICAgIGVycm9yOiBgVVJMIHZhbGlkYXRpb24gZXJyb3I6ICR7ZXJyb3J9YCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBJRCB3aXRoIGZ1bGwgbWV0YWRhdGFcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVGlrVG9rIFVSTFxuICogQHBhcmFtIHR5cGUgLSBUaGUgZXhwZWN0ZWQgdHlwZSAoJ211c2ljJyBvciAndmlkZW8nKVxuICogQHJldHVybnMgRXh0cmFjdGlvbiByZXN1bHQgd2l0aCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRpa1Rva0lkKFxuICB1cmw6IHN0cmluZyxcbiAgdHlwZTogJ211c2ljJyB8ICd2aWRlbydcbik6IEV4dHJhY3RlZElkIHtcbiAgY29uc3Qgb3JpZ2luYWxVcmwgPSB1cmw7XG5cbiAgY29uc3QgZXh0cmFjdEZuID0gdHlwZSA9PT0gJ211c2ljJyA/IGV4dHJhY3RUaWtUb2tNdXNpY0lkIDogZXh0cmFjdFRpa1Rva1ZpZGVvSWQ7XG4gIGNvbnN0IGlkID0gZXh0cmFjdEZuKHVybCk7XG5cbiAgaWYgKCFpZCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogJycsXG4gICAgICB0eXBlLFxuICAgICAgb3JpZ2luYWxVcmwsXG4gICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBgRmFpbGVkIHRvIGV4dHJhY3QgJHt0eXBlfSBJRCBmcm9tIFVSTC4gQ2hlY2sgVVJMIGZvcm1hdC5gLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHR5cGU6IGlkLmluY2x1ZGVzKCd0aWt0b2suY29tJykgPyAnc2hvcnRsaW5rJyA6IHR5cGUsXG4gICAgb3JpZ2luYWxVcmwsXG4gICAgaXNWYWxpZDogdHJ1ZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IFRpa1RvayB1c2VybmFtZSBmcm9tIGEgdmlkZW8gVVJMXG4gKiBTdXBwb3J0cyBmb3JtYXRzOlxuICogLSBodHRwczovL3d3dy50aWt0b2suY29tL0B1c2VybmFtZS92aWRlby83MDAzNDAyNjI5OTI5OTEzNjA1XG4gKiBcbiAqIE5vdGU6IFNob3J0IGxpbmtzICh2bS50aWt0b2suY29tLCB2dC50aWt0b2suY29tKSBjYW5ub3QgZXh0cmFjdCB1c2VybmFtZSBmcm9tIFVSTFxuICogYW5kIHdpbGwgcmV0dXJuIG51bGwuIFVzZSB0aGUgQVBJIHJlc3BvbnNlIGNyZWF0b3JVc2VybmFtZSBmaWVsZCBpbnN0ZWFkLlxuICogXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFRpa1RvayB2aWRlbyBVUkxcbiAqIEByZXR1cm5zIFVzZXJuYW1lICh3aXRob3V0IEApIG9yIG51bGwgaWYgZXh0cmFjdGlvbiBmYWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRpa1Rva1VzZXJuYW1lRnJvbVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICB0cnkge1xuICAgIC8vIE5vcm1hbGl6ZSBVUkxcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplVGlrVG9rVXJsKHVybCk7XG5cbiAgICAvLyBQYXR0ZXJuOiAvQHVzZXJuYW1lL3ZpZGVvLyBvciAvQHVzZXJuYW1lL1xuICAgIC8vIEhhbmRsZXM6IGh0dHBzOi8vd3d3LnRpa3Rvay5jb20vQGhheWxleWJ1aXgvdmlkZW8vNzAwMzQwMjYyOTkyOTkxMzYwNVxuICAgIGNvbnN0IHVzZXJuYW1lUGF0dGVybiA9IC9cXC9AKFthLXpBLVowLTkuX10rKS9pO1xuICAgIGNvbnN0IHVzZXJuYW1lTWF0Y2ggPSBub3JtYWxpemVkLm1hdGNoKHVzZXJuYW1lUGF0dGVybik7XG5cbiAgICBpZiAodXNlcm5hbWVNYXRjaCAmJiB1c2VybmFtZU1hdGNoWzFdKSB7XG4gICAgICBjb25zdCB1c2VybmFtZSA9IHVzZXJuYW1lTWF0Y2hbMV07XG4gICAgICAvLyBWYWxpZGF0ZSB1c2VybmFtZSBmb3JtYXQgKGFscGhhbnVtZXJpYywgdW5kZXJzY29yZXMsIGRvdHMsIG5vIHNwYWNlcylcbiAgICAgIGlmICgvXlthLXpBLVowLTkuX10rJC8udGVzdCh1c2VybmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3J0IGxpbmtzIGRvbid0IGNvbnRhaW4gdXNlcm5hbWUgaW4gVVJMXG4gICAgaWYgKC92W210XVxcLnRpa3Rva1xcLmNvbS9pLnRlc3Qobm9ybWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleHRyYWN0aW5nIHVzZXJuYW1lIGZyb20gVVJMOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdXNlci1mcmllbmRseSBlcnJvciBtZXNzYWdlIGZvciBmYWlsZWQgZXh0cmFjdGlvblxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhhdCBmYWlsZWRcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIGV4cGVjdGVkIHR5cGVcbiAqIEByZXR1cm5zIFVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0cmFjdGlvbkVycm9yTWVzc2FnZShcbiAgdXJsOiBzdHJpbmcsXG4gIHR5cGU6ICdtdXNpYycgfCAndmlkZW8nXG4pOiBzdHJpbmcge1xuICBpZiAoIXVybC5pbmNsdWRlcygndGlrdG9rLmNvbScpKSB7XG4gICAgcmV0dXJuICdQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIFRpa1RvayBVUkwnO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdtdXNpYycpIHtcbiAgICByZXR1cm4gJ011c2ljIElEIG5vdCBmb3VuZC4gUGxlYXNlIHVzZSBhIFVSTCBmb3JtYXQgbGlrZTogaHR0cHM6Ly93d3cudGlrdG9rLmNvbS9tdXNpYy9Tb25nLU5hbWUtMTIzNDU2Nzg5MCc7XG4gIH1cblxuICByZXR1cm4gJ1ZpZGVvIElEIG5vdCBmb3VuZC4gUGxlYXNlIHVzZSBhIFVSTCBmb3JtYXQgbGlrZTogaHR0cHM6Ly93d3cudGlrdG9rLmNvbS9AdXNlcm5hbWUvdmlkZW8vMTIzNDU2Nzg5MCc7XG59XG5cblxuXG5cblxuXG5cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVUaWtUb2tVcmwiLCJ1cmwiLCJub3JtYWxpemVkIiwidHJpbSIsInJlcGxhY2UiLCJzcGxpdCIsImVycm9yIiwiZXh0cmFjdFRpa1Rva011c2ljSWQiLCJtdXNpY1VybFBhdHRlcm4iLCJtdXNpY01hdGNoIiwibWF0Y2giLCJpZCIsImxlbmd0aCIsImNvbnNvbGUiLCJ3YXJuIiwicXVlcnlQYXR0ZXJuIiwicXVlcnlNYXRjaCIsInNob3J0TGlua1BhdHRlcm4iLCJzaG9ydE1hdGNoIiwic2hvcnRMaW5rIiwiZXh0cmFjdFRpa1Rva1ZpZGVvSWQiLCJ2aWRlb1VybFBhdHRlcm4iLCJ2aWRlb01hdGNoIiwidmFsaWRhdGVUaWtUb2tVcmwiLCJpbmNsdWRlcyIsImlzVmFsaWQiLCJ0eXBlIiwibXVzaWNJZCIsInZpZGVvSWQiLCJleHRyYWN0VGlrVG9rSWQiLCJvcmlnaW5hbFVybCIsImV4dHJhY3RGbiIsImV4dHJhY3RUaWtUb2tVc2VybmFtZUZyb21VcmwiLCJ1c2VybmFtZVBhdHRlcm4iLCJ1c2VybmFtZU1hdGNoIiwidXNlcm5hbWUiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJnZXRFeHRyYWN0aW9uRXJyb3JNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/url-utils.ts\n");

/***/ }),

/***/ "(rsc)/./server/context.ts":
/*!***************************!*\
  !*** ./server/context.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContext: () => (/* binding */ createContext)\n/* harmony export */ });\n/* harmony import */ var _lib_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/auth */ \"(rsc)/./lib/auth.ts\");\n\nconst createContext = async (opts)=>{\n    try {\n        // 1. Try NextAuth (Cookie)\n        const session = await (0,_lib_auth__WEBPACK_IMPORTED_MODULE_0__.auth)();\n        if (session?.user) {\n            return {\n                user: session.user\n            };\n        }\n    } catch (e) {\n        console.error(\"Context: auth() failed\", e);\n    }\n    // 2. Try Supabase Auth (Header)\n    // Mobile sends: Authorization: Bearer <token>\n    const authHeader = opts.req.headers.get(\"authorization\");\n    if (authHeader) {\n        const token = authHeader.split(\" \")[1];\n        if (token) {\n            try {\n                // Dynamically import jwt-decode to avoid edge runtime issues if any\n                // Debug logging\n                console.log(\"Context: Importing jwt-decode...\");\n                const jwtModule = await __webpack_require__.e(/*! import() */ \"vendor-chunks/jwt-decode\").then(__webpack_require__.bind(__webpack_require__, /*! jwt-decode */ \"(rsc)/./node_modules/jwt-decode/build/esm/index.js\"));\n                // Handle named vs default export\n                const jwtDecode = jwtModule.jwtDecode || jwtModule.default || jwtModule;\n                console.log(\"Context: decoding token...\");\n                const decoded = jwtDecode(token);\n                // decoded.sub is the user ID in Supabase\n                // We assume this ID matches our DB (since we are using same DB or synced)\n                // We need to fetch the user role from our DB to be safe\n                if (decoded.sub) {\n                    console.log(\"Context: finding user\", decoded.sub);\n                    const { prisma } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/prisma */ \"(rsc)/./lib/prisma.ts\"));\n                    const dbUser = await prisma.user.findUnique({\n                        where: {\n                            id: decoded.sub\n                        },\n                        select: {\n                            id: true,\n                            role: true,\n                            name: true,\n                            email: true\n                        }\n                    });\n                    if (dbUser) {\n                        console.log(\"Context: User found\", dbUser.id);\n                        return {\n                            user: {\n                                id: dbUser.id,\n                                role: dbUser.role,\n                                name: dbUser.name,\n                                email: dbUser.email\n                            }\n                        };\n                    } else {\n                        console.log(\"Context: User NOT found in DB\");\n                    }\n                }\n            } catch (error) {\n                console.error(\"JWT Decode or DB Error:\", error);\n            }\n        }\n    }\n    return {\n        user: undefined\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zZXJ2ZXIvY29udGV4dC50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUdrQztBQUUzQixNQUFNQyxnQkFBZ0IsT0FBT0M7SUFDaEMsSUFBSTtRQUNBLDJCQUEyQjtRQUMzQixNQUFNQyxVQUFVLE1BQU1ILCtDQUFJQTtRQUMxQixJQUFJRyxTQUFTQyxNQUFNO1lBQ2YsT0FBTztnQkFBRUEsTUFBTUQsUUFBUUMsSUFBSTtZQUFDO1FBQ2hDO0lBQ0osRUFBRSxPQUFPQyxHQUFHO1FBQ1JDLFFBQVFDLEtBQUssQ0FBQywwQkFBMEJGO0lBQzVDO0lBRUEsZ0NBQWdDO0lBQ2hDLDhDQUE4QztJQUM5QyxNQUFNRyxhQUFhTixLQUFLTyxHQUFHLENBQUNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDO0lBQ3hDLElBQUlILFlBQVk7UUFDWixNQUFNSSxRQUFRSixXQUFXSyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdEMsSUFBSUQsT0FBTztZQUNQLElBQUk7Z0JBQ0Esb0VBQW9FO2dCQUNwRSxnQkFBZ0I7Z0JBQ2hCTixRQUFRUSxHQUFHLENBQUM7Z0JBQ1osTUFBTUMsWUFBWSxNQUFNLDZMQUFvQjtnQkFDNUMsaUNBQWlDO2dCQUNqQyxNQUFNQyxZQUFZRCxVQUFVQyxTQUFTLElBQUksVUFBbUJDLE9BQU8sSUFBSUY7Z0JBRXZFVCxRQUFRUSxHQUFHLENBQUM7Z0JBQ1osTUFBTUksVUFBZUYsVUFBVUo7Z0JBQy9CLHlDQUF5QztnQkFDekMsMEVBQTBFO2dCQUMxRSx3REFBd0Q7Z0JBQ3hELElBQUlNLFFBQVFDLEdBQUcsRUFBRTtvQkFDYmIsUUFBUVEsR0FBRyxDQUFDLHlCQUF5QkksUUFBUUMsR0FBRztvQkFDaEQsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBRyxNQUFNLGlJQUFzQjtvQkFDL0MsTUFBTUMsU0FBUyxNQUFNRCxPQUFPaEIsSUFBSSxDQUFDa0IsVUFBVSxDQUFDO3dCQUN4Q0MsT0FBTzs0QkFBRUMsSUFBSU4sUUFBUUMsR0FBRzt3QkFBQzt3QkFDekJNLFFBQVE7NEJBQUVELElBQUk7NEJBQU1FLE1BQU07NEJBQU1DLE1BQU07NEJBQU1DLE9BQU87d0JBQUs7b0JBQzVEO29CQUVBLElBQUlQLFFBQVE7d0JBQ1JmLFFBQVFRLEdBQUcsQ0FBQyx1QkFBdUJPLE9BQU9HLEVBQUU7d0JBQzVDLE9BQU87NEJBQ0hwQixNQUFNO2dDQUNGb0IsSUFBSUgsT0FBT0csRUFBRTtnQ0FDYkUsTUFBTUwsT0FBT0ssSUFBSTtnQ0FDakJDLE1BQU1OLE9BQU9NLElBQUk7Z0NBQ2pCQyxPQUFPUCxPQUFPTyxLQUFLOzRCQUN2Qjt3QkFDSjtvQkFDSixPQUFPO3dCQUNIdEIsUUFBUVEsR0FBRyxDQUFDO29CQUNoQjtnQkFDSjtZQUNKLEVBQUUsT0FBT1AsT0FBTztnQkFDWkQsUUFBUUMsS0FBSyxDQUFDLDJCQUEyQkE7WUFDN0M7UUFDSjtJQUNKO0lBRUEsT0FBTztRQUNISCxNQUFNeUI7SUFDVjtBQUNKLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZXNhci13ZWIvLi9zZXJ2ZXIvY29udGV4dC50cz82M2MzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR5cGUgaW5mZXJBc3luY1JldHVyblR5cGUgfSBmcm9tIFwiQHRycGMvc2VydmVyXCI7XHJcbmltcG9ydCB7IHR5cGUgRmV0Y2hDcmVhdGVDb250ZXh0Rm5PcHRpb25zIH0gZnJvbSBcIkB0cnBjL3NlcnZlci9hZGFwdGVycy9mZXRjaFwiO1xyXG5cclxuaW1wb3J0IHsgYXV0aCB9IGZyb20gXCJAL2xpYi9hdXRoXCI7XHJcblxyXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udGV4dCA9IGFzeW5jIChvcHRzOiBGZXRjaENyZWF0ZUNvbnRleHRGbk9wdGlvbnMpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gMS4gVHJ5IE5leHRBdXRoIChDb29raWUpXHJcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGF1dGgoKTtcclxuICAgICAgICBpZiAoc2Vzc2lvbj8udXNlcikge1xyXG4gICAgICAgICAgICByZXR1cm4geyB1c2VyOiBzZXNzaW9uLnVzZXIgfTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbnRleHQ6IGF1dGgoKSBmYWlsZWRcIiwgZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMi4gVHJ5IFN1cGFiYXNlIEF1dGggKEhlYWRlcilcclxuICAgIC8vIE1vYmlsZSBzZW5kczogQXV0aG9yaXphdGlvbjogQmVhcmVyIDx0b2tlbj5cclxuICAgIGNvbnN0IGF1dGhIZWFkZXIgPSBvcHRzLnJlcS5oZWFkZXJzLmdldChcImF1dGhvcml6YXRpb25cIik7XHJcbiAgICBpZiAoYXV0aEhlYWRlcikge1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gYXV0aEhlYWRlci5zcGxpdChcIiBcIilbMV07XHJcbiAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEeW5hbWljYWxseSBpbXBvcnQgand0LWRlY29kZSB0byBhdm9pZCBlZGdlIHJ1bnRpbWUgaXNzdWVzIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgLy8gRGVidWcgbG9nZ2luZ1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb250ZXh0OiBJbXBvcnRpbmcgand0LWRlY29kZS4uLlwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3dE1vZHVsZSA9IGF3YWl0IGltcG9ydChcImp3dC1kZWNvZGVcIik7XHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbmFtZWQgdnMgZGVmYXVsdCBleHBvcnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3dERlY29kZSA9IGp3dE1vZHVsZS5qd3REZWNvZGUgfHwgKGp3dE1vZHVsZSBhcyBhbnkpLmRlZmF1bHQgfHwgand0TW9kdWxlO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29udGV4dDogZGVjb2RpbmcgdG9rZW4uLi5cIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkOiBhbnkgPSBqd3REZWNvZGUodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVjb2RlZC5zdWIgaXMgdGhlIHVzZXIgSUQgaW4gU3VwYWJhc2VcclxuICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGlzIElEIG1hdGNoZXMgb3VyIERCIChzaW5jZSB3ZSBhcmUgdXNpbmcgc2FtZSBEQiBvciBzeW5jZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZldGNoIHRoZSB1c2VyIHJvbGUgZnJvbSBvdXIgREIgdG8gYmUgc2FmZVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlY29kZWQuc3ViKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb250ZXh0OiBmaW5kaW5nIHVzZXJcIiwgZGVjb2RlZC5zdWIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJpc21hIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi9wcmlzbWFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGJVc2VyID0gYXdhaXQgcHJpc21hLnVzZXIuZmluZFVuaXF1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlOiB7IGlkOiBkZWNvZGVkLnN1YiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHsgaWQ6IHRydWUsIHJvbGU6IHRydWUsIG5hbWU6IHRydWUsIGVtYWlsOiB0cnVlIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRiVXNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbnRleHQ6IFVzZXIgZm91bmRcIiwgZGJVc2VyLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZGJVc2VyLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IGRiVXNlci5yb2xlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRiVXNlci5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsOiBkYlVzZXIuZW1haWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb250ZXh0OiBVc2VyIE5PVCBmb3VuZCBpbiBEQlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSldUIERlY29kZSBvciBEQiBFcnJvcjpcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlcjogdW5kZWZpbmVkLFxyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIENvbnRleHQgPSBpbmZlckFzeW5jUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlQ29udGV4dD47XHJcbiJdLCJuYW1lcyI6WyJhdXRoIiwiY3JlYXRlQ29udGV4dCIsIm9wdHMiLCJzZXNzaW9uIiwidXNlciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJhdXRoSGVhZGVyIiwicmVxIiwiaGVhZGVycyIsImdldCIsInRva2VuIiwic3BsaXQiLCJsb2ciLCJqd3RNb2R1bGUiLCJqd3REZWNvZGUiLCJkZWZhdWx0IiwiZGVjb2RlZCIsInN1YiIsInByaXNtYSIsImRiVXNlciIsImZpbmRVbmlxdWUiLCJ3aGVyZSIsImlkIiwic2VsZWN0Iiwicm9sZSIsIm5hbWUiLCJlbWFpbCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./server/context.ts\n");

/***/ }),

/***/ "(rsc)/./server/lib/tierUtils.ts":
/*!*********************************!*\
  !*** ./server/lib/tierUtils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCampaignTierFromBudget: () => (/* binding */ getCampaignTierFromBudget),\n/* harmony export */   getCreatorTierFromFollowers: () => (/* binding */ getCreatorTierFromFollowers),\n/* harmony export */   getMaxSubmissionsFromBudget: () => (/* binding */ getMaxSubmissionsFromBudget),\n/* harmony export */   getMinFollowersForTier: () => (/* binding */ getMinFollowersForTier),\n/* harmony export */   isCreatorEligibleForCampaign: () => (/* binding */ isCreatorEligibleForCampaign)\n/* harmony export */ });\n// Tier calculation utilities for backend\n/**\r\n * Calculate campaign tier based on total budget in TL\r\n */ function getCampaignTierFromBudget(budgetTL) {\n    if (budgetTL >= 100000) return \"S\";\n    if (budgetTL >= 60000) return \"A\";\n    if (budgetTL >= 30000) return \"B\";\n    if (budgetTL >= 15000) return \"C\";\n    return \"D\"; // Below minimum\n}\n/**\r\n * Get minimum follower requirement for a campaign tier\r\n */ function getMinFollowersForTier(tier) {\n    switch(tier){\n        case \"S\":\n            return 10000;\n        case \"A\":\n            return 5000;\n        case \"B\":\n            return 3000;\n        case \"C\":\n            return 1000;\n        case \"D\":\n            return 0;\n    }\n}\n/**\r\n * Calculate maximum submissions based on budget\r\n * Formula: (budget / 1000) * 100\r\n */ function getMaxSubmissionsFromBudget(budgetTL) {\n    return Math.floor(budgetTL / 1000 * 100);\n}\n/**\r\n * Calculate creator tier based on follower count\r\n */ function getCreatorTierFromFollowers(followers) {\n    if (followers >= 50000) return \"S\";\n    if (followers >= 10000) return \"A\";\n    if (followers >= 5000) return \"B\";\n    if (followers >= 1000) return \"C\";\n    return \"D\";\n}\n/**\r\n * Check if a creator's tier is eligible for a campaign tier\r\n */ function isCreatorEligibleForCampaign(creatorTier, campaignTier) {\n    // If creator has no tier (not connected TikTok), treat as D tier\n    const effectiveCreatorTier = creatorTier || \"D\";\n    const tierOrder = [\n        \"D\",\n        \"C\",\n        \"B\",\n        \"A\",\n        \"S\"\n    ];\n    const creatorIndex = tierOrder.indexOf(effectiveCreatorTier);\n    const campaignIndex = tierOrder.indexOf(campaignTier);\n    // Creator must have same or higher tier than campaign requirement\n    return creatorIndex >= campaignIndex;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zZXJ2ZXIvbGliL3RpZXJVdGlscy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHlDQUF5QztBQUl6Qzs7Q0FFQyxHQUNNLFNBQVNBLDBCQUEwQkMsUUFBZ0I7SUFDdEQsSUFBSUEsWUFBWSxRQUFRLE9BQU87SUFDL0IsSUFBSUEsWUFBWSxPQUFPLE9BQU87SUFDOUIsSUFBSUEsWUFBWSxPQUFPLE9BQU87SUFDOUIsSUFBSUEsWUFBWSxPQUFPLE9BQU87SUFDOUIsT0FBTyxLQUFLLGdCQUFnQjtBQUNoQztBQUVBOztDQUVDLEdBQ00sU0FBU0MsdUJBQXVCQyxJQUFVO0lBQzdDLE9BQVFBO1FBQ0osS0FBSztZQUFLLE9BQU87UUFDakIsS0FBSztZQUFLLE9BQU87UUFDakIsS0FBSztZQUFLLE9BQU87UUFDakIsS0FBSztZQUFLLE9BQU87UUFDakIsS0FBSztZQUFLLE9BQU87SUFDckI7QUFDSjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDLDRCQUE0QkgsUUFBZ0I7SUFDeEQsT0FBT0ksS0FBS0MsS0FBSyxDQUFDLFdBQVksT0FBUTtBQUMxQztBQUVBOztDQUVDLEdBQ00sU0FBU0MsNEJBQTRCQyxTQUFpQjtJQUN6RCxJQUFJQSxhQUFhLE9BQU8sT0FBTztJQUMvQixJQUFJQSxhQUFhLE9BQU8sT0FBTztJQUMvQixJQUFJQSxhQUFhLE1BQU0sT0FBTztJQUM5QixJQUFJQSxhQUFhLE1BQU0sT0FBTztJQUM5QixPQUFPO0FBQ1g7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLDZCQUE2QkMsV0FBd0IsRUFBRUMsWUFBa0I7SUFDckYsaUVBQWlFO0lBQ2pFLE1BQU1DLHVCQUF1QkYsZUFBZTtJQUU1QyxNQUFNRyxZQUFvQjtRQUFDO1FBQUs7UUFBSztRQUFLO1FBQUs7S0FBSTtJQUNuRCxNQUFNQyxlQUFlRCxVQUFVRSxPQUFPLENBQUNIO0lBQ3ZDLE1BQU1JLGdCQUFnQkgsVUFBVUUsT0FBTyxDQUFDSjtJQUV4QyxrRUFBa0U7SUFDbEUsT0FBT0csZ0JBQWdCRTtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nlc2FyLXdlYi8uL3NlcnZlci9saWIvdGllclV0aWxzLnRzP2RhYWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGllciBjYWxjdWxhdGlvbiB1dGlsaXRpZXMgZm9yIGJhY2tlbmRcclxuXHJcbmV4cG9ydCB0eXBlIFRpZXIgPSAnRCcgfCAnQycgfCAnQicgfCAnQScgfCAnUyc7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIGNhbXBhaWduIHRpZXIgYmFzZWQgb24gdG90YWwgYnVkZ2V0IGluIFRMXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FtcGFpZ25UaWVyRnJvbUJ1ZGdldChidWRnZXRUTDogbnVtYmVyKTogVGllciB7XHJcbiAgICBpZiAoYnVkZ2V0VEwgPj0gMTAwMDAwKSByZXR1cm4gJ1MnO1xyXG4gICAgaWYgKGJ1ZGdldFRMID49IDYwMDAwKSByZXR1cm4gJ0EnO1xyXG4gICAgaWYgKGJ1ZGdldFRMID49IDMwMDAwKSByZXR1cm4gJ0InO1xyXG4gICAgaWYgKGJ1ZGdldFRMID49IDE1MDAwKSByZXR1cm4gJ0MnO1xyXG4gICAgcmV0dXJuICdEJzsgLy8gQmVsb3cgbWluaW11bVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IG1pbmltdW0gZm9sbG93ZXIgcmVxdWlyZW1lbnQgZm9yIGEgY2FtcGFpZ24gdGllclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkZvbGxvd2Vyc0ZvclRpZXIodGllcjogVGllcik6IG51bWJlciB7XHJcbiAgICBzd2l0Y2ggKHRpZXIpIHtcclxuICAgICAgICBjYXNlICdTJzogcmV0dXJuIDEwMDAwO1xyXG4gICAgICAgIGNhc2UgJ0EnOiByZXR1cm4gNTAwMDtcclxuICAgICAgICBjYXNlICdCJzogcmV0dXJuIDMwMDA7XHJcbiAgICAgICAgY2FzZSAnQyc6IHJldHVybiAxMDAwO1xyXG4gICAgICAgIGNhc2UgJ0QnOiByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBtYXhpbXVtIHN1Ym1pc3Npb25zIGJhc2VkIG9uIGJ1ZGdldFxyXG4gKiBGb3JtdWxhOiAoYnVkZ2V0IC8gMTAwMCkgKiAxMDBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhTdWJtaXNzaW9uc0Zyb21CdWRnZXQoYnVkZ2V0VEw6IG51bWJlcik6IG51bWJlciB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcigoYnVkZ2V0VEwgLyAxMDAwKSAqIDEwMCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgY3JlYXRvciB0aWVyIGJhc2VkIG9uIGZvbGxvd2VyIGNvdW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRvclRpZXJGcm9tRm9sbG93ZXJzKGZvbGxvd2VyczogbnVtYmVyKTogVGllciB7XHJcbiAgICBpZiAoZm9sbG93ZXJzID49IDUwMDAwKSByZXR1cm4gJ1MnO1xyXG4gICAgaWYgKGZvbGxvd2VycyA+PSAxMDAwMCkgcmV0dXJuICdBJztcclxuICAgIGlmIChmb2xsb3dlcnMgPj0gNTAwMCkgcmV0dXJuICdCJztcclxuICAgIGlmIChmb2xsb3dlcnMgPj0gMTAwMCkgcmV0dXJuICdDJztcclxuICAgIHJldHVybiAnRCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGNyZWF0b3IncyB0aWVyIGlzIGVsaWdpYmxlIGZvciBhIGNhbXBhaWduIHRpZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0NyZWF0b3JFbGlnaWJsZUZvckNhbXBhaWduKGNyZWF0b3JUaWVyOiBUaWVyIHwgbnVsbCwgY2FtcGFpZ25UaWVyOiBUaWVyKTogYm9vbGVhbiB7XHJcbiAgICAvLyBJZiBjcmVhdG9yIGhhcyBubyB0aWVyIChub3QgY29ubmVjdGVkIFRpa1RvayksIHRyZWF0IGFzIEQgdGllclxyXG4gICAgY29uc3QgZWZmZWN0aXZlQ3JlYXRvclRpZXIgPSBjcmVhdG9yVGllciB8fCAnRCc7XHJcblxyXG4gICAgY29uc3QgdGllck9yZGVyOiBUaWVyW10gPSBbJ0QnLCAnQycsICdCJywgJ0EnLCAnUyddO1xyXG4gICAgY29uc3QgY3JlYXRvckluZGV4ID0gdGllck9yZGVyLmluZGV4T2YoZWZmZWN0aXZlQ3JlYXRvclRpZXIpO1xyXG4gICAgY29uc3QgY2FtcGFpZ25JbmRleCA9IHRpZXJPcmRlci5pbmRleE9mKGNhbXBhaWduVGllcik7XHJcblxyXG4gICAgLy8gQ3JlYXRvciBtdXN0IGhhdmUgc2FtZSBvciBoaWdoZXIgdGllciB0aGFuIGNhbXBhaWduIHJlcXVpcmVtZW50XHJcbiAgICByZXR1cm4gY3JlYXRvckluZGV4ID49IGNhbXBhaWduSW5kZXg7XHJcbn1cclxuIl0sIm5hbWVzIjpbImdldENhbXBhaWduVGllckZyb21CdWRnZXQiLCJidWRnZXRUTCIsImdldE1pbkZvbGxvd2Vyc0ZvclRpZXIiLCJ0aWVyIiwiZ2V0TWF4U3VibWlzc2lvbnNGcm9tQnVkZ2V0IiwiTWF0aCIsImZsb29yIiwiZ2V0Q3JlYXRvclRpZXJGcm9tRm9sbG93ZXJzIiwiZm9sbG93ZXJzIiwiaXNDcmVhdG9yRWxpZ2libGVGb3JDYW1wYWlnbiIsImNyZWF0b3JUaWVyIiwiY2FtcGFpZ25UaWVyIiwiZWZmZWN0aXZlQ3JlYXRvclRpZXIiLCJ0aWVyT3JkZXIiLCJjcmVhdG9ySW5kZXgiLCJpbmRleE9mIiwiY2FtcGFpZ25JbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./server/lib/tierUtils.ts\n");

/***/ }),

/***/ "(rsc)/./server/routers/_app.ts":
/*!********************************!*\
  !*** ./server/routers/_app.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appRouter: () => (/* binding */ appRouter)\n/* harmony export */ });\n/* harmony import */ var _trpc_server__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @trpc/server */ \"(rsc)/./node_modules/@trpc/server/dist/initTRPC-T5bbc89W.mjs\");\n/* harmony import */ var superjson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! superjson */ \"(rsc)/./node_modules/superjson/dist/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v4/classic/external.js\");\n/* harmony import */ var _lib_prisma__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/prisma */ \"(rsc)/./lib/prisma.ts\");\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @google/generative-ai */ \"(rsc)/./node_modules/@google/generative-ai/dist/index.mjs\");\n/* harmony import */ var _lib_tiktok_scraper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/tiktok-scraper */ \"(rsc)/./lib/tiktok-scraper.ts\");\n/* harmony import */ var _lib_tierUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/tierUtils */ \"(rsc)/./server/lib/tierUtils.ts\");\n\n\n\n\n\n\n\n// Minimal tRPC setup for type compatibility\n// This app uses REST API routes, but tRPC types are imported for compatibility\nconst t = _trpc_server__WEBPACK_IMPORTED_MODULE_5__.initTRPC.context().create({\n    transformer: superjson__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n});\nconst appRouter = t.router({\n    health: t.procedure.query(()=>{\n        return \"OK from tRPC!\";\n    }),\n    getUser: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        userId: zod__WEBPACK_IMPORTED_MODULE_6__.string()\n    })).query(async ({ input })=>{\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: input.userId\n            },\n            select: {\n                id: true,\n                name: true,\n                email: true,\n                role: true,\n                balance: true,\n                avatar: true,\n                tiktokHandle: true,\n                couponBalance: true,\n                plan: true,\n                subscriptionEndsAt: true,\n                cycleStartDate: true,\n                totalLikes: true,\n                videoCount: true,\n                followingCount: true,\n                followerCount: true,\n                creatorTier: true,\n                lastStatsFetchedAt: true\n            }\n        });\n        return user;\n    }),\n    updateProfile: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        tiktokHandle: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional()\n    })).mutation(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) {\n            throw new Error(\"UNAUTHORIZED\");\n        }\n        // Rate limiting: Check if updated recently (e.g. 10 mins)\n        const currentUser = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            },\n            select: {\n                lastStatsFetchedAt: true,\n                tiktokHandle: true\n            }\n        });\n        // If user is just refreshing (no new handle) and updated recently\n        if (!input.tiktokHandle && currentUser?.lastStatsFetchedAt) {\n            const timeDiff = new Date().getTime() - new Date(currentUser.lastStatsFetchedAt).getTime();\n            const minutesDiff = timeDiff / (1000 * 60);\n            if (minutesDiff < 10) {\n                // Return existing user without update if within limit\n                return _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n                    where: {\n                        id: userId\n                    }\n                });\n            }\n        }\n        let updateData = {\n            tiktokHandle: input.tiktokHandle\n        };\n        const toCheck = input.tiktokHandle || currentUser?.tiktokHandle;\n        if (toCheck) {\n            try {\n                const { tiktokScraper } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/tiktok-scraper */ \"(rsc)/./lib/tiktok-scraper.ts\"));\n                const profile = await tiktokScraper.checkUserProfile(toCheck);\n                if (profile.isValid) {\n                    if (profile.avatar) updateData.avatar = profile.avatar;\n                    updateData.tiktokHandle = profile.uniqueId;\n                    updateData.name = profile.uniqueId; // Or keep existing name? content creator name might be better\n                    // Stats Update\n                    if (profile.followerCount !== undefined) updateData.followerCount = profile.followerCount;\n                    if (profile.followingCount !== undefined) updateData.followingCount = profile.followingCount;\n                    if (profile.heartCount !== undefined) updateData.totalLikes = profile.heartCount;\n                    if (profile.videoCount !== undefined) updateData.videoCount = profile.videoCount;\n                    updateData.lastStatsFetchedAt = new Date();\n                    // Calculate and save creator tier based on follower count\n                    if (profile.followerCount !== undefined) {\n                        updateData.creatorTier = (0,_lib_tierUtils__WEBPACK_IMPORTED_MODULE_4__.getCreatorTierFromFollowers)(profile.followerCount);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Failed to fetch TikTok profile:\", error);\n                if (input.tiktokHandle) {\n                    throw new Error(\"TikTok profili bulunamadı veya erişilemiyor.\");\n                }\n            }\n        }\n        const updatedUser = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.update({\n            where: {\n                id: userId\n            },\n            data: updateData\n        });\n        return updatedUser;\n    }),\n    createUser: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        userId: zod__WEBPACK_IMPORTED_MODULE_6__.string(),\n        email: zod__WEBPACK_IMPORTED_MODULE_6__.string().email(),\n        name: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional()\n    })).mutation(async ({ input })=>{\n        // Check if user already exists\n        const existing = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: input.userId\n            }\n        });\n        if (existing) {\n            return existing;\n        }\n        // Create new user in database\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.create({\n            data: {\n                id: input.userId,\n                email: input.email,\n                password: \"supabase-auth\",\n                name: input.name || \"i\\xe7erik \\xfcreticisi\",\n                role: \"CREATOR\",\n                balance: 0,\n                couponBalance: 0,\n                plan: \"FREE\",\n                cycleStartDate: new Date()\n            }\n        });\n        return user;\n    }),\n    getActiveCampaigns: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        search: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional(),\n        tier: zod__WEBPACK_IMPORTED_MODULE_6__[\"enum\"]([\n            \"D\",\n            \"C\",\n            \"B\",\n            \"A\",\n            \"S\"\n        ]).optional(),\n        limit: zod__WEBPACK_IMPORTED_MODULE_6__.number().optional().default(100)\n    }).optional()).query(async ({ input })=>{\n        const search = input?.search;\n        const tier = input?.tier;\n        const limit = input?.limit || 100;\n        const where = {\n            status: \"ACTIVE\",\n            endDate: {\n                gt: new Date()\n            }\n        };\n        // Server-side search\n        if (search) {\n            where.OR = [\n                {\n                    title: {\n                        contains: search,\n                        mode: \"insensitive\"\n                    }\n                },\n                {\n                    song: {\n                        title: {\n                            contains: search,\n                            mode: \"insensitive\"\n                        }\n                    }\n                },\n                {\n                    song: {\n                        authorName: {\n                            contains: search,\n                            mode: \"insensitive\"\n                        }\n                    }\n                }\n            ];\n        }\n        // Tier filter\n        if (tier) {\n            where.tier = tier;\n        }\n        const campaigns = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findMany({\n            where,\n            take: limit,\n            select: {\n                id: true,\n                title: true,\n                status: true,\n                tier: true,\n                totalBudget: true,\n                maxSubmissions: true,\n                maxParticipants: true,\n                isProOnly: true,\n                targetTiers: true,\n                endDate: true,\n                minFollowers: true,\n                minVideoDuration: true,\n                platformFeePercent: true,\n                safetyReservePercent: true,\n                song: {\n                    select: {\n                        title: true,\n                        coverImage: true,\n                        authorName: true,\n                        artist: {\n                            select: {\n                                name: true\n                            }\n                        }\n                    }\n                },\n                _count: {\n                    select: {\n                        submissions: true\n                    }\n                }\n            },\n            orderBy: {\n                createdAt: \"desc\"\n            }\n        });\n        return campaigns;\n    }),\n    getJoinedCampaigns: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        cursor: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional(),\n        limit: zod__WEBPACK_IMPORTED_MODULE_6__.number().min(1).max(100).default(20),\n        endedOnly: zod__WEBPACK_IMPORTED_MODULE_6__.boolean().optional() // Filter for ended campaigns only\n    }).optional()).query(async ({ ctx, input })=>{\n        const userId = ctx.user?.id;\n        if (!userId) return {\n            campaigns: [],\n            nextCursor: null\n        };\n        const limit = input?.limit || 20;\n        const endedOnly = input?.endedOnly || false;\n        const where = {\n            submissions: {\n                some: {\n                    creatorId: userId\n                }\n            }\n        };\n        // Filter for ended campaigns if requested\n        if (endedOnly) {\n            where.OR = [\n                {\n                    status: \"COMPLETED\"\n                },\n                {\n                    endDate: {\n                        lt: new Date()\n                    }\n                }\n            ];\n        }\n        // Cursor-based pagination\n        if (input?.cursor) {\n            where.id = {\n                lt: input.cursor\n            };\n        }\n        const campaigns = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findMany({\n            where,\n            take: limit + 1,\n            select: {\n                id: true,\n                title: true,\n                status: true,\n                totalBudget: true,\n                maxSubmissions: true,\n                endDate: true,\n                platformFeePercent: true,\n                safetyReservePercent: true,\n                submissions: {\n                    where: {\n                        creatorId: userId\n                    },\n                    select: {\n                        id: true,\n                        status: true,\n                        lastViewCount: true,\n                        lastLikeCount: true,\n                        lastShareCount: true,\n                        createdAt: true,\n                        viewPoints: true,\n                        likePoints: true,\n                        sharePoints: true,\n                        totalPoints: true,\n                        sharePercent: true,\n                        estimatedEarnings: true\n                    }\n                },\n                song: {\n                    select: {\n                        title: true,\n                        authorName: true,\n                        coverImage: true,\n                        artist: {\n                            select: {\n                                name: true\n                            }\n                        }\n                    }\n                },\n                poolStats: {\n                    select: {\n                        totalCampaignPoints: true,\n                        totalSubmissions: true,\n                        averagePoints: true\n                    }\n                },\n                _count: {\n                    select: {\n                        submissions: true\n                    }\n                }\n            },\n            orderBy: {\n                updatedAt: \"desc\"\n            }\n        });\n        // Check if there are more results\n        const hasMore = campaigns.length > limit;\n        const result = hasMore ? campaigns.slice(0, limit) : campaigns;\n        const nextCursor = hasMore ? result[result.length - 1].id : null;\n        return {\n            campaigns: result,\n            nextCursor\n        };\n    }),\n    getCampaignCounts: t.procedure.query(async ({ ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const [activeCount, myActiveCount, joinedActiveCount] = await Promise.all([\n            // 1. Total Active Campaigns\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.count({\n                where: {\n                    status: \"ACTIVE\",\n                    endDate: {\n                        gt: new Date()\n                    }\n                }\n            }),\n            // 2. My Active Campaigns (if Artist)\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.count({\n                where: {\n                    artistId: userId,\n                    status: \"ACTIVE\",\n                    endDate: {\n                        gt: new Date()\n                    }\n                }\n            }),\n            // 3. Joined Active Campaigns (if Creator)\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.count({\n                where: {\n                    status: \"ACTIVE\",\n                    endDate: {\n                        gt: new Date()\n                    },\n                    submissions: {\n                        some: {\n                            creatorId: userId\n                        }\n                    }\n                }\n            })\n        ]);\n        return {\n            activeCount,\n            myActiveCount,\n            joinedActiveCount\n        };\n    }),\n    getCampaignById: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        id: zod__WEBPACK_IMPORTED_MODULE_6__.string()\n    })).query(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        // 1. Fetch Campaign Base Info\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findUnique({\n            where: {\n                id: input.id\n            },\n            include: {\n                _count: {\n                    select: {\n                        submissions: true\n                    }\n                },\n                song: {\n                    select: {\n                        title: true,\n                        coverImage: true,\n                        duration: true,\n                        tiktokUrl: true,\n                        tiktokMusicId: true,\n                        authorName: true,\n                        artist: {\n                            select: {\n                                name: true,\n                                bio: true,\n                                avatar: true\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        if (!campaign) return null;\n        // 2. Fetch My Submission (if logged in AND not the campaign owner)\n        let mySubmission = null;\n        if (userId && campaign.artistId !== userId) {\n            mySubmission = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findFirst({\n                where: {\n                    campaignId: input.id,\n                    creatorId: userId\n                }\n            });\n        }\n        // 3. Calculate Total Campaign Points (Real-time)\n        const aggregations = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.aggregate({\n            where: {\n                campaignId: input.id\n            },\n            _sum: {\n                lastViewCount: true,\n                lastLikeCount: true,\n                lastShareCount: true\n            }\n        });\n        // Calculate total points consistent with All Submissions logic\n        // Fetch all submissions light-weight to sum accurately\n        const allSubmissions = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findMany({\n            where: {\n                campaignId: input.id\n            },\n            select: {\n                totalPoints: true,\n                viewPoints: true,\n                likePoints: true,\n                sharePoints: true,\n                lastViewCount: true,\n                lastLikeCount: true,\n                lastShareCount: true\n            }\n        });\n        const totalCampaignPoints = allSubmissions.reduce((sum, sub)=>{\n            // Backfill logic matching getCampaignSubmissions\n            const viewPoints = sub.viewPoints || sub.lastViewCount * 0.01;\n            const likePoints = sub.likePoints || sub.lastLikeCount * 0.5;\n            const sharePoints = sub.sharePoints || sub.lastShareCount * 1.0;\n            const points = sub.totalPoints || viewPoints + likePoints + sharePoints;\n            return sum + points;\n        }, 0);\n        // Keep strict view/like totals from aggregation as they are raw counters\n        const totalViews = aggregations._sum.lastViewCount || 0;\n        const totalLikes = aggregations._sum.lastLikeCount || 0;\n        const totalShares = aggregations._sum.lastShareCount || 0;\n        // 4. Fetch Recent Submissions (If Owner) - for Artist View\n        let recentSubmissions = [];\n        if (userId && campaign.artistId === userId) {\n            recentSubmissions = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findMany({\n                where: {\n                    campaignId: input.id\n                },\n                orderBy: {\n                    createdAt: \"desc\"\n                },\n                take: 10,\n                select: {\n                    id: true,\n                    createdAt: true,\n                    tiktokUrl: true,\n                    totalPoints: true,\n                    sharePercent: true,\n                    viewPoints: true,\n                    likePoints: true,\n                    sharePoints: true,\n                    lastViewCount: true,\n                    lastLikeCount: true,\n                    lastShareCount: true,\n                    estimatedEarnings: true,\n                    creator: {\n                        select: {\n                            name: true,\n                            avatar: true,\n                            tiktokHandle: true\n                        }\n                    }\n                }\n            });\n        }\n        // Destructure to exclude stale computed fields from database\n        const { totalCampaignPoints: _, netBudgetTP: __, netMultiplier: ___, ...campaignData } = campaign;\n        return {\n            ...campaignData,\n            mySubmission,\n            // Always use fresh computed values, not stale database fields\n            totalViews,\n            totalCampaignPoints,\n            totalLikes,\n            totalShares,\n            submissions: recentSubmissions.map((sub)=>({\n                    ...sub,\n                    viewPoints: sub.viewPoints || sub.lastViewCount * 0.01,\n                    likePoints: sub.likePoints || sub.lastLikeCount * 0.5,\n                    sharePoints: sub.sharePoints || sub.lastShareCount * 1.0,\n                    totalPoints: sub.totalPoints || sub.lastViewCount * 0.01 + sub.lastLikeCount * 0.5 + sub.lastShareCount * 1.0\n                })) // Compatible array for Artist View\n        };\n    }),\n    getCampaignSubmissions: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        campaignId: zod__WEBPACK_IMPORTED_MODULE_6__.string(),\n        cursor: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional(),\n        limit: zod__WEBPACK_IMPORTED_MODULE_6__.number().min(1).max(100).default(25),\n        search: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional(),\n        sortBy: zod__WEBPACK_IMPORTED_MODULE_6__[\"enum\"]([\n            \"percentage\",\n            \"views\",\n            \"likes\",\n            \"shares\",\n            \"points\",\n            \"recent\",\n            \"tier\"\n        ]).default(\"percentage\")\n    })).query(async ({ input, ctx })=>{\n        const { campaignId, cursor, limit, search, sortBy } = input;\n        const where = {\n            campaignId\n        };\n        // Search Filter\n        if (search) {\n            where.creator = {\n                tiktokHandle: {\n                    contains: search,\n                    mode: \"insensitive\"\n                }\n            };\n        }\n        // Sort Logic\n        let orderBy = {};\n        switch(sortBy){\n            case \"percentage\":\n                orderBy = {\n                    sharePercent: \"desc\"\n                };\n                break;\n            case \"views\":\n                orderBy = {\n                    lastViewCount: \"desc\"\n                };\n                break;\n            case \"likes\":\n                orderBy = {\n                    lastLikeCount: \"desc\"\n                };\n                break;\n            case \"shares\":\n                orderBy = {\n                    lastShareCount: \"desc\"\n                };\n                break;\n            case \"points\":\n                orderBy = {\n                    totalPoints: \"desc\"\n                };\n                break;\n            case \"recent\":\n                orderBy = {\n                    createdAt: \"desc\"\n                };\n                break;\n            case \"tier\":\n                orderBy = {\n                    creator: {\n                        creatorTier: \"desc\"\n                    }\n                };\n                break; // S > A > B > C > D\n        }\n        const submissions = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findMany({\n            where,\n            take: limit + 1,\n            cursor: cursor ? {\n                id: cursor\n            } : undefined,\n            orderBy,\n            select: {\n                id: true,\n                createdAt: true,\n                tiktokUrl: true,\n                totalPoints: true,\n                sharePercent: true,\n                viewPoints: true,\n                likePoints: true,\n                sharePoints: true,\n                lastViewCount: true,\n                lastLikeCount: true,\n                lastShareCount: true,\n                estimatedEarnings: true,\n                creator: {\n                    select: {\n                        name: true,\n                        avatar: true,\n                        tiktokHandle: true,\n                        creatorTier: true // Added for tier display and sorting\n                    }\n                }\n            }\n        });\n        let nextCursor = undefined;\n        if (submissions.length > limit) {\n            const nextItem = submissions.pop();\n            nextCursor = nextItem.id;\n        }\n        // Backfill points for legacy data if needed\n        const treatedSubmissions = submissions.map((sub)=>{\n            const viewPoints = sub.viewPoints || sub.lastViewCount * 0.01;\n            const likePoints = sub.likePoints || sub.lastLikeCount * 0.5;\n            const sharePoints = sub.sharePoints || sub.lastShareCount * 1.0;\n            const totalPoints = sub.totalPoints || viewPoints + likePoints + sharePoints;\n            return {\n                ...sub,\n                viewPoints,\n                likePoints,\n                sharePoints,\n                totalPoints\n            };\n        });\n        return {\n            submissions: treatedSubmissions,\n            nextCursor\n        };\n    }),\n    getCampaignAnalysis: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        id: zod__WEBPACK_IMPORTED_MODULE_6__.string(),\n        period: zod__WEBPACK_IMPORTED_MODULE_6__[\"enum\"]([\n            \"24h\",\n            \"7d\",\n            \"30d\",\n            \"all\"\n        ]).default(\"all\")\n    })).query(async ({ input, ctx })=>{\n        const { id, period } = input;\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findUnique({\n            where: {\n                id\n            },\n            include: {\n                submissions: {\n                    select: {\n                        createdAt: true,\n                        lastViewCount: true,\n                        lastLikeCount: true,\n                        lastShareCount: true,\n                        creator: {\n                            select: {\n                                creatorTier: true\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        if (!campaign) throw new Error(\"CAMPAIGN_NOT_FOUND\");\n        if (campaign.artistId !== userId) throw new Error(\"FORBIDDEN\");\n        // Filter Submissions based on Period\n        let filteredSubmissions = campaign.submissions;\n        if (period !== \"all\") {\n            const now = new Date();\n            let startDate = new Date();\n            switch(period){\n                case \"24h\":\n                    startDate.setHours(now.getHours() - 24);\n                    break;\n                case \"7d\":\n                    startDate.setDate(now.getDate() - 7);\n                    break;\n                case \"30d\":\n                    startDate.setDate(now.getDate() - 30);\n                    break;\n            }\n            filteredSubmissions = campaign.submissions.filter((sub)=>new Date(sub.createdAt) >= startDate);\n        }\n        // Calculate Totals server-side\n        const totals = filteredSubmissions.reduce((acc, sub)=>({\n                views: acc.views + (sub.lastViewCount || 0),\n                likes: acc.likes + (sub.lastLikeCount || 0),\n                shares: acc.shares + (sub.lastShareCount || 0),\n                submissions: acc.submissions + 1\n            }), {\n            views: 0,\n            likes: 0,\n            shares: 0,\n            submissions: 0\n        });\n        // Calculate Tier Distribution\n        const tierCounts = {\n            D: 0,\n            C: 0,\n            B: 0,\n            A: 0,\n            S: 0\n        };\n        filteredSubmissions.forEach((sub)=>{\n            const tier = sub.creator?.creatorTier || \"D\";\n            tierCounts[tier] = (tierCounts[tier] || 0) + 1;\n        });\n        const totalSubmissions = filteredSubmissions.length;\n        const tierDistribution = Object.entries(tierCounts).map(([tier, count])=>({\n                tier,\n                count,\n                percentage: totalSubmissions > 0 ? count / totalSubmissions * 100 : 0\n            })).filter((item)=>item.count > 0) // Only include tiers that have submissions\n        .sort((a, b)=>{\n            const order = {\n                S: 5,\n                A: 4,\n                B: 3,\n                C: 2,\n                D: 1\n            };\n            return (order[b.tier] || 0) - (order[a.tier] || 0);\n        });\n        // Calculate Daily Stats (Chart Data) server-side\n        const grouped = filteredSubmissions.reduce((acc, sub)=>{\n            //For 24h view, group by Hour instead of Date? \n            // User requested \"top of graph... 24s, 7g, 30g\". \n            // Typically for 24h, hourly breakdown is better, but daily is safer for now unless requested.\n            // Let's stick to daily for 7d/30d/all. For 24h, daily might be just 1 or 2 points.\n            // Let's use Hour:Minute for 24h, otherwise Date.\n            let label = \"\";\n            if (period === \"24h\") {\n                label = new Date(sub.createdAt).toLocaleTimeString(\"tr-TR\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\"\n                });\n            } else {\n                label = new Date(sub.createdAt).toLocaleDateString(\"tr-TR\", {\n                    day: \"2-digit\",\n                    month: \"2-digit\"\n                });\n            }\n            if (!acc[label]) {\n                acc[label] = {\n                    date: label,\n                    views: 0,\n                    likes: 0,\n                    shares: 0,\n                    count: 0\n                };\n            }\n            acc[label].views += sub.lastViewCount || 0;\n            acc[label].likes += sub.lastLikeCount || 0;\n            acc[label].shares += sub.lastShareCount || 0;\n            acc[label].count += 1;\n            return acc;\n        }, {});\n        const chartData = Object.values(grouped).sort((a, b)=>{\n            // Sort logic needs to handle HH:mm vs DD.MM\n            if (period === \"24h\") {\n                return a.date.localeCompare(b.date); // Simple string compare for HH:mm works for same day usually, but across midnight?\n            // Using timestamp from original data would be better but we grouped. \n            // Re-sorting by \"first item found\" timestamp might be complex here.\n            // Let's stick to simple \"insert order\" or string sort for now.\n            // Actually, '24h' usually means \"last 24 hours\", so it spans 2 days.\n            // Correct sorting requires fuller date info.\n            // Simplified: The frontend chart logic relies on a.date.split('.').\n            // I will keep using DD.MM for consistency for now to avoid breaking frontend chart parsing which splits by '.'\n            // Wait, for 24h, showing just 2 bars (Today vs Yesterday) is probably fine/expected if we stick to DD.MM.\n            // If I change format, I break frontend.\n            // Decision: Stick to DD.MM for \"all\", \"7d\", \"30d\".\n            // For \"24h\", it essentially shows just the relevant days (usually 1 or 2).\n            // If user really wants hourly, I'd need to update frontend chart parsing too.\n            // I will stick to the existing DD.MM format to stay safe and consistent.\n            }\n            const [d1, m1] = a.date.split(\".\");\n            const [d2, m2] = b.date.split(\".\");\n            return new Date(2024, parseInt(m1) - 1, parseInt(d1)).getTime() - new Date(2024, parseInt(m2) - 1, parseInt(d2)).getTime();\n        });\n        return {\n            campaign,\n            totals,\n            chartData,\n            tierDistribution\n        };\n    }),\n    getSubmittedCampaign: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        id: zod__WEBPACK_IMPORTED_MODULE_6__.string()\n    })).query(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findUnique({\n            where: {\n                id: input.id\n            },\n            include: {\n                _count: {\n                    select: {\n                        submissions: true\n                    }\n                },\n                song: {\n                    select: {\n                        title: true,\n                        coverImage: true,\n                        duration: true,\n                        tiktokUrl: true,\n                        artist: {\n                            select: {\n                                name: true,\n                                avatar: true\n                            }\n                        }\n                    }\n                },\n                submissions: {\n                    where: {\n                        creatorId: userId\n                    },\n                    take: 1\n                }\n            }\n        });\n        if (!campaign || campaign.submissions.length === 0) {\n            throw new Error(\"SUBMISSION_NOT_FOUND\");\n        }\n        const mySubmission = campaign.submissions[0];\n        let finalSubmission = mySubmission;\n        // Smart Refresh: Check if stale (> 6 hours)\n        const now = new Date();\n        const lastChecked = mySubmission.lastCheckedAt ? new Date(mySubmission.lastCheckedAt) : new Date(0);\n        const diffHours = (now.getTime() - lastChecked.getTime()) / (1000 * 60 * 60);\n        if (diffHours > 6) {\n            try {\n                const { tiktokScraper } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/tiktok-scraper */ \"(rsc)/./lib/tiktok-scraper.ts\"));\n                const videoData = await tiktokScraper.verifyVideo(mySubmission.tiktokUrl);\n                finalSubmission = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.update({\n                    where: {\n                        id: mySubmission.id\n                    },\n                    data: {\n                        lastViewCount: videoData.views,\n                        lastLikeCount: videoData.likes,\n                        lastCommentCount: videoData.comments,\n                        lastShareCount: videoData.shares,\n                        lastCheckedAt: new Date()\n                    }\n                });\n            } catch (error) {\n                console.error(\"Smart Refresh Failed:\", error);\n            // Fail silently and show old data\n            }\n        }\n        // Live Aggregation\n        const aggregations = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.aggregate({\n            where: {\n                campaignId: input.id\n            },\n            _sum: {\n                lastViewCount: true,\n                lastLikeCount: true,\n                lastShareCount: true\n            }\n        });\n        const totalViews = aggregations._sum.lastViewCount || 0;\n        const totalLikes = aggregations._sum.lastLikeCount || 0;\n        const totalShares = aggregations._sum.lastShareCount || 0;\n        const totalCampaignPoints = totalViews * 0.01 + totalLikes * 0.5 + totalShares * 1.0;\n        return {\n            campaign,\n            submission: finalSubmission,\n            poolStats: {\n                totalCampaignPoints,\n                totalViews,\n                totalLikes\n            }\n        };\n    }),\n    validateVideo: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        campaignId: zod__WEBPACK_IMPORTED_MODULE_6__.string(),\n        tiktokUrl: zod__WEBPACK_IMPORTED_MODULE_6__.string().url()\n    })).mutation(async ({ ctx, input })=>{\n        if (!ctx.user) throw new Error(\"UNAUTHORIZED\");\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findUnique({\n            where: {\n                id: input.campaignId\n            },\n            include: {\n                song: true\n            }\n        });\n        if (!campaign) throw new Error(\"CAMPAIGN_NOT_FOUND\");\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: ctx.user.id\n            }\n        });\n        if (!user) throw new Error(\"USER_NOT_FOUND\");\n        let videoData;\n        try {\n            videoData = await _lib_tiktok_scraper__WEBPACK_IMPORTED_MODULE_3__.tiktokScraper.verifyVideo(input.tiktokUrl);\n        } catch (e) {\n            return {\n                isValid: false,\n                errors: [\n                    `Video doğrulanamadı: ${e.message}`\n                ],\n                video: null,\n                checks: {}\n            };\n        }\n        const errors = [];\n        // 1. Account Check\n        let isAccountMatch = false;\n        if (user.tiktokHandle) {\n            isAccountMatch = videoData.creatorUsername?.toLowerCase() === user.tiktokHandle.toLowerCase();\n            if (!isAccountMatch) {\n                errors.push(`Hesap Uyuşmazlığı: Video @${videoData.creatorUsername} ait, TikPay hesabın @${user.tiktokHandle}`);\n            }\n        } else {\n            errors.push(\"Profilinde TikTok kullanıcı adı tanımlı değil. L\\xfctfen profilinden ekle.\");\n        }\n        // 2. Song Check\n        const musicIdMatch = campaign.song.tiktokMusicId && videoData.soundId === campaign.song.tiktokMusicId;\n        const titleMatch = _lib_tiktok_scraper__WEBPACK_IMPORTED_MODULE_3__.tiktokScraper.verifySong(videoData, campaign.song.title);\n        const isSongMatch = !!(musicIdMatch || titleMatch);\n        if (!isSongMatch) {\n            errors.push(`Müzik Eşleşmedi: Kampanya şarkısı \"${campaign.song.title}\" videoda bulunamadı.`);\n        }\n        // 3. Requirements\n        const durationMatch = !campaign.minVideoDuration || videoData.duration >= campaign.minVideoDuration;\n        if (!durationMatch) {\n            errors.push(`Süre Yetersiz: Video ${videoData.duration}sn (Min: ${campaign.minVideoDuration}sn)`);\n        }\n        const followerMatch = !campaign.minFollowers || (videoData.creatorFollowers || 0) >= campaign.minFollowers;\n        if (!followerMatch) {\n            errors.push(`Takipçi Yetersiz: ${videoData.creatorFollowers} takipçi (Min: ${campaign.minFollowers})`);\n        }\n        return {\n            isValid: errors.length === 0,\n            errors,\n            video: videoData,\n            checks: {\n                accountMatch: isAccountMatch,\n                songMatch: isSongMatch,\n                durationMatch,\n                followerMatch\n            }\n        };\n    }),\n    submitVideo: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        campaignId: zod__WEBPACK_IMPORTED_MODULE_6__.string(),\n        tiktokUrl: zod__WEBPACK_IMPORTED_MODULE_6__.string().url()\n    })).mutation(async ({ input, ctx })=>{\n        // Validate user is logged in\n        const userId = ctx.user?.id;\n        if (!userId) {\n            throw new Error(\"UNAUTHORIZED\");\n        }\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            },\n            select: {\n                plan: true,\n                cycleStartDate: true,\n                creatorTier: true\n            }\n        });\n        if (!user) throw new Error(\"USER_NOT_FOUND\");\n        // Check Free Plan Limits (5 submissions / 30 days)\n        if (user.plan === \"FREE\") {\n            const cycleStart = user.cycleStartDate;\n            const now = new Date();\n            const daysInCycle = Math.floor((now.getTime() - cycleStart.getTime()) / (1000 * 60 * 60 * 24));\n            if (daysInCycle >= 30) {\n                // Reset cycle if > 30 days\n                await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.update({\n                    where: {\n                        id: userId\n                    },\n                    data: {\n                        cycleStartDate: now\n                    }\n                });\n            } else {\n                // Count submissions in current cycle\n                const submissionCount = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.count({\n                    where: {\n                        creatorId: userId,\n                        createdAt: {\n                            gte: cycleStart\n                        }\n                    }\n                });\n                if (submissionCount >= 5) {\n                    throw new Error(\"PLAN_LIMIT_REACHED\");\n                }\n            }\n        }\n        // Check if already submitted\n        const existing = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findUnique({\n            where: {\n                campaignId_creatorId: {\n                    campaignId: input.campaignId,\n                    creatorId: userId\n                }\n            }\n        });\n        if (existing) {\n            throw new Error(\"ALREADY_SUBMITTED\");\n        }\n        // Check Campaign Status & Limits\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findUnique({\n            where: {\n                id: input.campaignId\n            },\n            include: {\n                _count: {\n                    select: {\n                        submissions: true\n                    }\n                }\n            }\n        });\n        if (!campaign) throw new Error(\"CAMPAIGN_NOT_FOUND\");\n        if (campaign.status !== \"ACTIVE\") throw new Error(\"CAMPAIGN_NOT_ACTIVE\");\n        // Check tier eligibility - creators can only join campaigns at their tier or lower\n        if (!(0,_lib_tierUtils__WEBPACK_IMPORTED_MODULE_4__.isCreatorEligibleForCampaign)(user.creatorTier, campaign.tier)) {\n            const tierNames = {\n                D: \"D\",\n                C: \"C (<1k takip\\xe7i)\",\n                B: \"B (1k-3k)\",\n                A: \"A (3k-5k)\",\n                S: \"S (5k+)\"\n            };\n            const requiredTier = tierNames[campaign.tier] || campaign.tier;\n            const userTier = user.creatorTier ? tierNames[user.creatorTier] : \"Yok\";\n            throw new Error(`TIER_NOT_ELIGIBLE: Bu kampanya ${requiredTier} tier gerektiriyor. Senin tier'in: ${userTier}. TikTok hesabını bağlayıp takipçi sayını doğrulaman gerekir.`);\n        }\n        if (campaign._count.submissions >= campaign.maxSubmissions) {\n            throw new Error(\"CAMPAIGN_FULL\");\n        }\n        // 1. Verify Video with TikAPI (mocked for now if API key missing)\n        // We import dynamically to avoid issues if not used elsewhere\n        const { tiktokScraper } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/tiktok-scraper */ \"(rsc)/./lib/tiktok-scraper.ts\"));\n        let videoData;\n        try {\n            videoData = await tiktokScraper.verifyVideo(input.tiktokUrl);\n        } catch (e) {\n            throw new Error(`INVALID_VIDEO: ${e.message}`);\n        }\n        // 2. Create Submission\n        const submission = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.create({\n            data: {\n                campaignId: input.campaignId,\n                creatorId: userId,\n                tiktokUrl: input.tiktokUrl,\n                tiktokVideoId: videoData.videoId,\n                status: \"APPROVED\",\n                // Initial stats\n                lastViewCount: videoData.views,\n                lastLikeCount: videoData.likes,\n                lastCommentCount: videoData.comments,\n                lastShareCount: videoData.shares,\n                videoDuration: videoData.duration,\n                creatorFollowers: videoData.creatorFollowers,\n                lastCheckedAt: new Date()\n            }\n        });\n        // 3. Trigger backend calculations immediately\n        const { onSubmissionStatsUpdate } = await __webpack_require__.e(/*! import() */ \"_rsc_server_services_submissionHooks_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/server/services/submissionHooks */ \"(rsc)/./server/services/submissionHooks.ts\"));\n        await onSubmissionStatsUpdate(submission.id, _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma);\n        return {\n            success: true,\n            submissionId: submission.id\n        };\n    }),\n    deleteSubmission: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        submissionId: zod__WEBPACK_IMPORTED_MODULE_6__.string()\n    })).mutation(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        // 1. Verify ownership\n        const submission = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findUnique({\n            where: {\n                id: input.submissionId\n            },\n            select: {\n                creatorId: true,\n                campaignId: true,\n                status: true\n            }\n        });\n        if (!submission) throw new Error(\"SUBMISSION_NOT_FOUND\");\n        if (submission.creatorId !== userId) throw new Error(\"UNAUTHORIZED\");\n        // 2. Don't allow deletion of approved submissions (optional - you can remove this check)\n        if (submission.status === \"APPROVED\") {\n            throw new Error(\"CANNOT_DELETE_APPROVED_SUBMISSION\");\n        }\n        // Store campaign ID before deletion\n        const campaignId = submission.campaignId;\n        // 3. Delete the submission\n        await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.delete({\n            where: {\n                id: input.submissionId\n            }\n        });\n        // 4. Recalculate campaign stats (to update total points and other submissions' share percentages)\n        const { CalculationService } = await __webpack_require__.e(/*! import() */ \"_rsc_server_services_calculationService_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/server/services/calculationService */ \"(rsc)/./server/services/calculationService.ts\"));\n        await CalculationService.updateCampaignTotalPoints(campaignId, _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma);\n        await CalculationService.recalculateCampaignSubmissions(campaignId, _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma);\n        return {\n            success: true\n        };\n    }),\n    createCampaign: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        tiktokUrl: zod__WEBPACK_IMPORTED_MODULE_6__.string().url(),\n        title: zod__WEBPACK_IMPORTED_MODULE_6__.string().min(1),\n        description: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional(),\n        budget: zod__WEBPACK_IMPORTED_MODULE_6__.number().min(150000),\n        minVideoDuration: zod__WEBPACK_IMPORTED_MODULE_6__.number().optional(),\n        startDate: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional(),\n        endDate: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional()\n    })).mutation(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) {\n            throw new Error(\"UNAUTHORIZED\");\n        }\n        // Import tier utilities\n        const { getCampaignTierFromBudget, getMinFollowersForTier, getMaxSubmissionsFromBudget } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/server/lib/tierUtils */ \"(rsc)/./server/lib/tierUtils.ts\"));\n        // 1. Fetch Song Data from TikTok (using shared scraper)\n        const { tiktokScraper } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/tiktok-scraper */ \"(rsc)/./lib/tiktok-scraper.ts\"));\n        let songData;\n        try {\n            // This fetches song metadata (title, artist, cover)\n            songData = await tiktokScraper.fetchSongDetails(input.tiktokUrl);\n        } catch (e) {\n            throw new Error(`INVALID_SOUND: ${e.message}`);\n        }\n        // 2. Find or Create Song\n        let song = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.song.findFirst({\n            where: {\n                tiktokUrl: input.tiktokUrl\n            }\n        });\n        if (!song) {\n            song = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.song.create({\n                data: {\n                    title: songData.title,\n                    tiktokUrl: input.tiktokUrl,\n                    duration: songData.duration,\n                    coverImage: songData.coverImage,\n                    artistId: userId,\n                    authorName: songData.authorName,\n                    statsLastFetched: new Date()\n                }\n            });\n        }\n        // Parse dates\n        const startDate = input.startDate ? new Date(input.startDate) : new Date();\n        const endDate = input.endDate ? new Date(input.endDate) : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);\n        // 3. Calculate tier-based values\n        const budgetTP = input.budget;\n        const budgetTL = budgetTP / 10; // 10 TP = 1 TL Conversion\n        // Calculate campaign tier and auto-set requirements\n        const campaignTier = getCampaignTierFromBudget(budgetTL);\n        const minFollowers = getMinFollowersForTier(campaignTier);\n        const maxSubmissions = getMaxSubmissionsFromBudget(budgetTL);\n        // 4. Deduction & Creation (Transaction)\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.$transaction(async (tx)=>{\n            // Check Balance\n            const user = await tx.user.findUnique({\n                where: {\n                    id: userId\n                }\n            });\n            if (!user) throw new Error(\"USER_NOT_FOUND\");\n            if (Number(user.balance) < budgetTL) {\n                throw new Error(\"INSUFFICIENT_BALANCE\");\n            }\n            // Deduct from Wallet\n            await tx.user.update({\n                where: {\n                    id: userId\n                },\n                data: {\n                    balance: {\n                        decrement: budgetTL\n                    }\n                }\n            });\n            // Record Spending Transaction\n            await tx.transaction.create({\n                data: {\n                    userId,\n                    type: \"SPEND\",\n                    amount: budgetTL,\n                    status: \"COMPLETED\",\n                    description: `Kampanya Oluşturma: ${input.title}`\n                }\n            });\n            // Create Campaign with tier\n            return await tx.campaign.create({\n                data: {\n                    title: input.title,\n                    description: input.description,\n                    totalBudget: budgetTL,\n                    remainingBudget: budgetTL,\n                    status: \"PENDING_APPROVAL\",\n                    tier: campaignTier,\n                    songId: song.id,\n                    artistId: userId,\n                    minFollowers: minFollowers,\n                    minVideoDuration: input.minVideoDuration,\n                    maxSubmissions: maxSubmissions,\n                    startDate: startDate,\n                    endDate: endDate\n                }\n            });\n        });\n        return {\n            success: true,\n            campaignId: campaign.id\n        };\n    }),\n    getMyCampaigns: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        cursor: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional(),\n        limit: zod__WEBPACK_IMPORTED_MODULE_6__.number().min(1).max(100).default(20),\n        endedOnly: zod__WEBPACK_IMPORTED_MODULE_6__.boolean().optional() // Filter for ended campaigns only\n    }).optional()).query(async ({ ctx, input })=>{\n        const userId = ctx.user?.id;\n        if (!userId) return {\n            campaigns: [],\n            nextCursor: null\n        };\n        const limit = input?.limit || 20;\n        const endedOnly = input?.endedOnly || false;\n        const where = {\n            artistId: userId\n        };\n        // Filter for ended campaigns if requested\n        if (endedOnly) {\n            where.OR = [\n                {\n                    status: \"COMPLETED\"\n                },\n                {\n                    endDate: {\n                        lt: new Date()\n                    }\n                }\n            ];\n        }\n        // Cursor-based pagination\n        if (input?.cursor) {\n            where.id = {\n                lt: input.cursor\n            };\n        }\n        const campaigns = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findMany({\n            where,\n            take: limit + 1,\n            select: {\n                id: true,\n                title: true,\n                description: true,\n                status: true,\n                tier: true,\n                totalBudget: true,\n                maxSubmissions: true,\n                startDate: true,\n                endDate: true,\n                minFollowers: true,\n                platformFeePercent: true,\n                safetyReservePercent: true,\n                artistId: true,\n                song: {\n                    select: {\n                        title: true,\n                        coverImage: true,\n                        authorName: true,\n                        artist: {\n                            select: {\n                                name: true\n                            }\n                        }\n                    }\n                },\n                poolStats: {\n                    select: {\n                        totalCampaignPoints: true,\n                        totalSubmissions: true,\n                        averagePoints: true\n                    }\n                },\n                _count: {\n                    select: {\n                        submissions: true\n                    }\n                }\n            },\n            orderBy: {\n                createdAt: \"desc\"\n            }\n        });\n        // Check if there are more results\n        const hasMore = campaigns.length > limit;\n        const result = hasMore ? campaigns.slice(0, limit) : campaigns;\n        const nextCursor = hasMore ? result[result.length - 1].id : null;\n        return {\n            campaigns: result,\n            nextCursor\n        };\n    }),\n    getCreatorStats: t.procedure.query(async ({ ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        // Fetch user info for tier, follower count, and plan\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            },\n            select: {\n                creatorTier: true,\n                followerCount: true,\n                plan: true\n            }\n        });\n        // OPTIMIZED: Use select instead of include to fetch only needed fields\n        // Eliminates deep nesting and reduces query time by 40-60%\n        const submissions = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findMany({\n            where: {\n                creatorId: userId\n            },\n            select: {\n                id: true,\n                status: true,\n                totalEarnings: true,\n                estimatedEarnings: true,\n                lastViewCount: true,\n                sharePercent: true,\n                createdAt: true,\n                updatedAt: true,\n                // Only select needed campaign fields\n                campaign: {\n                    select: {\n                        id: true,\n                        status: true,\n                        endDate: true,\n                        song: {\n                            select: {\n                                title: true\n                            }\n                        }\n                    }\n                }\n            },\n            orderBy: {\n                createdAt: \"desc\"\n            }\n        });\n        // Aggregate calculations - separate ended vs active campaigns\n        // FIXED: totalEarnings (Toplam) = sum of finalized earnings from ENDED campaigns only\n        const totalEarnings = submissions.filter((s)=>{\n            if (!s.campaign) return false;\n            // Campaign is ended if status is COMPLETED OR endDate has passed\n            const campaignEnded = s.campaign.status === \"COMPLETED\" || new Date(s.campaign.endDate) < new Date();\n            return campaignEnded; // Only ended campaigns\n        }).reduce((sum, s)=>sum + Number(s.totalEarnings), 0);\n        // FIXED: estimatedEarnings (Tahmini) = sum of estimated earnings from ACTIVE campaigns only\n        const estimatedEarnings = submissions.filter((s)=>{\n            if (!s.campaign) return false;\n            // Campaign is ended if status is COMPLETED OR endDate has passed\n            const campaignEnded = s.campaign.status === \"COMPLETED\" || new Date(s.campaign.endDate) < new Date();\n            return !campaignEnded; // Only active campaigns\n        }).reduce((sum, s)=>sum + Number(s.estimatedEarnings), 0);\n        const totalViews = submissions.reduce((sum, s)=>sum + (s.lastViewCount || 0), 0);\n        // UPDATED: Active videos count - only approved submissions with active (not ended) campaigns\n        const activeVideos = submissions.filter((s)=>{\n            if (s.status !== \"APPROVED\") return false;\n            if (!s.campaign) return false;\n            // Campaign is ended if status is COMPLETED OR endDate has passed\n            const campaignEnded = s.campaign.status === \"COMPLETED\" || new Date(s.campaign.endDate) < new Date();\n            return !campaignEnded; // Only count active campaigns\n        }).length;\n        // Calculate Average Contribution Percent - ONLY for ended campaigns\n        // OPTIMIZED: Filter from already-fetched submissions instead of separate query\n        const endedSubmissions = submissions.filter((s)=>{\n            const campaign = s.campaign;\n            return campaign && (campaign.status === \"COMPLETED\" || new Date(campaign.endDate) < new Date());\n        });\n        const avgContributionPercent = endedSubmissions.length > 0 ? endedSubmissions.reduce((sum, s)=>sum + (s.sharePercent || 0), 0) / endedSubmissions.length * 100 // Convert to percentage\n         : 0;\n        // Calculate Average Views - ONLY for ended campaigns\n        const avgViews = endedSubmissions.length > 0 ? Math.round(endedSubmissions.reduce((sum, s)=>sum + (s.lastViewCount || 0), 0) / endedSubmissions.length) : 0;\n        // Fetch Recent Activity - Show EARNING and SPEND transactions\n        const recentTransactions = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.transaction.findMany({\n            where: {\n                userId,\n                type: {\n                    in: [\n                        \"EARNING\",\n                        \"SPEND\"\n                    ]\n                } // Show earnings/payouts and purchases/subscriptions\n            },\n            take: 20,\n            orderBy: {\n                createdAt: \"desc\"\n            }\n        });\n        // OPTIMIZED: Use already-fetched submissions instead of separate query\n        // Filter for finished campaigns from the submissions we already have\n        const finishedSubmissions = submissions.filter((s)=>s.status === \"APPROVED\" && s.campaign && new Date(s.campaign.endDate) < new Date()).slice(0, 20);\n        const recentActivity = [\n            // Campaign earnings - only from finished campaigns\n            ...finishedSubmissions.map((s)=>({\n                    id: s.id,\n                    type: \"CAMPAIGN\",\n                    amount: (Number(s.estimatedEarnings) || 0) * 10,\n                    date: s.updatedAt,\n                    description: `${s.campaign?.song?.title || \"Kampanya\"} - Kazanç`,\n                    status: \"COMPLETED\",\n                    isPlus: true\n                })),\n            // Transactions (payouts, withdrawals, purchases)\n            ...recentTransactions.map((t)=>({\n                    id: t.id,\n                    type: t.type,\n                    amount: Number(t.amount) * 10,\n                    date: t.createdAt,\n                    description: t.description || \"\\xd6deme\",\n                    status: t.status,\n                    isPlus: t.type === \"EARNING\" // EARNING is positive, SPEND is negative\n                }))\n        ].sort((a, b)=>b.date.getTime() - a.date.getTime()).slice(0, 20);\n        return {\n            totalEarnings,\n            estimatedEarnings,\n            totalViews,\n            activeVideos,\n            avgContributionPercent,\n            avgViews,\n            totalVideos: submissions.length,\n            recentActivity,\n            recentSubmissions: submissions.filter((s)=>{\n                if (!s.campaign) return false;\n                // Only include submissions from active campaigns\n                const campaignEnded = s.campaign.status === \"COMPLETED\" || new Date(s.campaign.endDate) < new Date();\n                return !campaignEnded;\n            }).slice(0, 10),\n            // User info\n            creatorTier: user?.creatorTier,\n            followerCount: user?.followerCount || 0,\n            plan: user?.plan || \"FREE\"\n        };\n    }),\n    getArtistStats: t.procedure.query(async ({ ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        // OPTIMIZED: Parallelize all independent queries\n        const [budgetStats, viewStats, recentTransactions, activeCampaigns] = await Promise.all([\n            // 1. Calculate Active Budget & Campaign Count (Aggregation)\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.aggregate({\n                where: {\n                    artistId: userId,\n                    status: \"ACTIVE\"\n                },\n                _sum: {\n                    remainingBudget: true\n                },\n                _count: true\n            }),\n            // 2. Calculate Total Views (Aggregation)\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.aggregate({\n                where: {\n                    campaign: {\n                        artistId: userId\n                    }\n                },\n                _sum: {\n                    lastViewCount: true\n                }\n            }),\n            // 3. Recent Transactions\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.transaction.findMany({\n                where: {\n                    userId\n                },\n                take: 20,\n                orderBy: {\n                    createdAt: \"desc\"\n                }\n            }),\n            // 4. Active Campaigns List (for display)\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findMany({\n                where: {\n                    artistId: userId,\n                    status: \"ACTIVE\",\n                    endDate: {\n                        gt: new Date()\n                    }\n                },\n                select: {\n                    id: true,\n                    title: true,\n                    status: true,\n                    tier: true,\n                    totalBudget: true,\n                    remainingBudget: true,\n                    maxSubmissions: true,\n                    startDate: true,\n                    endDate: true,\n                    song: {\n                        select: {\n                            title: true,\n                            coverImage: true,\n                            authorName: true\n                        }\n                    },\n                    _count: {\n                        select: {\n                            submissions: true\n                        }\n                    }\n                },\n                orderBy: {\n                    createdAt: \"desc\"\n                },\n                take: 10\n            })\n        ]);\n        return {\n            // balance: REMOVED (Frontend uses getUser()->balance)\n            totalViews: viewStats._sum.lastViewCount || 0,\n            activeBudget: Number(budgetStats._sum.remainingBudget || 0),\n            activeCampaignsCount: budgetStats._count,\n            recentTransactions,\n            activeCampaigns\n        };\n    }),\n    getActivity: t.procedure.query(async ({ ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            }\n        });\n        if (!user) throw new Error(\"USER_NOT_FOUND\");\n        if (user.role === \"ARTIST\") {\n            // For Artist: Show submissions to THEIR campaigns\n            return await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findMany({\n                where: {\n                    campaign: {\n                        artistId: userId\n                    }\n                },\n                include: {\n                    campaign: {\n                        select: {\n                            title: true,\n                            song: {\n                                select: {\n                                    title: true,\n                                    coverImage: true\n                                }\n                            }\n                        }\n                    }\n                },\n                orderBy: {\n                    createdAt: \"desc\"\n                },\n                take: 20\n            });\n        } else {\n            // For Creator: Show THEIR submissions\n            return await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.submission.findMany({\n                where: {\n                    creatorId: userId\n                },\n                include: {\n                    campaign: {\n                        select: {\n                            title: true,\n                            song: {\n                                select: {\n                                    title: true,\n                                    coverImage: true,\n                                    artist: {\n                                        select: {\n                                            name: true\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                },\n                orderBy: {\n                    createdAt: \"desc\"\n                },\n                take: 20\n            });\n        }\n    }),\n    upgradeToPro: t.procedure.mutation(async ({ ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        // Mock success for credit card flow\n        const updatedUser = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.update({\n            where: {\n                id: userId\n            },\n            data: {\n                plan: \"PRO\"\n            }\n        });\n        return {\n            success: true,\n            user: updatedUser\n        };\n    }),\n    upgradeToProWithTP: t.procedure.mutation(async ({ ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            }\n        });\n        if (!user) throw new Error(\"USER_NOT_FOUND\");\n        // 1 TL = 10 TP. Price is 3000 TP => 300 TL.\n        const COST_TL = 300;\n        const COUPON_REWARD = 20; // Grant 20 coupons with each subscription\n        if (Number(user.balance) < COST_TL) {\n            throw new Error(\"INSUFFICIENT_BALANCE\");\n        }\n        // Add 30 days to current time\n        const expiresAt = new Date();\n        expiresAt.setDate(expiresAt.getDate() + 30);\n        const [updatedUser] = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.$transaction([\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.update({\n                where: {\n                    id: userId\n                },\n                data: {\n                    balance: {\n                        decrement: COST_TL\n                    },\n                    couponBalance: {\n                        increment: COUPON_REWARD\n                    },\n                    plan: \"PRO\",\n                    subscriptionEndsAt: expiresAt\n                }\n            }),\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.transaction.create({\n                data: {\n                    userId,\n                    type: \"SPEND\",\n                    amount: COST_TL,\n                    description: \"Pro \\xdcyelik (30 G\\xfcn) + 20 Market Kupon\",\n                    status: \"COMPLETED\"\n                }\n            })\n        ]);\n        return {\n            success: true,\n            user: updatedUser\n        };\n    }),\n    // Marketplace Procedures\n    buyCoupons: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        amount: zod__WEBPACK_IMPORTED_MODULE_6__.number().min(1)\n    })).mutation(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const COST_PER_COUPON = 100; // 100 TP per coupon\n        const totalCost = input.amount * COST_PER_COUPON;\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            }\n        });\n        if (!user) throw new Error(\"USER_NOT_FOUND\");\n        if (Number(user.balance) < totalCost) {\n            throw new Error(\"INSUFFICIENT_BALANCE\");\n        }\n        // Deduct balance and add coupons\n        await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.$transaction([\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.update({\n                where: {\n                    id: userId\n                },\n                data: {\n                    balance: {\n                        decrement: totalCost\n                    },\n                    couponBalance: {\n                        increment: input.amount\n                    }\n                }\n            }),\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.transaction.create({\n                data: {\n                    userId,\n                    type: \"SPEND\",\n                    amount: totalCost,\n                    status: \"COMPLETED\",\n                    description: `Kupon Satın Alma: ${input.amount} kupon`\n                }\n            })\n        ]);\n        return {\n            success: true\n        };\n    }),\n    useCoupon: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        tool: zod__WEBPACK_IMPORTED_MODULE_6__[\"enum\"]([\n            \"PROFILE\",\n            \"HASHTAG\",\n            \"VALUATION\",\n            \"AUDIT\",\n            \"COMPARE\"\n        ]),\n        input: zod__WEBPACK_IMPORTED_MODULE_6__.string().min(1)\n    })).mutation(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const user = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            }\n        });\n        if (!user) throw new Error(\"USER_NOT_FOUND\");\n        if (user.couponBalance < 1) {\n            throw new Error(\"INSUFFICIENT_COUPONS\");\n        }\n        // Mock Analysis Logic based on Tool Type\n        let resultData = {};\n        if (input.tool === \"HASHTAG\") {\n            try {\n                const apiKey = process.env.GOOGLE_AI_API_KEY;\n                if (!apiKey) throw new Error(\"Missing Google AI API Key\");\n                // Dynamically import to avoid load-time errors\n                const { GoogleGenerativeAI } = __webpack_require__(/*! @google/generative-ai */ \"(rsc)/./node_modules/@google/generative-ai/dist/index.js\");\n                const genAI = new GoogleGenerativeAI(apiKey);\n                const model = genAI.getGenerativeModel({\n                    model: \"gemini-2.5-flash\"\n                });\n                const prompt = `Analyze this TikTok video topic for a Turkish audience: \"${input.input}\".\n            Generate a JSON object with high-performing Turkish hashtags.\n            Format: { \n              \"broad\": [\"#tag1\", \"#tag2\", ...], // 6-8 Popular/General tags (mostly Turkish)\n              \"niche\": [\"#tag3\", \"#tag4\", ...], // 6-8 Specific/Niche tags (mostly Turkish)\n              \"viralityScore\": 85, // 0-100 score based on trend potential\n              \"bestTime\": \"19:00\" // Best time to post in Turkey (HH:MM)\n            }. \n            Only return the JSON.`;\n                const result = await model.generateContent(prompt);\n                const response = await result.response;\n                const text = response.text();\n                // Clean markdown helpers if present\n                const cleanJson = text.replace(/```json|```/g, \"\").trim();\n                resultData = JSON.parse(cleanJson);\n            } catch (error) {\n                console.error(\"Gemini Error:\", error.message);\n                // Fallback if API fails for ANY reason (network, key, region, parsing)\n                resultData = {\n                    broad: [\n                        \"#fyp\",\n                        \"#kesfet\",\n                        \"#tiktok\"\n                    ],\n                    niche: [\n                        `#${input.input.replace(/\\s/g, \"\")}`,\n                        \"#trend\"\n                    ],\n                    viralityScore: 70,\n                    bestTime: \"20:00\",\n                    error: error.message // Optional: return error to UI for debugging\n                };\n            }\n        } else if (input.tool === \"VALUATION\") {\n            try {\n                // Real Data via TikAPI\n                const apiKey = process.env.TIK_API_KEY;\n                if (!apiKey) throw new Error(\"Missing TikAPI Key (TIK_API_KEY)\");\n                // 1. Fetch User Info (for Follower Count)\n                const userRes = await fetch(`https://api.tikapi.io/public/check?username=${input.input}`, {\n                    headers: {\n                        \"X-API-KEY\": apiKey\n                    }\n                });\n                if (!userRes.ok) throw new Error(`TikAPI Check Error: ${userRes.statusText}`);\n                const userData = await userRes.json();\n                const userInfo = userData.userInfo;\n                if (!userInfo) throw new Error(\"User not found\");\n                const followers = userInfo.stats?.followerCount || 0;\n                // 2. Fetch User Posts (for Views/Engagement) - Recent Batch\n                // TikAPI public/posts requires 'secUid' for reliability.\n                const secUid = userInfo.user?.secUid;\n                if (!secUid) {\n                    console.warn(\"No secUid found, trying username fallback but likely to fail if API demands secUid\");\n                }\n                // Construct query - prefer secUid\n                const queryParam = secUid ? `secUid=${encodeURIComponent(secUid)}` : `username=${encodeURIComponent(userInfo.user?.uniqueId || input.input)}`;\n                const postsRes = await fetch(`https://api.tikapi.io/public/posts?${queryParam}`, {\n                    headers: {\n                        \"X-API-KEY\": apiKey\n                    }\n                });\n                if (!postsRes.ok) {\n                    // If bad request, log more details if possible (TikAPI errors are sometimes in body)\n                    const errText = await postsRes.text();\n                    console.error(\"TikAPI Posts Error details:\", errText);\n                    throw new Error(`TikAPI Posts Error: ${postsRes.status} ${postsRes.statusText}`);\n                }\n                const postsData = await postsRes.json();\n                const posts = postsData.itemList || [];\n                // Filter Last 10 Days\n                const now = new Date();\n                const tenDaysAgo = new Date(now.getTime() - 10 * 24 * 60 * 60 * 1000);\n                const recentPosts = posts.filter((p)=>new Date(p.createTime * 1000) > tenDaysAgo);\n                let avgViews = 0;\n                let safeEr = 0;\n                if (recentPosts.length > 0) {\n                    const totalViews = recentPosts.reduce((acc, p)=>acc + (p.stats?.playCount || 0), 0);\n                    const totalLikes = recentPosts.reduce((acc, p)=>acc + (p.stats?.diggCount || 0), 0);\n                    const totalComments = recentPosts.reduce((acc, p)=>acc + (p.stats?.commentCount || 0), 0);\n                    const totalShares = recentPosts.reduce((acc, p)=>acc + (p.stats?.shareCount || 0), 0);\n                    // Weighted Engagement: Likes(1) + Comments(2) + Shares(3)\n                    const weightedEngagements = totalLikes + totalComments * 2 + totalShares * 3;\n                    avgViews = Math.floor(totalViews / recentPosts.length);\n                    // Real ER Calculation (No Floor)\n                    const realEr = totalViews > 0 ? weightedEngagements / totalViews * 100 : 0;\n                    // No floor minimum of 10%\n                    safeEr = Math.min(realEr, 100);\n                } else {\n                    // Fallback if no posts in last 10 days: Use last 3 posts generally\n                    if (posts.length > 0) {\n                        const last3 = posts.slice(0, 3);\n                        const totalViews = last3.reduce((acc, p)=>acc + (p.stats?.playCount || 0), 0);\n                        const totalLikes = last3.reduce((acc, p)=>acc + (p.stats?.diggCount || 0), 0);\n                        const totalComments = last3.reduce((acc, p)=>acc + (p.stats?.commentCount || 0), 0);\n                        const totalShares = last3.reduce((acc, p)=>acc + (p.stats?.shareCount || 0), 0);\n                        const weightedEngagements = totalLikes + totalComments * 2 + totalShares * 3;\n                        avgViews = Math.floor(totalViews / last3.length);\n                        const realEr = totalViews > 0 ? weightedEngagements / totalViews * 100 : 0;\n                        safeEr = Math.min(realEr, 100);\n                    } else {\n                        avgViews = 0; // Truly inactive account\n                        safeEr = 0;\n                    }\n                }\n                // Dynamic CPM Algorithm\n                let cpm = 20; // Base 20 TL\n                let erMultiplier = 1;\n                if (safeEr >= 10) {\n                    erMultiplier = 1.25; // Base boost (+25%) for hitting 10%\n                    const excessEr = safeEr - 10;\n                    if (excessEr > 0) {\n                        // +2% boost for each %1 ER above 10\n                        erMultiplier += excessEr * 0.02;\n                    }\n                }\n                cpm *= erMultiplier;\n                if (followers > 50000) cpm *= 1.1;\n                const estimatedPrice = avgViews / 1000 * cpm;\n                resultData = {\n                    username: userInfo.user?.uniqueId || input.input,\n                    pricePerPost: estimatedPrice,\n                    engagementRate: safeEr.toFixed(2),\n                    avgViews: avgViews,\n                    followers: followers,\n                    cpmdUsed: cpm\n                };\n            } catch (error) {\n                console.error(\"TikAPI Valuation Error:\", error.message);\n                throw new Error(\"Analiz sırasında bir hata oluştu: \" + error.message);\n            }\n        } else if (input.tool === \"PROFILE\") {\n            try {\n                const apiKey = process.env.TIK_API_KEY;\n                if (!apiKey) throw new Error(\"Missing TikAPI Key\");\n                // 1. Check User\n                const userRes = await fetch(`https://api.tikapi.io/public/check?username=${input.input}`, {\n                    headers: {\n                        \"X-API-KEY\": apiKey\n                    }\n                });\n                if (!userRes.ok) throw new Error(\"User Check Failed\");\n                const userData = await userRes.json();\n                const userInfo = userData.userInfo;\n                if (!userInfo) throw new Error(\"User not found\");\n                // 2. Fetch Posts\n                const secUid = userInfo.user?.secUid;\n                const target = secUid ? `secUid=${encodeURIComponent(secUid)}` : `username=${encodeURIComponent(userInfo.user?.uniqueId || input.input)}`;\n                const postsRes = await fetch(`https://api.tikapi.io/public/posts?${target}&count=15`, {\n                    headers: {\n                        \"X-API-KEY\": apiKey\n                    }\n                }); // Fetch a few more to ensure we get 10 valid\n                if (!postsRes.ok) throw new Error(\"Posts Fetch Failed\");\n                const postsData = await postsRes.json();\n                const allPosts = postsData.itemList || [];\n                // 3. Analyze Last 10 Videos\n                const last10 = allPosts.slice(0, 10);\n                if (last10.length === 0) throw new Error(\"No recent videos found to analyze.\");\n                const analyzedVideos = last10.map((p)=>{\n                    const views = p.stats?.playCount || 0;\n                    const likes = p.stats?.diggCount || 0;\n                    const comments = p.stats?.commentCount || 0;\n                    const shares = p.stats?.shareCount || 0;\n                    // Weighted ER: ((Likes + Comments*2 + Shares*3) / Views) * 100\n                    const weightedEng = likes + comments * 2 + shares * 3;\n                    const er = views > 0 ? weightedEng / views * 100 : 0;\n                    return {\n                        id: p.id,\n                        desc: p.desc || \"\",\n                        cover: p.video?.cover || \"\",\n                        createTime: p.createTime,\n                        stats: {\n                            views,\n                            likes,\n                            comments,\n                            shares,\n                            er\n                        }\n                    };\n                });\n                // 4. Averages\n                const avgStats = {\n                    views: Math.floor(analyzedVideos.reduce((acc, v)=>acc + v.stats.views, 0) / analyzedVideos.length),\n                    likes: Math.floor(analyzedVideos.reduce((acc, v)=>acc + v.stats.likes, 0) / analyzedVideos.length),\n                    comments: Math.floor(analyzedVideos.reduce((acc, v)=>acc + v.stats.comments, 0) / analyzedVideos.length),\n                    shares: Math.floor(analyzedVideos.reduce((acc, v)=>acc + v.stats.shares, 0) / analyzedVideos.length),\n                    er: parseFloat((analyzedVideos.reduce((acc, v)=>acc + v.stats.er, 0) / analyzedVideos.length).toFixed(2))\n                };\n                // 5. Consistency Score (Based on Variance of Gaps between posts)\n                // If gaps are uniform, consistency is high.\n                let consistencyScore = 50;\n                if (analyzedVideos.length > 1) {\n                    const gaps = [];\n                    for(let i = 0; i < analyzedVideos.length - 1; i++){\n                        const gapHrs = Math.abs(analyzedVideos[i].createTime - analyzedVideos[i + 1].createTime) / 3600;\n                        gaps.push(gapHrs);\n                    }\n                    // Calculate Coefficient of Variation (CV) = StdDev / Mean\n                    const meanGap = gaps.reduce((a, b)=>a + b, 0) / gaps.length;\n                    const variance = gaps.reduce((a, b)=>a + Math.pow(b - meanGap, 2), 0) / gaps.length;\n                    const stdDev = Math.sqrt(variance);\n                    const cv = stdDev / (meanGap || 1);\n                    // Lower CV is better. If CV < 0.2 -> Excellent (100). If CV > 1.5 -> Bad (20).\n                    // Map 0.2...1.5 to 100...20 roughly.\n                    consistencyScore = Math.max(20, Math.min(100, 100 - cv * 50));\n                    // Penalty for inactivity: If mean gap > 7 days (168 hrs), reduce score.\n                    if (meanGap > 168) consistencyScore *= 0.7;\n                }\n                // 6. Community Health (Interaction Ratios)\n                // Comments/Likes ratio: 0.5% is good. Shares/Likes ratio: 10% is viral.\n                const commentRatio = avgStats.likes > 0 ? avgStats.comments / avgStats.likes * 100 : 0;\n                const shareRatio = avgStats.likes > 0 ? avgStats.shares / avgStats.likes * 100 : 0;\n                let communityScore = 50; // Base\n                if (commentRatio > 0.5) communityScore += 20; // Good talkative audience\n                if (commentRatio > 1.5) communityScore += 10;\n                if (shareRatio > 5) communityScore += 15; // High sharability\n                if (shareRatio > 10) communityScore += 15; // Very Viral\n                communityScore = Math.min(100, communityScore);\n                resultData = {\n                    user: {\n                        username: userInfo.user.uniqueId,\n                        nickname: userInfo.user.nickname,\n                        avatar: userInfo.user.avatarThumb,\n                        followers: userInfo.stats.followerCount\n                    },\n                    averages: avgStats,\n                    videos: analyzedVideos,\n                    scores: {\n                        consistency: Math.round(consistencyScore),\n                        community: Math.round(communityScore)\n                    }\n                };\n            } catch (error) {\n                console.error(\"Profile Analysis Error:\", error.message);\n                throw new Error(\"Analiz Başarısız: \" + error.message);\n            }\n        } else if (input.tool === \"AUDIT\") {\n            try {\n                const apiKey = process.env.TIK_API_KEY;\n                if (!apiKey) throw new Error(\"Missing TikAPI Key\");\n                // Extract Video ID from Link\n                let videoId = input.input;\n                if (input.input.includes(\"tiktok.com\")) {\n                    const match = input.input.match(/\\/video\\/(\\d+)/);\n                    if (match) videoId = match[1];\n                }\n                // Fetch Video Details\n                const vidRes = await fetch(`https://api.tikapi.io/public/video?id=${videoId}`, {\n                    headers: {\n                        \"X-API-KEY\": apiKey\n                    }\n                });\n                if (!vidRes.ok) throw new Error(\"Video not found or API error\");\n                const vidData = await vidRes.json();\n                const video = vidData.itemInfo?.itemStruct;\n                if (!video) throw new Error(\"Video data is empty\");\n                // Calculate Stats\n                const stats = video.stats;\n                const views = stats.playCount || 1;\n                const likes = stats.diggCount || 0;\n                const comments = stats.commentCount || 0;\n                const shares = stats.shareCount || 0;\n                const saves = stats.collectCount || 0;\n                const downloads = stats.downloadCount || 0;\n                // User Formula: (likes*2 + comments*3 + shares*4)\n                const weightedEngagement = likes * 2 + comments * 3 + shares * 4;\n                // Percentage\n                const customEr = weightedEngagement / views * 100;\n                // Calculate Virality Score (0-100)\n                const erScore = Math.min(customEr / 25 * 100, 100);\n                const viewScore = Math.min(views / 100000 * 100, 100);\n                const viralityScore = Math.round(erScore * 0.7 + viewScore * 0.3);\n                // Assign Grade\n                let grade = \"C\";\n                if (viralityScore >= 90) grade = \"S\";\n                else if (viralityScore >= 75) grade = \"A\";\n                else if (viralityScore >= 50) grade = \"B\";\n                else if (viralityScore < 30) grade = \"F\";\n                resultData = {\n                    video: {\n                        id: video.id,\n                        desc: video.desc,\n                        cover: video.video?.cover,\n                        author: video.author?.uniqueId,\n                        authorAvatar: video.author?.avatarLarger,\n                        createTime: video.createTime,\n                        duration: video.video?.duration\n                    },\n                    stats: {\n                        views,\n                        likes,\n                        comments,\n                        shares,\n                        saves,\n                        downloads,\n                        er: customEr.toFixed(1)\n                    },\n                    scores: {\n                        virality: viralityScore,\n                        grade,\n                        customEr: customEr.toFixed(1),\n                        aiAnalysis: \"Analiz hazırlanıyor...\" // Placeholder\n                    }\n                };\n                // Generate AI Analysis\n                // Generate AI Analysis\n                try {\n                    const apiKey = process.env.GOOGLE_AI_API_KEY;\n                    if (!apiKey) {\n                        console.warn(\"GOOGLE_AI_API_KEY is missing/empty.\");\n                        resultData.scores.aiAnalysis = \"API anahtarı eksik, analiz yapılamadı.\";\n                    } else {\n                        const genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_2__.GoogleGenerativeAI(apiKey);\n                        const model = genAI.getGenerativeModel({\n                            model: \"gemini-2.5-flash\"\n                        });\n                        const prompt = `\n                Role: TikTok Koçu\n                Görev: Bu video için 2 cümlelik analiz yap.\n                Veriler: Not: ${grade}, Etkileşim: %${customEr.toFixed(1)}\n                \n                Format (Sadece 2 cümle):\n                1. Cümle: Videonun neden bu notu aldığını açıkla (etkileşim/izlenme dengesi).\n                2. Cümle: Daha iyi olması için net bir taktik ver.\n\n                Kurallar:\n                - Rakam kullanma.\n                - Basit ve net ol.\n                - \"Bu notu aldı çünkü...\" deme, direkt analizi söyle.\n                `;\n                        const result = await model.generateContent(prompt);\n                        const response = await result.response;\n                        const text = response.text();\n                        if (text) resultData.scores.aiAnalysis = text.trim();\n                    }\n                } catch (aiError) {\n                    console.error(\"AI Gen Error:\", aiError);\n                    resultData.scores.aiAnalysis = `${grade} notu aldın. Etkileşim oranlarını artırmaya odaklanmalısın. (AI Hatası)`;\n                }\n            } catch (error) {\n                console.error(\"AUDIT Tool Error:\", error);\n                throw new Error(error.message || \"Video analysis failed\");\n            }\n        } else if (input.tool === \"COMPARE\") {\n            try {\n                const apiKey = process.env.TIK_API_KEY;\n                if (!apiKey) throw new Error(\"Missing TikAPI Key\");\n                // Helper function to analyze a user\n                const analyzeUser = async (username)=>{\n                    // 1. Check User to get stats and secUid\n                    const userRes = await fetch(`https://api.tikapi.io/public/check?username=${encodeURIComponent(username.trim())}`, {\n                        headers: {\n                            \"X-API-KEY\": apiKey\n                        }\n                    });\n                    if (!userRes.ok) throw new Error(`User ${username} check failed`);\n                    const userData = await userRes.json();\n                    const userInfo = userData.userInfo;\n                    if (!userInfo) throw new Error(`User ${username} not found`);\n                    // 2. Fetch Last 10 Posts\n                    const target = userInfo.user?.secUid ? `secUid=${encodeURIComponent(userInfo.user.secUid)}` : `username=${encodeURIComponent(userInfo.user.uniqueId)}`;\n                    const postsRes = await fetch(`https://api.tikapi.io/public/posts?${target}&count=15`, {\n                        headers: {\n                            \"X-API-KEY\": apiKey\n                        }\n                    });\n                    const postsData = await postsRes.json();\n                    const allPosts = postsData.itemList || [];\n                    const last10 = allPosts.slice(0, 10);\n                    // 3. Calc Metrics\n                    // Basic Profile Stats\n                    const followers = userInfo.stats?.followerCount || 0;\n                    const totalLikes = userInfo.stats?.heartCount || 0; // Lifetime likes usually in stats\n                    let avgViews = 0;\n                    let safeEr = 0;\n                    let consistencyScore = 50;\n                    let communityScore = 50;\n                    if (last10.length > 0) {\n                        // Avg Views + ER\n                        const totalViews = last10.reduce((acc, p)=>acc + (p.stats?.playCount || 0), 0);\n                        avgViews = Math.floor(totalViews / last10.length);\n                        const totalWeightedEng = last10.reduce((acc, p)=>{\n                            return acc + (p.stats?.diggCount || 0) + (p.stats?.commentCount || 0) * 2 + (p.stats?.shareCount || 0) * 3;\n                        }, 0);\n                        safeEr = totalViews > 0 ? totalWeightedEng / totalViews * 100 : 0;\n                        safeEr = Math.min(safeEr, 100);\n                        // Consistency\n                        if (last10.length > 1) {\n                            const gaps = [];\n                            for(let i = 0; i < last10.length - 1; i++){\n                                const gapHrs = Math.abs(last10[i].createTime - last10[i + 1].createTime) / 3600;\n                                gaps.push(gapHrs);\n                            }\n                            const meanGap = gaps.reduce((a, b)=>a + b, 0) / gaps.length;\n                            const variance = gaps.reduce((a, b)=>a + Math.pow(b - meanGap, 2), 0) / gaps.length;\n                            const cv = Math.sqrt(variance) / (meanGap || 1);\n                            consistencyScore = Math.max(20, Math.min(100, 100 - cv * 50));\n                            if (meanGap > 168) consistencyScore *= 0.7; // Inactive penalty\n                        }\n                        // Community (Aggregate of last 10)\n                        const aggLikes = last10.reduce((acc, p)=>acc + (p.stats?.diggCount || 0), 0);\n                        const aggComments = last10.reduce((acc, p)=>acc + (p.stats?.commentCount || 0), 0);\n                        const aggShares = last10.reduce((acc, p)=>acc + (p.stats?.shareCount || 0), 0);\n                        const commentRatio = aggLikes > 0 ? aggComments / aggLikes * 100 : 0;\n                        const shareRatio = aggLikes > 0 ? aggShares / aggLikes * 100 : 0;\n                        if (commentRatio > 0.5) communityScore += 20;\n                        if (commentRatio > 1.5) communityScore += 10;\n                        if (shareRatio > 5) communityScore += 15;\n                        if (shareRatio > 10) communityScore += 15;\n                        communityScore = Math.min(100, communityScore);\n                    }\n                    return {\n                        username: userInfo.user.uniqueId,\n                        nickname: userInfo.user.nickname,\n                        avatar: userInfo.user.avatarThumb,\n                        stats: {\n                            followers,\n                            totalLikes,\n                            avgViews,\n                            er: parseFloat(safeEr.toFixed(2)),\n                            consistency: Math.round(consistencyScore),\n                            community: Math.round(communityScore)\n                        }\n                    };\n                };\n                // Parse Input \"user1,user2\"\n                const [user1Arg, user2Arg] = input.input.split(\",\").map((s)=>s.trim());\n                if (!user1Arg || !user2Arg) throw new Error(\"Please enter two usernames separated by comma.\");\n                // Run Parallel\n                const [user1Data, user2Data] = await Promise.all([\n                    analyzeUser(user1Arg),\n                    analyzeUser(user2Arg)\n                ]);\n                resultData = {\n                    user1: user1Data,\n                    user2: user2Data\n                };\n            } catch (error) {\n                console.error(\"Comparison Error:\", error.message);\n                throw new Error(\"Karşılaştırma Başarısız: \" + error.message);\n            }\n        }\n        // Deduct Coupon and Save History\n        await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.$transaction([\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.update({\n                where: {\n                    id: userId\n                },\n                data: {\n                    couponBalance: {\n                        decrement: 1\n                    }\n                }\n            }),\n            _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.marketplaceUsage.create({\n                data: {\n                    userId,\n                    toolType: input.tool,\n                    input: input.input,\n                    resultSnapshot: resultData\n                }\n            })\n        ]);\n        return {\n            success: true,\n            result: resultData\n        };\n    }),\n    getMarketplaceHistory: t.procedure.query(async ({ ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        return await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.marketplaceUsage.findMany({\n            where: {\n                userId\n            },\n            orderBy: {\n                createdAt: \"desc\"\n            }\n        });\n    }),\n    completeCampaign: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        campaignId: zod__WEBPACK_IMPORTED_MODULE_6__.string()\n    })).mutation(async ({ input, ctx })=>{\n        // 1. Authorization\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findUnique({\n            where: {\n                id: input.campaignId\n            },\n            include: {\n                submissions: {\n                    where: {\n                        status: {\n                            not: \"REJECTED\"\n                        }\n                    }\n                }\n            }\n        });\n        if (!campaign) throw new Error(\"CAMPAIGN_NOT_FOUND\");\n        if (campaign.artistId !== userId && ctx.user?.role !== \"ADMIN\") throw new Error(\"FORBIDDEN\");\n        if (campaign.status === \"COMPLETED\") throw new Error(\"CAMPAIGN_ALREADY_COMPLETED\");\n        // 2. Refresh Metrics (outside transaction - can fail gracefully)\n        const { tiktokScraper } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/tiktok-scraper */ \"(rsc)/./lib/tiktok-scraper.ts\"));\n        const submissions = campaign.submissions;\n        const CHUNK_SIZE = 5;\n        const refreshedMetrics = [];\n        for(let i = 0; i < submissions.length; i += CHUNK_SIZE){\n            const chunk = submissions.slice(i, i + CHUNK_SIZE);\n            await Promise.all(chunk.map(async (sub)=>{\n                try {\n                    if (sub.tiktokUrl) {\n                        const videoData = await tiktokScraper.verifyVideo(sub.tiktokUrl);\n                        refreshedMetrics.push({\n                            id: sub.id,\n                            views: videoData.views,\n                            likes: videoData.likes,\n                            comments: videoData.comments,\n                            shares: videoData.shares\n                        });\n                    }\n                } catch (e) {\n                    console.error(`Failed to refresh submission ${sub.id}:`, e);\n                    // Use old metrics if refresh fails\n                    refreshedMetrics.push({\n                        id: sub.id,\n                        views: sub.lastViewCount || 0,\n                        likes: sub.lastLikeCount || 0,\n                        comments: sub.lastCommentCount || 0,\n                        shares: sub.lastShareCount || 0\n                    });\n                }\n            }));\n        }\n        // 3. ALL calculations and payouts in ONE atomic transaction\n        const { CalculationService } = await __webpack_require__.e(/*! import() */ \"_rsc_server_services_calculationService_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/server/services/calculationService */ \"(rsc)/./server/services/calculationService.ts\"));\n        await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.$transaction(async (tx)=>{\n            // 3a. Update metrics and calculate points for all submissions\n            for (const metrics of refreshedMetrics){\n                const points = CalculationService.calculatePoints(metrics.views, metrics.likes, metrics.shares);\n                await tx.submission.update({\n                    where: {\n                        id: metrics.id\n                    },\n                    data: {\n                        lastViewCount: metrics.views,\n                        lastLikeCount: metrics.likes,\n                        lastCommentCount: metrics.comments,\n                        lastShareCount: metrics.shares,\n                        lastCheckedAt: new Date(),\n                        viewPoints: points.viewPoints,\n                        likePoints: points.likePoints,\n                        sharePoints: points.sharePoints,\n                        totalPoints: points.totalPoints\n                    }\n                });\n            }\n            // 3b. Recalculate campaign totals and distribution (with Robin Hood cap)\n            await CalculationService.updateCampaignTotalPoints(input.campaignId, _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma, tx);\n            await CalculationService.recalculateCampaignSubmissions(input.campaignId, _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma, tx);\n            // 3c. Distribute payouts to creators\n            const finalSubmissions = await tx.submission.findMany({\n                where: {\n                    campaignId: input.campaignId,\n                    status: \"APPROVED\",\n                    totalEarnings: {\n                        gt: 0\n                    }\n                },\n                select: {\n                    id: true,\n                    creatorId: true,\n                    totalEarnings: true\n                }\n            });\n            for (const sub of finalSubmissions){\n                const earningsTL = Number(sub.totalEarnings);\n                if (earningsTL > 0) {\n                    // Update creator balance\n                    await tx.user.update({\n                        where: {\n                            id: sub.creatorId\n                        },\n                        data: {\n                            balance: {\n                                increment: earningsTL\n                            }\n                        }\n                    });\n                    // Create earnings transaction record\n                    await tx.transaction.create({\n                        data: {\n                            userId: sub.creatorId,\n                            type: \"EARNING\",\n                            amount: earningsTL,\n                            status: \"COMPLETED\",\n                            description: `Kampanya Kazancı: ${campaign.title}`,\n                            reference: sub.id\n                        }\n                    });\n                }\n            }\n            // 3d. Mark campaign as completed\n            await tx.campaign.update({\n                where: {\n                    id: input.campaignId\n                },\n                data: {\n                    status: \"COMPLETED\",\n                    completedAt: new Date()\n                }\n            });\n        }, {\n            timeout: 60000 // 60 second timeout for large campaigns\n        });\n        return {\n            success: true\n        };\n    }),\n    rejectCampaign: t.procedure.input(zod__WEBPACK_IMPORTED_MODULE_6__.object({\n        campaignId: zod__WEBPACK_IMPORTED_MODULE_6__.string(),\n        reason: zod__WEBPACK_IMPORTED_MODULE_6__.string().optional()\n    })).mutation(async ({ input, ctx })=>{\n        const userId = ctx.user?.id;\n        if (!userId) throw new Error(\"UNAUTHORIZED\");\n        const admin = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.user.findUnique({\n            where: {\n                id: userId\n            }\n        });\n        if (admin?.role !== \"ADMIN\") throw new Error(\"FORBIDDEN\");\n        const campaign = await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.campaign.findUnique({\n            where: {\n                id: input.campaignId\n            }\n        });\n        if (!campaign) throw new Error(\"CAMPAIGN_NOT_FOUND\");\n        const refundAmountTL = Number(campaign.totalBudget);\n        // Refund & Reject\n        await _lib_prisma__WEBPACK_IMPORTED_MODULE_1__.prisma.$transaction(async (tx)=>{\n            await tx.campaign.update({\n                where: {\n                    id: input.campaignId\n                },\n                data: {\n                    status: \"REJECTED\"\n                }\n            });\n            await tx.user.update({\n                where: {\n                    id: campaign.artistId\n                },\n                data: {\n                    balance: {\n                        increment: refundAmountTL\n                    }\n                }\n            });\n            await tx.transaction.create({\n                data: {\n                    userId: campaign.artistId,\n                    type: \"DEPOSIT\",\n                    amount: refundAmountTL,\n                    status: \"COMPLETED\",\n                    description: `Kampanya İadesi: ${campaign.title} (${input.reason || \"Admin Reddi\"})`\n                }\n            });\n        });\n        return {\n            success: true\n        };\n    })\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUEsR0FBRzFNLFFBQVEsQ0FBQ3RCLE1BQU0sQ0FBQztnQkFDdkJ4QyxPQUFPO29CQUFFQyxJQUFJUCxNQUFNbUksVUFBVTtnQkFBQztnQkFDOUJwRixNQUFNO29CQUFFVyxRQUFRO2dCQUFXO1lBQzdCO1lBRUEsTUFBTW9OLEdBQUcxUSxJQUFJLENBQUMwQyxNQUFNLENBQUM7Z0JBQ25CeEMsT0FBTztvQkFBRUMsSUFBSTZELFNBQVNxRCxRQUFRO2dCQUFDO2dCQUMvQjFFLE1BQU07b0JBQUVuQyxTQUFTO3dCQUFFc1MsV0FBV3lKO29CQUFlO2dCQUFFO1lBQ2pEO1lBRUEsTUFBTTdMLEdBQUdHLFdBQVcsQ0FBQ3pSLE1BQU0sQ0FBQztnQkFDMUJ1RCxNQUFNO29CQUNKN0MsUUFBUWtFLFNBQVNxRCxRQUFRO29CQUN6QnlKLE1BQU07b0JBQ05DLFFBQVF3TDtvQkFDUmpaLFFBQVE7b0JBQ1J3TSxhQUFhLENBQUMsaUJBQWlCLEVBQUU5TCxTQUFTTixLQUFLLENBQUMsRUFBRSxFQUFFOUQsTUFBTXljLE1BQU0sSUFBSSxjQUFjLENBQUMsQ0FBQztnQkFDdEY7WUFDRjtRQUNGO1FBRUEsT0FBTztZQUFFL00sU0FBUztRQUFLO0lBQ3pCO0FBQ0osR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL3Nlc2FyLXdlYi8uL3NlcnZlci9yb3V0ZXJzL19hcHAudHM/ZGRiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbml0VFJQQyB9IGZyb20gXCJAdHJwYy9zZXJ2ZXJcIjtcbmltcG9ydCBzdXBlcmpzb24gZnJvbSBcInN1cGVyanNvblwiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7IHByaXNtYSB9IGZyb20gXCJAL2xpYi9wcmlzbWFcIjtcbmltcG9ydCB7IEdvb2dsZUdlbmVyYXRpdmVBSSB9IGZyb20gXCJAZ29vZ2xlL2dlbmVyYXRpdmUtYWlcIjtcbmltcG9ydCB7IENvbnRleHQgfSBmcm9tIFwiLi4vY29udGV4dFwiO1xuaW1wb3J0IHsgdGlrdG9rU2NyYXBlciB9IGZyb20gXCJAL2xpYi90aWt0b2stc2NyYXBlclwiO1xuaW1wb3J0IHsgZ2V0Q3JlYXRvclRpZXJGcm9tRm9sbG93ZXJzLCBpc0NyZWF0b3JFbGlnaWJsZUZvckNhbXBhaWduIH0gZnJvbSBcIi4uL2xpYi90aWVyVXRpbHNcIjtcblxuLy8gTWluaW1hbCB0UlBDIHNldHVwIGZvciB0eXBlIGNvbXBhdGliaWxpdHlcbi8vIFRoaXMgYXBwIHVzZXMgUkVTVCBBUEkgcm91dGVzLCBidXQgdFJQQyB0eXBlcyBhcmUgaW1wb3J0ZWQgZm9yIGNvbXBhdGliaWxpdHlcbmNvbnN0IHQgPSBpbml0VFJQQy5jb250ZXh0PENvbnRleHQ+KCkuY3JlYXRlKHtcbiAgdHJhbnNmb3JtZXI6IHN1cGVyanNvbixcbn0pO1xuXG5leHBvcnQgY29uc3QgYXBwUm91dGVyID0gdC5yb3V0ZXIoe1xuICBoZWFsdGg6IHQucHJvY2VkdXJlLnF1ZXJ5KCgpID0+IHtcbiAgICByZXR1cm4gXCJPSyBmcm9tIHRSUEMhXCI7XG4gIH0pLFxuICBnZXRVc2VyOiB0LnByb2NlZHVyZVxuICAgIC5pbnB1dCh6Lm9iamVjdCh7IHVzZXJJZDogei5zdHJpbmcoKSB9KSlcbiAgICAucXVlcnkoYXN5bmMgKHsgaW5wdXQgfSkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW5wdXQudXNlcklkIH0sXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIG5hbWU6IHRydWUsXG4gICAgICAgICAgZW1haWw6IHRydWUsXG4gICAgICAgICAgcm9sZTogdHJ1ZSxcbiAgICAgICAgICBiYWxhbmNlOiB0cnVlLFxuICAgICAgICAgIGF2YXRhcjogdHJ1ZSxcbiAgICAgICAgICB0aWt0b2tIYW5kbGU6IHRydWUsXG4gICAgICAgICAgY291cG9uQmFsYW5jZTogdHJ1ZSxcbiAgICAgICAgICBwbGFuOiB0cnVlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvbkVuZHNBdDogdHJ1ZSxcbiAgICAgICAgICBjeWNsZVN0YXJ0RGF0ZTogdHJ1ZSxcbiAgICAgICAgICB0b3RhbExpa2VzOiB0cnVlLFxuICAgICAgICAgIHZpZGVvQ291bnQ6IHRydWUsXG4gICAgICAgICAgZm9sbG93aW5nQ291bnQ6IHRydWUsXG4gICAgICAgICAgZm9sbG93ZXJDb3VudDogdHJ1ZSxcbiAgICAgICAgICBjcmVhdG9yVGllcjogdHJ1ZSxcbiAgICAgICAgICBsYXN0U3RhdHNGZXRjaGVkQXQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9KSxcblxuICB1cGRhdGVQcm9maWxlOiB0LnByb2NlZHVyZVxuICAgIC5pbnB1dCh6Lm9iamVjdCh7XG4gICAgICB0aWt0b2tIYW5kbGU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KSlcbiAgICAubXV0YXRpb24oYXN5bmMgKHsgaW5wdXQsIGN0eCB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBjdHgudXNlcj8uaWQ7XG4gICAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJhdGUgbGltaXRpbmc6IENoZWNrIGlmIHVwZGF0ZWQgcmVjZW50bHkgKGUuZy4gMTAgbWlucylcbiAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgcHJpc21hLnVzZXIuZmluZFVuaXF1ZSh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgICAgc2VsZWN0OiB7IGxhc3RTdGF0c0ZldGNoZWRBdDogdHJ1ZSwgdGlrdG9rSGFuZGxlOiB0cnVlIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB1c2VyIGlzIGp1c3QgcmVmcmVzaGluZyAobm8gbmV3IGhhbmRsZSkgYW5kIHVwZGF0ZWQgcmVjZW50bHlcbiAgICAgIGlmICghaW5wdXQudGlrdG9rSGFuZGxlICYmIGN1cnJlbnRVc2VyPy5sYXN0U3RhdHNGZXRjaGVkQXQpIHtcbiAgICAgICAgY29uc3QgdGltZURpZmYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGN1cnJlbnRVc2VyLmxhc3RTdGF0c0ZldGNoZWRBdCkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBtaW51dGVzRGlmZiA9IHRpbWVEaWZmIC8gKDEwMDAgKiA2MCk7XG5cbiAgICAgICAgaWYgKG1pbnV0ZXNEaWZmIDwgMTApIHtcbiAgICAgICAgICAvLyBSZXR1cm4gZXhpc3RpbmcgdXNlciB3aXRob3V0IHVwZGF0ZSBpZiB3aXRoaW4gbGltaXRcbiAgICAgICAgICByZXR1cm4gcHJpc21hLnVzZXIuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiB1c2VySWQgfSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgdXBkYXRlRGF0YTogYW55ID0ge1xuICAgICAgICB0aWt0b2tIYW5kbGU6IGlucHV0LnRpa3Rva0hhbmRsZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRvQ2hlY2sgPSBpbnB1dC50aWt0b2tIYW5kbGUgfHwgY3VycmVudFVzZXI/LnRpa3Rva0hhbmRsZTtcblxuICAgICAgaWYgKHRvQ2hlY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHRpa3Rva1NjcmFwZXIgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL3Rpa3Rvay1zY3JhcGVyXCIpO1xuICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCB0aWt0b2tTY3JhcGVyLmNoZWNrVXNlclByb2ZpbGUodG9DaGVjayk7XG5cbiAgICAgICAgICBpZiAocHJvZmlsZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICBpZiAocHJvZmlsZS5hdmF0YXIpIHVwZGF0ZURhdGEuYXZhdGFyID0gcHJvZmlsZS5hdmF0YXI7XG4gICAgICAgICAgICB1cGRhdGVEYXRhLnRpa3Rva0hhbmRsZSA9IHByb2ZpbGUudW5pcXVlSWQ7XG4gICAgICAgICAgICB1cGRhdGVEYXRhLm5hbWUgPSBwcm9maWxlLnVuaXF1ZUlkOyAvLyBPciBrZWVwIGV4aXN0aW5nIG5hbWU/IGNvbnRlbnQgY3JlYXRvciBuYW1lIG1pZ2h0IGJlIGJldHRlclxuXG4gICAgICAgICAgICAvLyBTdGF0cyBVcGRhdGVcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmZvbGxvd2VyQ291bnQgIT09IHVuZGVmaW5lZCkgdXBkYXRlRGF0YS5mb2xsb3dlckNvdW50ID0gcHJvZmlsZS5mb2xsb3dlckNvdW50O1xuICAgICAgICAgICAgaWYgKHByb2ZpbGUuZm9sbG93aW5nQ291bnQgIT09IHVuZGVmaW5lZCkgdXBkYXRlRGF0YS5mb2xsb3dpbmdDb3VudCA9IHByb2ZpbGUuZm9sbG93aW5nQ291bnQ7XG4gICAgICAgICAgICBpZiAocHJvZmlsZS5oZWFydENvdW50ICE9PSB1bmRlZmluZWQpIHVwZGF0ZURhdGEudG90YWxMaWtlcyA9IHByb2ZpbGUuaGVhcnRDb3VudDtcbiAgICAgICAgICAgIGlmIChwcm9maWxlLnZpZGVvQ291bnQgIT09IHVuZGVmaW5lZCkgdXBkYXRlRGF0YS52aWRlb0NvdW50ID0gcHJvZmlsZS52aWRlb0NvdW50O1xuXG4gICAgICAgICAgICB1cGRhdGVEYXRhLmxhc3RTdGF0c0ZldGNoZWRBdCA9IG5ldyBEYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhbmQgc2F2ZSBjcmVhdG9yIHRpZXIgYmFzZWQgb24gZm9sbG93ZXIgY291bnRcbiAgICAgICAgICAgIGlmIChwcm9maWxlLmZvbGxvd2VyQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB1cGRhdGVEYXRhLmNyZWF0b3JUaWVyID0gZ2V0Q3JlYXRvclRpZXJGcm9tRm9sbG93ZXJzKHByb2ZpbGUuZm9sbG93ZXJDb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggVGlrVG9rIHByb2ZpbGU6XCIsIGVycm9yKTtcbiAgICAgICAgICBpZiAoaW5wdXQudGlrdG9rSGFuZGxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaWtUb2sgcHJvZmlsaSBidWx1bmFtYWTEsSB2ZXlhIGVyacWfaWxlbWl5b3IuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHByaXNtYS51c2VyLnVwZGF0ZSh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgICAgZGF0YTogdXBkYXRlRGF0YSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdXBkYXRlZFVzZXI7XG4gICAgfSksXG5cbiAgY3JlYXRlVXNlcjogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgdXNlcklkOiB6LnN0cmluZygpLFxuICAgICAgZW1haWw6IHouc3RyaW5nKCkuZW1haWwoKSxcbiAgICAgIG5hbWU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KSlcbiAgICAubXV0YXRpb24oYXN5bmMgKHsgaW5wdXQgfSkgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBhbHJlYWR5IGV4aXN0c1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IGlucHV0LnVzZXJJZCB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIG5ldyB1c2VyIGluIGRhdGFiYXNlXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJpc21hLnVzZXIuY3JlYXRlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiBpbnB1dC51c2VySWQsXG4gICAgICAgICAgZW1haWw6IGlucHV0LmVtYWlsLFxuICAgICAgICAgIHBhc3N3b3JkOiAnc3VwYWJhc2UtYXV0aCcsIC8vIE5vdCB1c2VkLCBTdXBhYmFzZSBoYW5kbGVzIGF1dGhcbiAgICAgICAgICBuYW1lOiBpbnB1dC5uYW1lIHx8ICdpw6dlcmlrIMO8cmV0aWNpc2knLFxuICAgICAgICAgIHJvbGU6ICdDUkVBVE9SJyxcbiAgICAgICAgICBiYWxhbmNlOiAwLFxuICAgICAgICAgIGNvdXBvbkJhbGFuY2U6IDAsXG4gICAgICAgICAgcGxhbjogJ0ZSRUUnLFxuICAgICAgICAgIGN5Y2xlU3RhcnREYXRlOiBuZXcgRGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9KSxcblxuICBnZXRBY3RpdmVDYW1wYWlnbnM6IHQucHJvY2VkdXJlXG4gICAgLmlucHV0KHoub2JqZWN0KHtcbiAgICAgIHNlYXJjaDogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgdGllcjogei5lbnVtKFsnRCcsICdDJywgJ0InLCAnQScsICdTJ10pLm9wdGlvbmFsKCksXG4gICAgICBsaW1pdDogei5udW1iZXIoKS5vcHRpb25hbCgpLmRlZmF1bHQoMTAwKVxuICAgIH0pLm9wdGlvbmFsKCkpXG4gICAgLnF1ZXJ5KGFzeW5jICh7IGlucHV0IH0pID0+IHtcbiAgICAgIGNvbnN0IHNlYXJjaCA9IGlucHV0Py5zZWFyY2g7XG4gICAgICBjb25zdCB0aWVyID0gaW5wdXQ/LnRpZXI7XG4gICAgICBjb25zdCBsaW1pdCA9IGlucHV0Py5saW1pdCB8fCAxMDA7XG5cbiAgICAgIGNvbnN0IHdoZXJlOiBhbnkgPSB7XG4gICAgICAgIHN0YXR1czogXCJBQ1RJVkVcIixcbiAgICAgICAgZW5kRGF0ZTogeyBndDogbmV3IERhdGUoKSB9XG4gICAgICB9O1xuXG4gICAgICAvLyBTZXJ2ZXItc2lkZSBzZWFyY2hcbiAgICAgIGlmIChzZWFyY2gpIHtcbiAgICAgICAgd2hlcmUuT1IgPSBbXG4gICAgICAgICAgeyB0aXRsZTogeyBjb250YWluczogc2VhcmNoLCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0gfSxcbiAgICAgICAgICB7IHNvbmc6IHsgdGl0bGU6IHsgY29udGFpbnM6IHNlYXJjaCwgbW9kZTogJ2luc2Vuc2l0aXZlJyB9IH0gfSxcbiAgICAgICAgICB7IHNvbmc6IHsgYXV0aG9yTmFtZTogeyBjb250YWluczogc2VhcmNoLCBtb2RlOiAnaW5zZW5zaXRpdmUnIH0gfSB9XG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIC8vIFRpZXIgZmlsdGVyXG4gICAgICBpZiAodGllcikge1xuICAgICAgICB3aGVyZS50aWVyID0gdGllcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FtcGFpZ25zID0gYXdhaXQgcHJpc21hLmNhbXBhaWduLmZpbmRNYW55KHtcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIHRha2U6IGxpbWl0LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICB0aXRsZTogdHJ1ZSxcbiAgICAgICAgICBzdGF0dXM6IHRydWUsXG4gICAgICAgICAgdGllcjogdHJ1ZSxcbiAgICAgICAgICB0b3RhbEJ1ZGdldDogdHJ1ZSxcbiAgICAgICAgICBtYXhTdWJtaXNzaW9uczogdHJ1ZSxcbiAgICAgICAgICBtYXhQYXJ0aWNpcGFudHM6IHRydWUsIC8vIE5FV1xuICAgICAgICAgIGlzUHJvT25seTogdHJ1ZSwgICAgICAgLy8gTkVXXG4gICAgICAgICAgdGFyZ2V0VGllcnM6IHRydWUsICAgICAvLyBORVdcbiAgICAgICAgICBlbmREYXRlOiB0cnVlLFxuICAgICAgICAgIG1pbkZvbGxvd2VyczogdHJ1ZSxcbiAgICAgICAgICBtaW5WaWRlb0R1cmF0aW9uOiB0cnVlLFxuICAgICAgICAgIHBsYXRmb3JtRmVlUGVyY2VudDogdHJ1ZSxcbiAgICAgICAgICBzYWZldHlSZXNlcnZlUGVyY2VudDogdHJ1ZSxcbiAgICAgICAgICBzb25nOiB7XG4gICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgdGl0bGU6IHRydWUsXG4gICAgICAgICAgICAgIGNvdmVySW1hZ2U6IHRydWUsXG4gICAgICAgICAgICAgIGF1dGhvck5hbWU6IHRydWUsXG4gICAgICAgICAgICAgIGFydGlzdDogeyBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9jb3VudDogeyBzZWxlY3Q6IHsgc3VibWlzc2lvbnM6IHRydWUgfSB9XG4gICAgICAgIH0sXG4gICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYW1wYWlnbnM7XG4gICAgfSksXG4gIGdldEpvaW5lZENhbXBhaWduczogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgY3Vyc29yOiB6LnN0cmluZygpLm9wdGlvbmFsKCksIC8vIENhbXBhaWduIElEIGZvciBjdXJzb3ItYmFzZWQgcGFnaW5hdGlvblxuICAgICAgbGltaXQ6IHoubnVtYmVyKCkubWluKDEpLm1heCgxMDApLmRlZmF1bHQoMjApLFxuICAgICAgZW5kZWRPbmx5OiB6LmJvb2xlYW4oKS5vcHRpb25hbCgpIC8vIEZpbHRlciBmb3IgZW5kZWQgY2FtcGFpZ25zIG9ubHlcbiAgICB9KS5vcHRpb25hbCgpKVxuICAgIC5xdWVyeShhc3luYyAoeyBjdHgsIGlucHV0IH0pID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSByZXR1cm4geyBjYW1wYWlnbnM6IFtdLCBuZXh0Q3Vyc29yOiBudWxsIH07XG5cbiAgICAgIGNvbnN0IGxpbWl0ID0gaW5wdXQ/LmxpbWl0IHx8IDIwO1xuICAgICAgY29uc3QgZW5kZWRPbmx5ID0gaW5wdXQ/LmVuZGVkT25seSB8fCBmYWxzZTtcblxuICAgICAgY29uc3Qgd2hlcmU6IGFueSA9IHtcbiAgICAgICAgc3VibWlzc2lvbnM6IHtcbiAgICAgICAgICBzb21lOiB7IGNyZWF0b3JJZDogdXNlcklkIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gRmlsdGVyIGZvciBlbmRlZCBjYW1wYWlnbnMgaWYgcmVxdWVzdGVkXG4gICAgICBpZiAoZW5kZWRPbmx5KSB7XG4gICAgICAgIHdoZXJlLk9SID0gW1xuICAgICAgICAgIHsgc3RhdHVzOiAnQ09NUExFVEVEJyB9LFxuICAgICAgICAgIHsgZW5kRGF0ZTogeyBsdDogbmV3IERhdGUoKSB9IH1cbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3Vyc29yLWJhc2VkIHBhZ2luYXRpb25cbiAgICAgIGlmIChpbnB1dD8uY3Vyc29yKSB7XG4gICAgICAgIHdoZXJlLmlkID0geyBsdDogaW5wdXQuY3Vyc29yIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbXBhaWducyA9IGF3YWl0IHByaXNtYS5jYW1wYWlnbi5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlLFxuICAgICAgICB0YWtlOiBsaW1pdCArIDEsIC8vIEZldGNoIG9uZSBleHRyYSB0byBkZXRlcm1pbmUgaWYgdGhlcmUgYXJlIG1vcmVcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgdGl0bGU6IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiB0cnVlLFxuICAgICAgICAgIHRvdGFsQnVkZ2V0OiB0cnVlLFxuICAgICAgICAgIG1heFN1Ym1pc3Npb25zOiB0cnVlLFxuICAgICAgICAgIGVuZERhdGU6IHRydWUsXG4gICAgICAgICAgcGxhdGZvcm1GZWVQZXJjZW50OiB0cnVlLFxuICAgICAgICAgIHNhZmV0eVJlc2VydmVQZXJjZW50OiB0cnVlLFxuICAgICAgICAgIHN1Ym1pc3Npb25zOiB7XG4gICAgICAgICAgICB3aGVyZTogeyBjcmVhdG9ySWQ6IHVzZXJJZCB9LFxuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgICAgICBzdGF0dXM6IHRydWUsXG4gICAgICAgICAgICAgIGxhc3RWaWV3Q291bnQ6IHRydWUsXG4gICAgICAgICAgICAgIGxhc3RMaWtlQ291bnQ6IHRydWUsXG4gICAgICAgICAgICAgIGxhc3RTaGFyZUNvdW50OiB0cnVlLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IHRydWUsXG4gICAgICAgICAgICAgIHZpZXdQb2ludHM6IHRydWUsXG4gICAgICAgICAgICAgIGxpa2VQb2ludHM6IHRydWUsXG4gICAgICAgICAgICAgIHNoYXJlUG9pbnRzOiB0cnVlLFxuICAgICAgICAgICAgICB0b3RhbFBvaW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgc2hhcmVQZXJjZW50OiB0cnVlLFxuICAgICAgICAgICAgICBlc3RpbWF0ZWRFYXJuaW5nczogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc29uZzoge1xuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgIHRpdGxlOiB0cnVlLFxuICAgICAgICAgICAgICBhdXRob3JOYW1lOiB0cnVlLFxuICAgICAgICAgICAgICBjb3ZlckltYWdlOiB0cnVlLFxuICAgICAgICAgICAgICBhcnRpc3Q6IHsgc2VsZWN0OiB7IG5hbWU6IHRydWUgfSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb29sU3RhdHM6IHtcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICB0b3RhbENhbXBhaWduUG9pbnRzOiB0cnVlLFxuICAgICAgICAgICAgICB0b3RhbFN1Ym1pc3Npb25zOiB0cnVlLFxuICAgICAgICAgICAgICBhdmVyYWdlUG9pbnRzOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBfY291bnQ6IHsgc2VsZWN0OiB7IHN1Ym1pc3Npb25zOiB0cnVlIH0gfVxuICAgICAgICB9LFxuICAgICAgICBvcmRlckJ5OiB7IHVwZGF0ZWRBdDogXCJkZXNjXCIgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBtb3JlIHJlc3VsdHNcbiAgICAgIGNvbnN0IGhhc01vcmUgPSBjYW1wYWlnbnMubGVuZ3RoID4gbGltaXQ7XG4gICAgICBjb25zdCByZXN1bHQgPSBoYXNNb3JlID8gY2FtcGFpZ25zLnNsaWNlKDAsIGxpbWl0KSA6IGNhbXBhaWducztcbiAgICAgIGNvbnN0IG5leHRDdXJzb3IgPSBoYXNNb3JlID8gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5pZCA6IG51bGw7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbXBhaWduczogcmVzdWx0LFxuICAgICAgICBuZXh0Q3Vyc29yXG4gICAgICB9O1xuICAgIH0pLFxuXG4gIGdldENhbXBhaWduQ291bnRzOiB0LnByb2NlZHVyZVxuICAgIC5xdWVyeShhc3luYyAoeyBjdHggfSkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gY3R4LnVzZXI/LmlkO1xuICAgICAgaWYgKCF1c2VySWQpIHRocm93IG5ldyBFcnJvcihcIlVOQVVUSE9SSVpFRFwiKTtcblxuICAgICAgY29uc3QgW2FjdGl2ZUNvdW50LCBteUFjdGl2ZUNvdW50LCBqb2luZWRBY3RpdmVDb3VudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIC8vIDEuIFRvdGFsIEFjdGl2ZSBDYW1wYWlnbnNcbiAgICAgICAgcHJpc21hLmNhbXBhaWduLmNvdW50KHtcbiAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgc3RhdHVzOiBcIkFDVElWRVwiLFxuICAgICAgICAgICAgZW5kRGF0ZTogeyBndDogbmV3IERhdGUoKSB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcblxuICAgICAgICAvLyAyLiBNeSBBY3RpdmUgQ2FtcGFpZ25zIChpZiBBcnRpc3QpXG4gICAgICAgIHByaXNtYS5jYW1wYWlnbi5jb3VudCh7XG4gICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgIGFydGlzdElkOiB1c2VySWQsXG4gICAgICAgICAgICBzdGF0dXM6IFwiQUNUSVZFXCIsXG4gICAgICAgICAgICBlbmREYXRlOiB7IGd0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuXG4gICAgICAgIC8vIDMuIEpvaW5lZCBBY3RpdmUgQ2FtcGFpZ25zIChpZiBDcmVhdG9yKVxuICAgICAgICBwcmlzbWEuY2FtcGFpZ24uY291bnQoe1xuICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICBzdGF0dXM6IFwiQUNUSVZFXCIsXG4gICAgICAgICAgICBlbmREYXRlOiB7IGd0OiBuZXcgRGF0ZSgpIH0sXG4gICAgICAgICAgICBzdWJtaXNzaW9uczoge1xuICAgICAgICAgICAgICBzb21lOiB7IGNyZWF0b3JJZDogdXNlcklkIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlQ291bnQsXG4gICAgICAgIG15QWN0aXZlQ291bnQsXG4gICAgICAgIGpvaW5lZEFjdGl2ZUNvdW50XG4gICAgICB9O1xuICAgIH0pLFxuICBnZXRDYW1wYWlnbkJ5SWQ6IHQucHJvY2VkdXJlXG4gICAgLmlucHV0KHoub2JqZWN0KHsgaWQ6IHouc3RyaW5nKCkgfSkpXG4gICAgLnF1ZXJ5KGFzeW5jICh7IGlucHV0LCBjdHggfSkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gY3R4LnVzZXI/LmlkO1xuXG4gICAgICAvLyAxLiBGZXRjaCBDYW1wYWlnbiBCYXNlIEluZm9cbiAgICAgIGNvbnN0IGNhbXBhaWduID0gYXdhaXQgcHJpc21hLmNhbXBhaWduLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW5wdXQuaWQgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIF9jb3VudDoge1xuICAgICAgICAgICAgc2VsZWN0OiB7IHN1Ym1pc3Npb25zOiB0cnVlIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNvbmc6IHtcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICB0aXRsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgY292ZXJJbWFnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgIHRpa3Rva1VybDogdHJ1ZSxcbiAgICAgICAgICAgICAgdGlrdG9rTXVzaWNJZDogdHJ1ZSxcbiAgICAgICAgICAgICAgYXV0aG9yTmFtZTogdHJ1ZSwgLy8gQWRkZWQgZm9yIHByb3BlciBkaXNwbGF5XG4gICAgICAgICAgICAgIGFydGlzdDoge1xuICAgICAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGJpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGF2YXRhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY2FtcGFpZ24pIHJldHVybiBudWxsO1xuXG4gICAgICAvLyAyLiBGZXRjaCBNeSBTdWJtaXNzaW9uIChpZiBsb2dnZWQgaW4gQU5EIG5vdCB0aGUgY2FtcGFpZ24gb3duZXIpXG4gICAgICBsZXQgbXlTdWJtaXNzaW9uOiBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIHByaXNtYS5zdWJtaXNzaW9uLmZpbmRGaXJzdD4+ID0gbnVsbDtcbiAgICAgIGlmICh1c2VySWQgJiYgY2FtcGFpZ24uYXJ0aXN0SWQgIT09IHVzZXJJZCkge1xuICAgICAgICBteVN1Ym1pc3Npb24gPSBhd2FpdCBwcmlzbWEuc3VibWlzc2lvbi5maW5kRmlyc3Qoe1xuICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICBjYW1wYWlnbklkOiBpbnB1dC5pZCxcbiAgICAgICAgICAgIGNyZWF0b3JJZDogdXNlcklkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gMy4gQ2FsY3VsYXRlIFRvdGFsIENhbXBhaWduIFBvaW50cyAoUmVhbC10aW1lKVxuICAgICAgY29uc3QgYWdncmVnYXRpb25zID0gYXdhaXQgcHJpc21hLnN1Ym1pc3Npb24uYWdncmVnYXRlKHtcbiAgICAgICAgd2hlcmU6IHsgY2FtcGFpZ25JZDogaW5wdXQuaWQgfSxcbiAgICAgICAgX3N1bToge1xuICAgICAgICAgIGxhc3RWaWV3Q291bnQ6IHRydWUsXG4gICAgICAgICAgbGFzdExpa2VDb3VudDogdHJ1ZSxcbiAgICAgICAgICBsYXN0U2hhcmVDb3VudDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHBvaW50cyBjb25zaXN0ZW50IHdpdGggQWxsIFN1Ym1pc3Npb25zIGxvZ2ljXG4gICAgICAvLyBGZXRjaCBhbGwgc3VibWlzc2lvbnMgbGlnaHQtd2VpZ2h0IHRvIHN1bSBhY2N1cmF0ZWx5XG4gICAgICBjb25zdCBhbGxTdWJtaXNzaW9ucyA9IGF3YWl0IHByaXNtYS5zdWJtaXNzaW9uLmZpbmRNYW55KHtcbiAgICAgICAgd2hlcmU6IHsgY2FtcGFpZ25JZDogaW5wdXQuaWQgfSxcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgdG90YWxQb2ludHM6IHRydWUsXG4gICAgICAgICAgdmlld1BvaW50czogdHJ1ZSxcbiAgICAgICAgICBsaWtlUG9pbnRzOiB0cnVlLFxuICAgICAgICAgIHNoYXJlUG9pbnRzOiB0cnVlLFxuICAgICAgICAgIGxhc3RWaWV3Q291bnQ6IHRydWUsXG4gICAgICAgICAgbGFzdExpa2VDb3VudDogdHJ1ZSxcbiAgICAgICAgICBsYXN0U2hhcmVDb3VudDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdG90YWxDYW1wYWlnblBvaW50cyA9IGFsbFN1Ym1pc3Npb25zLnJlZHVjZSgoc3VtLCBzdWIpID0+IHtcbiAgICAgICAgLy8gQmFja2ZpbGwgbG9naWMgbWF0Y2hpbmcgZ2V0Q2FtcGFpZ25TdWJtaXNzaW9uc1xuICAgICAgICBjb25zdCB2aWV3UG9pbnRzID0gc3ViLnZpZXdQb2ludHMgfHwgKHN1Yi5sYXN0Vmlld0NvdW50ICogMC4wMSk7XG4gICAgICAgIGNvbnN0IGxpa2VQb2ludHMgPSBzdWIubGlrZVBvaW50cyB8fCAoc3ViLmxhc3RMaWtlQ291bnQgKiAwLjUpO1xuICAgICAgICBjb25zdCBzaGFyZVBvaW50cyA9IHN1Yi5zaGFyZVBvaW50cyB8fCAoc3ViLmxhc3RTaGFyZUNvdW50ICogMS4wKTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gc3ViLnRvdGFsUG9pbnRzIHx8ICh2aWV3UG9pbnRzICsgbGlrZVBvaW50cyArIHNoYXJlUG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIHN1bSArIHBvaW50cztcbiAgICAgIH0sIDApO1xuXG4gICAgICAvLyBLZWVwIHN0cmljdCB2aWV3L2xpa2UgdG90YWxzIGZyb20gYWdncmVnYXRpb24gYXMgdGhleSBhcmUgcmF3IGNvdW50ZXJzXG4gICAgICBjb25zdCB0b3RhbFZpZXdzID0gYWdncmVnYXRpb25zLl9zdW0ubGFzdFZpZXdDb3VudCB8fCAwO1xuICAgICAgY29uc3QgdG90YWxMaWtlcyA9IGFnZ3JlZ2F0aW9ucy5fc3VtLmxhc3RMaWtlQ291bnQgfHwgMDtcbiAgICAgIGNvbnN0IHRvdGFsU2hhcmVzID0gYWdncmVnYXRpb25zLl9zdW0ubGFzdFNoYXJlQ291bnQgfHwgMDtcblxuICAgICAgLy8gNC4gRmV0Y2ggUmVjZW50IFN1Ym1pc3Npb25zIChJZiBPd25lcikgLSBmb3IgQXJ0aXN0IFZpZXdcbiAgICAgIGxldCByZWNlbnRTdWJtaXNzaW9uczogYW55W10gPSBbXTtcbiAgICAgIGlmICh1c2VySWQgJiYgY2FtcGFpZ24uYXJ0aXN0SWQgPT09IHVzZXJJZCkge1xuICAgICAgICByZWNlbnRTdWJtaXNzaW9ucyA9IGF3YWl0IHByaXNtYS5zdWJtaXNzaW9uLmZpbmRNYW55KHtcbiAgICAgICAgICB3aGVyZTogeyBjYW1wYWlnbklkOiBpbnB1dC5pZCB9LFxuICAgICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiAnZGVzYycgfSxcbiAgICAgICAgICB0YWtlOiAxMCxcbiAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiB0cnVlLFxuICAgICAgICAgICAgdGlrdG9rVXJsOiB0cnVlLFxuICAgICAgICAgICAgdG90YWxQb2ludHM6IHRydWUsXG4gICAgICAgICAgICBzaGFyZVBlcmNlbnQ6IHRydWUsXG4gICAgICAgICAgICB2aWV3UG9pbnRzOiB0cnVlLFxuICAgICAgICAgICAgbGlrZVBvaW50czogdHJ1ZSxcbiAgICAgICAgICAgIHNoYXJlUG9pbnRzOiB0cnVlLFxuICAgICAgICAgICAgbGFzdFZpZXdDb3VudDogdHJ1ZSxcbiAgICAgICAgICAgIGxhc3RMaWtlQ291bnQ6IHRydWUsXG4gICAgICAgICAgICBsYXN0U2hhcmVDb3VudDogdHJ1ZSxcbiAgICAgICAgICAgIGVzdGltYXRlZEVhcm5pbmdzOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRvcjoge1xuICAgICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF2YXRhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aWt0b2tIYW5kbGU6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlc3RydWN0dXJlIHRvIGV4Y2x1ZGUgc3RhbGUgY29tcHV0ZWQgZmllbGRzIGZyb20gZGF0YWJhc2VcbiAgICAgIGNvbnN0IHsgdG90YWxDYW1wYWlnblBvaW50czogXywgbmV0QnVkZ2V0VFA6IF9fLCBuZXRNdWx0aXBsaWVyOiBfX18sIC4uLmNhbXBhaWduRGF0YSB9ID0gY2FtcGFpZ247XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNhbXBhaWduRGF0YSxcbiAgICAgICAgbXlTdWJtaXNzaW9uLFxuICAgICAgICAvLyBBbHdheXMgdXNlIGZyZXNoIGNvbXB1dGVkIHZhbHVlcywgbm90IHN0YWxlIGRhdGFiYXNlIGZpZWxkc1xuICAgICAgICB0b3RhbFZpZXdzLFxuICAgICAgICB0b3RhbENhbXBhaWduUG9pbnRzLFxuICAgICAgICB0b3RhbExpa2VzLFxuICAgICAgICB0b3RhbFNoYXJlcyxcbiAgICAgICAgc3VibWlzc2lvbnM6IHJlY2VudFN1Ym1pc3Npb25zLm1hcChzdWIgPT4gKHtcbiAgICAgICAgICAuLi5zdWIsXG4gICAgICAgICAgdmlld1BvaW50czogc3ViLnZpZXdQb2ludHMgfHwgKHN1Yi5sYXN0Vmlld0NvdW50ICogMC4wMSksXG4gICAgICAgICAgbGlrZVBvaW50czogc3ViLmxpa2VQb2ludHMgfHwgKHN1Yi5sYXN0TGlrZUNvdW50ICogMC41KSxcbiAgICAgICAgICBzaGFyZVBvaW50czogc3ViLnNoYXJlUG9pbnRzIHx8IChzdWIubGFzdFNoYXJlQ291bnQgKiAxLjApLFxuICAgICAgICAgIHRvdGFsUG9pbnRzOiBzdWIudG90YWxQb2ludHMgfHwgKChzdWIubGFzdFZpZXdDb3VudCAqIDAuMDEpICsgKHN1Yi5sYXN0TGlrZUNvdW50ICogMC41KSArIChzdWIubGFzdFNoYXJlQ291bnQgKiAxLjApKVxuICAgICAgICB9KSkgLy8gQ29tcGF0aWJsZSBhcnJheSBmb3IgQXJ0aXN0IFZpZXdcbiAgICAgIH07XG4gICAgfSksXG5cbiAgZ2V0Q2FtcGFpZ25TdWJtaXNzaW9uczogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgY2FtcGFpZ25JZDogei5zdHJpbmcoKSxcbiAgICAgIGN1cnNvcjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgbGltaXQ6IHoubnVtYmVyKCkubWluKDEpLm1heCgxMDApLmRlZmF1bHQoMjUpLFxuICAgICAgc2VhcmNoOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICBzb3J0Qnk6IHouZW51bShbJ3BlcmNlbnRhZ2UnLCAndmlld3MnLCAnbGlrZXMnLCAnc2hhcmVzJywgJ3BvaW50cycsICdyZWNlbnQnLCAndGllciddKS5kZWZhdWx0KCdwZXJjZW50YWdlJylcbiAgICB9KSlcbiAgICAucXVlcnkoYXN5bmMgKHsgaW5wdXQsIGN0eCB9KSA9PiB7XG4gICAgICBjb25zdCB7IGNhbXBhaWduSWQsIGN1cnNvciwgbGltaXQsIHNlYXJjaCwgc29ydEJ5IH0gPSBpbnB1dDtcblxuICAgICAgY29uc3Qgd2hlcmU6IGFueSA9IHsgY2FtcGFpZ25JZCB9O1xuXG4gICAgICAvLyBTZWFyY2ggRmlsdGVyXG4gICAgICBpZiAoc2VhcmNoKSB7XG4gICAgICAgIHdoZXJlLmNyZWF0b3IgPSB7XG4gICAgICAgICAgdGlrdG9rSGFuZGxlOiB7IGNvbnRhaW5zOiBzZWFyY2gsIG1vZGU6ICdpbnNlbnNpdGl2ZScgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBTb3J0IExvZ2ljXG4gICAgICBsZXQgb3JkZXJCeTogYW55ID0ge307XG4gICAgICBzd2l0Y2ggKHNvcnRCeSkge1xuICAgICAgICBjYXNlICdwZXJjZW50YWdlJzogb3JkZXJCeSA9IHsgc2hhcmVQZXJjZW50OiAnZGVzYycgfTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZpZXdzJzogb3JkZXJCeSA9IHsgbGFzdFZpZXdDb3VudDogJ2Rlc2MnIH07IGJyZWFrO1xuICAgICAgICBjYXNlICdsaWtlcyc6IG9yZGVyQnkgPSB7IGxhc3RMaWtlQ291bnQ6ICdkZXNjJyB9OyBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhcmVzJzogb3JkZXJCeSA9IHsgbGFzdFNoYXJlQ291bnQ6ICdkZXNjJyB9OyBicmVhaztcbiAgICAgICAgY2FzZSAncG9pbnRzJzogb3JkZXJCeSA9IHsgdG90YWxQb2ludHM6ICdkZXNjJyB9OyBicmVhaztcbiAgICAgICAgY2FzZSAncmVjZW50Jzogb3JkZXJCeSA9IHsgY3JlYXRlZEF0OiAnZGVzYycgfTsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RpZXInOiBvcmRlckJ5ID0geyBjcmVhdG9yOiB7IGNyZWF0b3JUaWVyOiAnZGVzYycgfSB9OyBicmVhazsgLy8gUyA+IEEgPiBCID4gQyA+IERcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3VibWlzc2lvbnMgPSBhd2FpdCBwcmlzbWEuc3VibWlzc2lvbi5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlLFxuICAgICAgICB0YWtlOiBsaW1pdCArIDEsXG4gICAgICAgIGN1cnNvcjogY3Vyc29yID8geyBpZDogY3Vyc29yIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIG9yZGVyQnksXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRBdDogdHJ1ZSxcbiAgICAgICAgICB0aWt0b2tVcmw6IHRydWUsXG4gICAgICAgICAgdG90YWxQb2ludHM6IHRydWUsXG4gICAgICAgICAgc2hhcmVQZXJjZW50OiB0cnVlLFxuICAgICAgICAgIHZpZXdQb2ludHM6IHRydWUsXG4gICAgICAgICAgbGlrZVBvaW50czogdHJ1ZSxcbiAgICAgICAgICBzaGFyZVBvaW50czogdHJ1ZSxcbiAgICAgICAgICBsYXN0Vmlld0NvdW50OiB0cnVlLFxuICAgICAgICAgIGxhc3RMaWtlQ291bnQ6IHRydWUsXG4gICAgICAgICAgbGFzdFNoYXJlQ291bnQ6IHRydWUsXG4gICAgICAgICAgZXN0aW1hdGVkRWFybmluZ3M6IHRydWUsXG4gICAgICAgICAgY3JlYXRvcjoge1xuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgIG5hbWU6IHRydWUsXG4gICAgICAgICAgICAgIGF2YXRhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgdGlrdG9rSGFuZGxlOiB0cnVlLFxuICAgICAgICAgICAgICBjcmVhdG9yVGllcjogdHJ1ZSAvLyBBZGRlZCBmb3IgdGllciBkaXNwbGF5IGFuZCBzb3J0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbGV0IG5leHRDdXJzb3I6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChzdWJtaXNzaW9ucy5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICBjb25zdCBuZXh0SXRlbSA9IHN1Ym1pc3Npb25zLnBvcCgpO1xuICAgICAgICBuZXh0Q3Vyc29yID0gbmV4dEl0ZW0hLmlkO1xuICAgICAgfVxuXG4gICAgICAvLyBCYWNrZmlsbCBwb2ludHMgZm9yIGxlZ2FjeSBkYXRhIGlmIG5lZWRlZFxuICAgICAgY29uc3QgdHJlYXRlZFN1Ym1pc3Npb25zID0gc3VibWlzc2lvbnMubWFwKHN1YiA9PiB7XG4gICAgICAgIGNvbnN0IHZpZXdQb2ludHMgPSBzdWIudmlld1BvaW50cyB8fCAoc3ViLmxhc3RWaWV3Q291bnQgKiAwLjAxKTtcbiAgICAgICAgY29uc3QgbGlrZVBvaW50cyA9IHN1Yi5saWtlUG9pbnRzIHx8IChzdWIubGFzdExpa2VDb3VudCAqIDAuNSk7XG4gICAgICAgIGNvbnN0IHNoYXJlUG9pbnRzID0gc3ViLnNoYXJlUG9pbnRzIHx8IChzdWIubGFzdFNoYXJlQ291bnQgKiAxLjApO1xuICAgICAgICBjb25zdCB0b3RhbFBvaW50cyA9IHN1Yi50b3RhbFBvaW50cyB8fCAodmlld1BvaW50cyArIGxpa2VQb2ludHMgKyBzaGFyZVBvaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zdWIsXG4gICAgICAgICAgdmlld1BvaW50cyxcbiAgICAgICAgICBsaWtlUG9pbnRzLFxuICAgICAgICAgIHNoYXJlUG9pbnRzLFxuICAgICAgICAgIHRvdGFsUG9pbnRzLFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Ym1pc3Npb25zOiB0cmVhdGVkU3VibWlzc2lvbnMsXG4gICAgICAgIG5leHRDdXJzb3JcbiAgICAgIH07XG4gICAgfSksXG5cbiAgZ2V0Q2FtcGFpZ25BbmFseXNpczogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgaWQ6IHouc3RyaW5nKCksXG4gICAgICBwZXJpb2Q6IHouZW51bShbJzI0aCcsICc3ZCcsICczMGQnLCAnYWxsJ10pLmRlZmF1bHQoJ2FsbCcpXG4gICAgfSkpXG4gICAgLnF1ZXJ5KGFzeW5jICh7IGlucHV0LCBjdHggfSkgPT4ge1xuICAgICAgY29uc3QgeyBpZCwgcGVyaW9kIH0gPSBpbnB1dDtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG5cbiAgICAgIGNvbnN0IGNhbXBhaWduID0gYXdhaXQgcHJpc21hLmNhbXBhaWduLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZCB9LFxuICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgc3VibWlzc2lvbnM6IHtcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IHRydWUsXG4gICAgICAgICAgICAgIGxhc3RWaWV3Q291bnQ6IHRydWUsXG4gICAgICAgICAgICAgIGxhc3RMaWtlQ291bnQ6IHRydWUsXG4gICAgICAgICAgICAgIGxhc3RTaGFyZUNvdW50OiB0cnVlLFxuICAgICAgICAgICAgICBjcmVhdG9yOiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgICBjcmVhdG9yVGllcjogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY2FtcGFpZ24pIHRocm93IG5ldyBFcnJvcihcIkNBTVBBSUdOX05PVF9GT1VORFwiKTtcbiAgICAgIGlmIChjYW1wYWlnbi5hcnRpc3RJZCAhPT0gdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJGT1JCSURERU5cIik7XG5cbiAgICAgIC8vIEZpbHRlciBTdWJtaXNzaW9ucyBiYXNlZCBvbiBQZXJpb2RcbiAgICAgIGxldCBmaWx0ZXJlZFN1Ym1pc3Npb25zID0gY2FtcGFpZ24uc3VibWlzc2lvbnM7XG4gICAgICBpZiAocGVyaW9kICE9PSAnYWxsJykge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgc3RhcnREYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xuICAgICAgICAgIGNhc2UgJzI0aCc6IHN0YXJ0RGF0ZS5zZXRIb3Vycyhub3cuZ2V0SG91cnMoKSAtIDI0KTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnN2QnOiBzdGFydERhdGUuc2V0RGF0ZShub3cuZ2V0RGF0ZSgpIC0gNyk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzMwZCc6IHN0YXJ0RGF0ZS5zZXREYXRlKG5vdy5nZXREYXRlKCkgLSAzMCk7IGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyZWRTdWJtaXNzaW9ucyA9IGNhbXBhaWduLnN1Ym1pc3Npb25zLmZpbHRlcihzdWIgPT4gbmV3IERhdGUoc3ViLmNyZWF0ZWRBdCkgPj0gc3RhcnREYXRlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIFRvdGFscyBzZXJ2ZXItc2lkZVxuICAgICAgY29uc3QgdG90YWxzID0gZmlsdGVyZWRTdWJtaXNzaW9ucy5yZWR1Y2UoKGFjYzogYW55LCBzdWI6IGFueSkgPT4gKHtcbiAgICAgICAgdmlld3M6IGFjYy52aWV3cyArIChzdWIubGFzdFZpZXdDb3VudCB8fCAwKSxcbiAgICAgICAgbGlrZXM6IGFjYy5saWtlcyArIChzdWIubGFzdExpa2VDb3VudCB8fCAwKSxcbiAgICAgICAgc2hhcmVzOiBhY2Muc2hhcmVzICsgKHN1Yi5sYXN0U2hhcmVDb3VudCB8fCAwKSxcbiAgICAgICAgc3VibWlzc2lvbnM6IGFjYy5zdWJtaXNzaW9ucyArIDFcbiAgICAgIH0pLCB7IHZpZXdzOiAwLCBsaWtlczogMCwgc2hhcmVzOiAwLCBzdWJtaXNzaW9uczogMCB9KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIFRpZXIgRGlzdHJpYnV0aW9uXG4gICAgICBjb25zdCB0aWVyQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0geyBEOiAwLCBDOiAwLCBCOiAwLCBBOiAwLCBTOiAwIH07XG4gICAgICBmaWx0ZXJlZFN1Ym1pc3Npb25zLmZvckVhY2goKHN1YjogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHRpZXIgPSBzdWIuY3JlYXRvcj8uY3JlYXRvclRpZXIgfHwgJ0QnO1xuICAgICAgICB0aWVyQ291bnRzW3RpZXJdID0gKHRpZXJDb3VudHNbdGllcl0gfHwgMCkgKyAxO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHRvdGFsU3VibWlzc2lvbnMgPSBmaWx0ZXJlZFN1Ym1pc3Npb25zLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRpZXJEaXN0cmlidXRpb24gPSBPYmplY3QuZW50cmllcyh0aWVyQ291bnRzKVxuICAgICAgICAubWFwKChbdGllciwgY291bnRdKSA9PiAoe1xuICAgICAgICAgIHRpZXIsXG4gICAgICAgICAgY291bnQsXG4gICAgICAgICAgcGVyY2VudGFnZTogdG90YWxTdWJtaXNzaW9ucyA+IDAgPyAoY291bnQgLyB0b3RhbFN1Ym1pc3Npb25zKSAqIDEwMCA6IDBcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmNvdW50ID4gMCkgLy8gT25seSBpbmNsdWRlIHRpZXJzIHRoYXQgaGF2ZSBzdWJtaXNzaW9uc1xuICAgICAgICAuc29ydCgoYSwgYikgPT4geyAvLyBTb3J0IFMgLT4gQSAtPiBCIC0+IEMgLT4gRFxuICAgICAgICAgIGNvbnN0IG9yZGVyOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0geyBTOiA1LCBBOiA0LCBCOiAzLCBDOiAyLCBEOiAxIH07XG4gICAgICAgICAgcmV0dXJuIChvcmRlcltiLnRpZXJdIHx8IDApIC0gKG9yZGVyW2EudGllcl0gfHwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgRGFpbHkgU3RhdHMgKENoYXJ0IERhdGEpIHNlcnZlci1zaWRlXG4gICAgICBjb25zdCBncm91cGVkID0gZmlsdGVyZWRTdWJtaXNzaW9ucy5yZWR1Y2UoKGFjYzogYW55LCBzdWI6IGFueSkgPT4ge1xuICAgICAgICAvL0ZvciAyNGggdmlldywgZ3JvdXAgYnkgSG91ciBpbnN0ZWFkIG9mIERhdGU/IFxuICAgICAgICAvLyBVc2VyIHJlcXVlc3RlZCBcInRvcCBvZiBncmFwaC4uLiAyNHMsIDdnLCAzMGdcIi4gXG4gICAgICAgIC8vIFR5cGljYWxseSBmb3IgMjRoLCBob3VybHkgYnJlYWtkb3duIGlzIGJldHRlciwgYnV0IGRhaWx5IGlzIHNhZmVyIGZvciBub3cgdW5sZXNzIHJlcXVlc3RlZC5cbiAgICAgICAgLy8gTGV0J3Mgc3RpY2sgdG8gZGFpbHkgZm9yIDdkLzMwZC9hbGwuIEZvciAyNGgsIGRhaWx5IG1pZ2h0IGJlIGp1c3QgMSBvciAyIHBvaW50cy5cbiAgICAgICAgLy8gTGV0J3MgdXNlIEhvdXI6TWludXRlIGZvciAyNGgsIG90aGVyd2lzZSBEYXRlLlxuXG4gICAgICAgIGxldCBsYWJlbCA9IFwiXCI7XG4gICAgICAgIGlmIChwZXJpb2QgPT09ICcyNGgnKSB7XG4gICAgICAgICAgbGFiZWwgPSBuZXcgRGF0ZShzdWIuY3JlYXRlZEF0KS50b0xvY2FsZVRpbWVTdHJpbmcoJ3RyLVRSJywgeyBob3VyOiAnMi1kaWdpdCcsIG1pbnV0ZTogJzItZGlnaXQnIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsID0gbmV3IERhdGUoc3ViLmNyZWF0ZWRBdCkudG9Mb2NhbGVEYXRlU3RyaW5nKCd0ci1UUicsIHsgZGF5OiAnMi1kaWdpdCcsIG1vbnRoOiAnMi1kaWdpdCcgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFjY1tsYWJlbF0pIHtcbiAgICAgICAgICBhY2NbbGFiZWxdID0geyBkYXRlOiBsYWJlbCwgdmlld3M6IDAsIGxpa2VzOiAwLCBzaGFyZXM6IDAsIGNvdW50OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgYWNjW2xhYmVsXS52aWV3cyArPSAoc3ViLmxhc3RWaWV3Q291bnQgfHwgMCk7XG4gICAgICAgIGFjY1tsYWJlbF0ubGlrZXMgKz0gKHN1Yi5sYXN0TGlrZUNvdW50IHx8IDApO1xuICAgICAgICBhY2NbbGFiZWxdLnNoYXJlcyArPSAoc3ViLmxhc3RTaGFyZUNvdW50IHx8IDApO1xuICAgICAgICBhY2NbbGFiZWxdLmNvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIGNvbnN0IGNoYXJ0RGF0YSA9IE9iamVjdC52YWx1ZXMoZ3JvdXBlZCkuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IHtcbiAgICAgICAgLy8gU29ydCBsb2dpYyBuZWVkcyB0byBoYW5kbGUgSEg6bW0gdnMgREQuTU1cbiAgICAgICAgaWYgKHBlcmlvZCA9PT0gJzI0aCcpIHtcbiAgICAgICAgICByZXR1cm4gYS5kYXRlLmxvY2FsZUNvbXBhcmUoYi5kYXRlKTsgLy8gU2ltcGxlIHN0cmluZyBjb21wYXJlIGZvciBISDptbSB3b3JrcyBmb3Igc2FtZSBkYXkgdXN1YWxseSwgYnV0IGFjcm9zcyBtaWRuaWdodD9cbiAgICAgICAgICAvLyBVc2luZyB0aW1lc3RhbXAgZnJvbSBvcmlnaW5hbCBkYXRhIHdvdWxkIGJlIGJldHRlciBidXQgd2UgZ3JvdXBlZC4gXG4gICAgICAgICAgLy8gUmUtc29ydGluZyBieSBcImZpcnN0IGl0ZW0gZm91bmRcIiB0aW1lc3RhbXAgbWlnaHQgYmUgY29tcGxleCBoZXJlLlxuICAgICAgICAgIC8vIExldCdzIHN0aWNrIHRvIHNpbXBsZSBcImluc2VydCBvcmRlclwiIG9yIHN0cmluZyBzb3J0IGZvciBub3cuXG4gICAgICAgICAgLy8gQWN0dWFsbHksICcyNGgnIHVzdWFsbHkgbWVhbnMgXCJsYXN0IDI0IGhvdXJzXCIsIHNvIGl0IHNwYW5zIDIgZGF5cy5cbiAgICAgICAgICAvLyBDb3JyZWN0IHNvcnRpbmcgcmVxdWlyZXMgZnVsbGVyIGRhdGUgaW5mby5cbiAgICAgICAgICAvLyBTaW1wbGlmaWVkOiBUaGUgZnJvbnRlbmQgY2hhcnQgbG9naWMgcmVsaWVzIG9uIGEuZGF0ZS5zcGxpdCgnLicpLlxuICAgICAgICAgIC8vIEkgd2lsbCBrZWVwIHVzaW5nIERELk1NIGZvciBjb25zaXN0ZW5jeSBmb3Igbm93IHRvIGF2b2lkIGJyZWFraW5nIGZyb250ZW5kIGNoYXJ0IHBhcnNpbmcgd2hpY2ggc3BsaXRzIGJ5ICcuJ1xuICAgICAgICAgIC8vIFdhaXQsIGZvciAyNGgsIHNob3dpbmcganVzdCAyIGJhcnMgKFRvZGF5IHZzIFllc3RlcmRheSkgaXMgcHJvYmFibHkgZmluZS9leHBlY3RlZCBpZiB3ZSBzdGljayB0byBERC5NTS5cbiAgICAgICAgICAvLyBJZiBJIGNoYW5nZSBmb3JtYXQsIEkgYnJlYWsgZnJvbnRlbmQuXG4gICAgICAgICAgLy8gRGVjaXNpb246IFN0aWNrIHRvIERELk1NIGZvciBcImFsbFwiLCBcIjdkXCIsIFwiMzBkXCIuXG4gICAgICAgICAgLy8gRm9yIFwiMjRoXCIsIGl0IGVzc2VudGlhbGx5IHNob3dzIGp1c3QgdGhlIHJlbGV2YW50IGRheXMgKHVzdWFsbHkgMSBvciAyKS5cbiAgICAgICAgICAvLyBJZiB1c2VyIHJlYWxseSB3YW50cyBob3VybHksIEknZCBuZWVkIHRvIHVwZGF0ZSBmcm9udGVuZCBjaGFydCBwYXJzaW5nIHRvby5cbiAgICAgICAgICAvLyBJIHdpbGwgc3RpY2sgdG8gdGhlIGV4aXN0aW5nIERELk1NIGZvcm1hdCB0byBzdGF5IHNhZmUgYW5kIGNvbnNpc3RlbnQuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2QxLCBtMV0gPSBhLmRhdGUuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgW2QyLCBtMl0gPSBiLmRhdGUuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKDIwMjQsIHBhcnNlSW50KG0xKSAtIDEsIHBhcnNlSW50KGQxKSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoMjAyNCwgcGFyc2VJbnQobTIpIC0gMSwgcGFyc2VJbnQoZDIpKS5nZXRUaW1lKCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FtcGFpZ24sXG4gICAgICAgIHRvdGFscyxcbiAgICAgICAgY2hhcnREYXRhLFxuICAgICAgICB0aWVyRGlzdHJpYnV0aW9uXG4gICAgICB9O1xuICAgIH0pLFxuXG4gIGdldFN1Ym1pdHRlZENhbXBhaWduOiB0LnByb2NlZHVyZVxuICAgIC5pbnB1dCh6Lm9iamVjdCh7IGlkOiB6LnN0cmluZygpIH0pKVxuICAgIC5xdWVyeShhc3luYyAoeyBpbnB1dCwgY3R4IH0pID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG5cbiAgICAgIGNvbnN0IGNhbXBhaWduID0gYXdhaXQgcHJpc21hLmNhbXBhaWduLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW5wdXQuaWQgfSxcbiAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgIF9jb3VudDoge1xuICAgICAgICAgICAgc2VsZWN0OiB7IHN1Ym1pc3Npb25zOiB0cnVlIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNvbmc6IHtcbiAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICB0aXRsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgY292ZXJJbWFnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgIHRpa3Rva1VybDogdHJ1ZSxcbiAgICAgICAgICAgICAgYXJ0aXN0OiB7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiB7IG5hbWU6IHRydWUsIGF2YXRhcjogdHJ1ZSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHN1Ym1pc3Npb25zOiB7XG4gICAgICAgICAgICB3aGVyZTogeyBjcmVhdG9ySWQ6IHVzZXJJZCB9LFxuICAgICAgICAgICAgdGFrZTogMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY2FtcGFpZ24gfHwgY2FtcGFpZ24uc3VibWlzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNVQk1JU1NJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBteVN1Ym1pc3Npb24gPSBjYW1wYWlnbi5zdWJtaXNzaW9uc1swXTtcbiAgICAgIGxldCBmaW5hbFN1Ym1pc3Npb24gPSBteVN1Ym1pc3Npb247XG5cbiAgICAgIC8vIFNtYXJ0IFJlZnJlc2g6IENoZWNrIGlmIHN0YWxlICg+IDYgaG91cnMpXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgbGFzdENoZWNrZWQgPSBteVN1Ym1pc3Npb24ubGFzdENoZWNrZWRBdCA/IG5ldyBEYXRlKG15U3VibWlzc2lvbi5sYXN0Q2hlY2tlZEF0KSA6IG5ldyBEYXRlKDApO1xuICAgICAgY29uc3QgZGlmZkhvdXJzID0gKG5vdy5nZXRUaW1lKCkgLSBsYXN0Q2hlY2tlZC5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwKTtcblxuICAgICAgaWYgKGRpZmZIb3VycyA+IDYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHRpa3Rva1NjcmFwZXIgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL3Rpa3Rvay1zY3JhcGVyXCIpO1xuICAgICAgICAgIGNvbnN0IHZpZGVvRGF0YSA9IGF3YWl0IHRpa3Rva1NjcmFwZXIudmVyaWZ5VmlkZW8obXlTdWJtaXNzaW9uLnRpa3Rva1VybCk7XG5cbiAgICAgICAgICBmaW5hbFN1Ym1pc3Npb24gPSBhd2FpdCBwcmlzbWEuc3VibWlzc2lvbi51cGRhdGUoe1xuICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IG15U3VibWlzc2lvbi5pZCB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBsYXN0Vmlld0NvdW50OiB2aWRlb0RhdGEudmlld3MsXG4gICAgICAgICAgICAgIGxhc3RMaWtlQ291bnQ6IHZpZGVvRGF0YS5saWtlcyxcbiAgICAgICAgICAgICAgbGFzdENvbW1lbnRDb3VudDogdmlkZW9EYXRhLmNvbW1lbnRzLFxuICAgICAgICAgICAgICBsYXN0U2hhcmVDb3VudDogdmlkZW9EYXRhLnNoYXJlcyxcbiAgICAgICAgICAgICAgbGFzdENoZWNrZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTbWFydCBSZWZyZXNoIEZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgICAgIC8vIEZhaWwgc2lsZW50bHkgYW5kIHNob3cgb2xkIGRhdGFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMaXZlIEFnZ3JlZ2F0aW9uXG4gICAgICBjb25zdCBhZ2dyZWdhdGlvbnMgPSBhd2FpdCBwcmlzbWEuc3VibWlzc2lvbi5hZ2dyZWdhdGUoe1xuICAgICAgICB3aGVyZTogeyBjYW1wYWlnbklkOiBpbnB1dC5pZCB9LFxuICAgICAgICBfc3VtOiB7XG4gICAgICAgICAgbGFzdFZpZXdDb3VudDogdHJ1ZSxcbiAgICAgICAgICBsYXN0TGlrZUNvdW50OiB0cnVlLFxuICAgICAgICAgIGxhc3RTaGFyZUNvdW50OiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB0b3RhbFZpZXdzID0gYWdncmVnYXRpb25zLl9zdW0ubGFzdFZpZXdDb3VudCB8fCAwO1xuICAgICAgY29uc3QgdG90YWxMaWtlcyA9IGFnZ3JlZ2F0aW9ucy5fc3VtLmxhc3RMaWtlQ291bnQgfHwgMDtcbiAgICAgIGNvbnN0IHRvdGFsU2hhcmVzID0gYWdncmVnYXRpb25zLl9zdW0ubGFzdFNoYXJlQ291bnQgfHwgMDtcbiAgICAgIGNvbnN0IHRvdGFsQ2FtcGFpZ25Qb2ludHMgPSAodG90YWxWaWV3cyAqIDAuMDEpICsgKHRvdGFsTGlrZXMgKiAwLjUpICsgKHRvdGFsU2hhcmVzICogMS4wKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FtcGFpZ24sXG4gICAgICAgIHN1Ym1pc3Npb246IGZpbmFsU3VibWlzc2lvbixcbiAgICAgICAgcG9vbFN0YXRzOiB7XG4gICAgICAgICAgdG90YWxDYW1wYWlnblBvaW50cyxcbiAgICAgICAgICB0b3RhbFZpZXdzLFxuICAgICAgICAgIHRvdGFsTGlrZXNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSxcbiAgdmFsaWRhdGVWaWRlbzogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgY2FtcGFpZ25JZDogei5zdHJpbmcoKSxcbiAgICAgIHRpa3Rva1VybDogei5zdHJpbmcoKS51cmwoKVxuICAgIH0pKVxuICAgIC5tdXRhdGlvbihhc3luYyAoeyBjdHgsIGlucHV0IH0pID0+IHtcbiAgICAgIGlmICghY3R4LnVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVOQVVUSE9SSVpFRFwiKTtcblxuICAgICAgY29uc3QgY2FtcGFpZ24gPSBhd2FpdCBwcmlzbWEuY2FtcGFpZ24uZmluZFVuaXF1ZSh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiBpbnB1dC5jYW1wYWlnbklkIH0sXG4gICAgICAgIGluY2x1ZGU6IHsgc29uZzogdHJ1ZSB9XG4gICAgICB9KTtcbiAgICAgIGlmICghY2FtcGFpZ24pIHRocm93IG5ldyBFcnJvcihcIkNBTVBBSUdOX05PVF9GT1VORFwiKTtcblxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogY3R4LnVzZXIuaWQgfSB9KTtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVVNFUl9OT1RfRk9VTkRcIik7XG5cbiAgICAgIGxldCB2aWRlb0RhdGE7XG4gICAgICB0cnkge1xuICAgICAgICB2aWRlb0RhdGEgPSBhd2FpdCB0aWt0b2tTY3JhcGVyLnZlcmlmeVZpZGVvKGlucHV0LnRpa3Rva1VybCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcnM6IFtgVmlkZW8gZG/En3J1bGFuYW1hZMSxOiAke2UubWVzc2FnZX1gXSxcbiAgICAgICAgICB2aWRlbzogbnVsbCxcbiAgICAgICAgICBjaGVja3M6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgLy8gMS4gQWNjb3VudCBDaGVja1xuICAgICAgbGV0IGlzQWNjb3VudE1hdGNoID0gZmFsc2U7XG4gICAgICBpZiAodXNlci50aWt0b2tIYW5kbGUpIHtcbiAgICAgICAgaXNBY2NvdW50TWF0Y2ggPSB2aWRlb0RhdGEuY3JlYXRvclVzZXJuYW1lPy50b0xvd2VyQ2FzZSgpID09PSB1c2VyLnRpa3Rva0hhbmRsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIWlzQWNjb3VudE1hdGNoKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goYEhlc2FwIFV5dcWfbWF6bMSxxJ/EsTogVmlkZW8gQCR7dmlkZW9EYXRhLmNyZWF0b3JVc2VybmFtZX0gYWl0LCBUaWtQYXkgaGVzYWLEsW4gQCR7dXNlci50aWt0b2tIYW5kbGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKFwiUHJvZmlsaW5kZSBUaWtUb2sga3VsbGFuxLFjxLEgYWTEsSB0YW7EsW1sxLEgZGXEn2lsLiBMw7x0ZmVuIHByb2ZpbGluZGVuIGVrbGUuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBTb25nIENoZWNrXG4gICAgICBjb25zdCBtdXNpY0lkTWF0Y2ggPSBjYW1wYWlnbi5zb25nLnRpa3Rva011c2ljSWQgJiYgdmlkZW9EYXRhLnNvdW5kSWQgPT09IGNhbXBhaWduLnNvbmcudGlrdG9rTXVzaWNJZDtcbiAgICAgIGNvbnN0IHRpdGxlTWF0Y2ggPSB0aWt0b2tTY3JhcGVyLnZlcmlmeVNvbmcodmlkZW9EYXRhLCBjYW1wYWlnbi5zb25nLnRpdGxlKTtcbiAgICAgIGNvbnN0IGlzU29uZ01hdGNoID0gISEobXVzaWNJZE1hdGNoIHx8IHRpdGxlTWF0Y2gpO1xuXG4gICAgICBpZiAoIWlzU29uZ01hdGNoKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGBNw7x6aWsgRcWfbGXFn21lZGk6IEthbXBhbnlhIMWfYXJrxLFzxLEgXCIke2NhbXBhaWduLnNvbmcudGl0bGV9XCIgdmlkZW9kYSBidWx1bmFtYWTEsS5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gMy4gUmVxdWlyZW1lbnRzXG4gICAgICBjb25zdCBkdXJhdGlvbk1hdGNoID0gIWNhbXBhaWduLm1pblZpZGVvRHVyYXRpb24gfHwgdmlkZW9EYXRhLmR1cmF0aW9uID49IGNhbXBhaWduLm1pblZpZGVvRHVyYXRpb247XG4gICAgICBpZiAoIWR1cmF0aW9uTWF0Y2gpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYFPDvHJlIFlldGVyc2l6OiBWaWRlbyAke3ZpZGVvRGF0YS5kdXJhdGlvbn1zbiAoTWluOiAke2NhbXBhaWduLm1pblZpZGVvRHVyYXRpb259c24pYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvbGxvd2VyTWF0Y2ggPSAhY2FtcGFpZ24ubWluRm9sbG93ZXJzIHx8ICh2aWRlb0RhdGEuY3JlYXRvckZvbGxvd2VycyB8fCAwKSA+PSBjYW1wYWlnbi5taW5Gb2xsb3dlcnM7XG4gICAgICBpZiAoIWZvbGxvd2VyTWF0Y2gpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYFRha2lww6dpIFlldGVyc2l6OiAke3ZpZGVvRGF0YS5jcmVhdG9yRm9sbG93ZXJzfSB0YWtpcMOnaSAoTWluOiAke2NhbXBhaWduLm1pbkZvbGxvd2Vyc30pYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgdmlkZW86IHZpZGVvRGF0YSxcbiAgICAgICAgY2hlY2tzOiB7XG4gICAgICAgICAgYWNjb3VudE1hdGNoOiBpc0FjY291bnRNYXRjaCxcbiAgICAgICAgICBzb25nTWF0Y2g6IGlzU29uZ01hdGNoLFxuICAgICAgICAgIGR1cmF0aW9uTWF0Y2gsXG4gICAgICAgICAgZm9sbG93ZXJNYXRjaFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pLFxuXG4gIHN1Ym1pdFZpZGVvOiB0LnByb2NlZHVyZVxuICAgIC5pbnB1dCh6Lm9iamVjdCh7XG4gICAgICBjYW1wYWlnbklkOiB6LnN0cmluZygpLFxuICAgICAgdGlrdG9rVXJsOiB6LnN0cmluZygpLnVybCgpXG4gICAgfSkpXG4gICAgLm11dGF0aW9uKGFzeW5jICh7IGlucHV0LCBjdHggfSkgPT4ge1xuICAgICAgLy8gVmFsaWRhdGUgdXNlciBpcyBsb2dnZWQgaW5cbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVOQVVUSE9SSVpFRFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogdXNlcklkIH0sXG4gICAgICAgIHNlbGVjdDogeyBwbGFuOiB0cnVlLCBjeWNsZVN0YXJ0RGF0ZTogdHJ1ZSwgY3JlYXRvclRpZXI6IHRydWUgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVVNFUl9OT1RfRk9VTkRcIik7XG5cbiAgICAgIC8vIENoZWNrIEZyZWUgUGxhbiBMaW1pdHMgKDUgc3VibWlzc2lvbnMgLyAzMCBkYXlzKVxuICAgICAgaWYgKHVzZXIucGxhbiA9PT0gXCJGUkVFXCIpIHtcbiAgICAgICAgY29uc3QgY3ljbGVTdGFydCA9IHVzZXIuY3ljbGVTdGFydERhdGU7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IGRheXNJbkN5Y2xlID0gTWF0aC5mbG9vcigobm93LmdldFRpbWUoKSAtIGN5Y2xlU3RhcnQuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSk7XG5cbiAgICAgICAgaWYgKGRheXNJbkN5Y2xlID49IDMwKSB7XG4gICAgICAgICAgLy8gUmVzZXQgY3ljbGUgaWYgPiAzMCBkYXlzXG4gICAgICAgICAgYXdhaXQgcHJpc21hLnVzZXIudXBkYXRlKHtcbiAgICAgICAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgICAgICAgIGRhdGE6IHsgY3ljbGVTdGFydERhdGU6IG5vdyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ291bnQgc3VibWlzc2lvbnMgaW4gY3VycmVudCBjeWNsZVxuICAgICAgICAgIGNvbnN0IHN1Ym1pc3Npb25Db3VudCA9IGF3YWl0IHByaXNtYS5zdWJtaXNzaW9uLmNvdW50KHtcbiAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgIGNyZWF0b3JJZDogdXNlcklkLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IHtcbiAgICAgICAgICAgICAgICBndGU6IGN5Y2xlU3RhcnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHN1Ym1pc3Npb25Db3VudCA+PSA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQTEFOX0xJTUlUX1JFQUNIRURcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgc3VibWl0dGVkXG4gICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHByaXNtYS5zdWJtaXNzaW9uLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGNhbXBhaWduSWRfY3JlYXRvcklkOiB7XG4gICAgICAgICAgICBjYW1wYWlnbklkOiBpbnB1dC5jYW1wYWlnbklkLFxuICAgICAgICAgICAgY3JlYXRvcklkOiB1c2VySWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUxSRUFEWV9TVUJNSVRURURcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIENhbXBhaWduIFN0YXR1cyAmIExpbWl0c1xuICAgICAgY29uc3QgY2FtcGFpZ24gPSBhd2FpdCBwcmlzbWEuY2FtcGFpZ24uZmluZFVuaXF1ZSh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiBpbnB1dC5jYW1wYWlnbklkIH0sXG4gICAgICAgIGluY2x1ZGU6IHtcbiAgICAgICAgICBfY291bnQ6IHsgc2VsZWN0OiB7IHN1Ym1pc3Npb25zOiB0cnVlIH0gfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjYW1wYWlnbikgdGhyb3cgbmV3IEVycm9yKFwiQ0FNUEFJR05fTk9UX0ZPVU5EXCIpO1xuICAgICAgaWYgKGNhbXBhaWduLnN0YXR1cyAhPT0gXCJBQ1RJVkVcIikgdGhyb3cgbmV3IEVycm9yKFwiQ0FNUEFJR05fTk9UX0FDVElWRVwiKTtcblxuICAgICAgLy8gQ2hlY2sgdGllciBlbGlnaWJpbGl0eSAtIGNyZWF0b3JzIGNhbiBvbmx5IGpvaW4gY2FtcGFpZ25zIGF0IHRoZWlyIHRpZXIgb3IgbG93ZXJcbiAgICAgIGlmICghaXNDcmVhdG9yRWxpZ2libGVGb3JDYW1wYWlnbih1c2VyLmNyZWF0b3JUaWVyLCBjYW1wYWlnbi50aWVyKSkge1xuICAgICAgICBjb25zdCB0aWVyTmFtZXMgPSB7IEQ6ICdEJywgQzogJ0MgKDwxayB0YWtpcMOnaSknLCBCOiAnQiAoMWstM2spJywgQTogJ0EgKDNrLTVrKScsIFM6ICdTICg1ayspJyB9O1xuICAgICAgICBjb25zdCByZXF1aXJlZFRpZXIgPSB0aWVyTmFtZXNbY2FtcGFpZ24udGllcl0gfHwgY2FtcGFpZ24udGllcjtcbiAgICAgICAgY29uc3QgdXNlclRpZXIgPSB1c2VyLmNyZWF0b3JUaWVyID8gdGllck5hbWVzW3VzZXIuY3JlYXRvclRpZXJdIDogJ1lvayc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVElFUl9OT1RfRUxJR0lCTEU6IEJ1IGthbXBhbnlhICR7cmVxdWlyZWRUaWVyfSB0aWVyIGdlcmVrdGlyaXlvci4gU2VuaW4gdGllcidpbjogJHt1c2VyVGllcn0uIFRpa1RvayBoZXNhYsSxbsSxIGJhxJ9sYXnEsXAgdGFraXDDp2kgc2F5xLFuxLEgZG/En3J1bGFtYW4gZ2VyZWtpci5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbXBhaWduLl9jb3VudC5zdWJtaXNzaW9ucyA+PSBjYW1wYWlnbi5tYXhTdWJtaXNzaW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQU1QQUlHTl9GVUxMXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyAxLiBWZXJpZnkgVmlkZW8gd2l0aCBUaWtBUEkgKG1vY2tlZCBmb3Igbm93IGlmIEFQSSBrZXkgbWlzc2luZylcbiAgICAgIC8vIFdlIGltcG9ydCBkeW5hbWljYWxseSB0byBhdm9pZCBpc3N1ZXMgaWYgbm90IHVzZWQgZWxzZXdoZXJlXG4gICAgICBjb25zdCB7IHRpa3Rva1NjcmFwZXIgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL3Rpa3Rvay1zY3JhcGVyXCIpO1xuXG4gICAgICBsZXQgdmlkZW9EYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmlkZW9EYXRhID0gYXdhaXQgdGlrdG9rU2NyYXBlci52ZXJpZnlWaWRlbyhpbnB1dC50aWt0b2tVcmwpO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSU5WQUxJRF9WSURFTzogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDIuIENyZWF0ZSBTdWJtaXNzaW9uXG4gICAgICBjb25zdCBzdWJtaXNzaW9uID0gYXdhaXQgcHJpc21hLnN1Ym1pc3Npb24uY3JlYXRlKHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGNhbXBhaWduSWQ6IGlucHV0LmNhbXBhaWduSWQsXG4gICAgICAgICAgY3JlYXRvcklkOiB1c2VySWQsXG4gICAgICAgICAgdGlrdG9rVXJsOiBpbnB1dC50aWt0b2tVcmwsXG4gICAgICAgICAgdGlrdG9rVmlkZW9JZDogdmlkZW9EYXRhLnZpZGVvSWQsXG4gICAgICAgICAgc3RhdHVzOiBcIkFQUFJPVkVEXCIsIC8vIEF1dG8tYXBwcm92ZSBzaW5jZSB2aWRlbyBwYXNzZWQgdmFsaWRhdGlvblxuICAgICAgICAgIC8vIEluaXRpYWwgc3RhdHNcbiAgICAgICAgICBsYXN0Vmlld0NvdW50OiB2aWRlb0RhdGEudmlld3MsXG4gICAgICAgICAgbGFzdExpa2VDb3VudDogdmlkZW9EYXRhLmxpa2VzLFxuICAgICAgICAgIGxhc3RDb21tZW50Q291bnQ6IHZpZGVvRGF0YS5jb21tZW50cyxcbiAgICAgICAgICBsYXN0U2hhcmVDb3VudDogdmlkZW9EYXRhLnNoYXJlcyxcbiAgICAgICAgICB2aWRlb0R1cmF0aW9uOiB2aWRlb0RhdGEuZHVyYXRpb24sXG4gICAgICAgICAgY3JlYXRvckZvbGxvd2VyczogdmlkZW9EYXRhLmNyZWF0b3JGb2xsb3dlcnMsXG4gICAgICAgICAgbGFzdENoZWNrZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyAzLiBUcmlnZ2VyIGJhY2tlbmQgY2FsY3VsYXRpb25zIGltbWVkaWF0ZWx5XG4gICAgICBjb25zdCB7IG9uU3VibWlzc2lvblN0YXRzVXBkYXRlIH0gPSBhd2FpdCBpbXBvcnQoJ0Avc2VydmVyL3NlcnZpY2VzL3N1Ym1pc3Npb25Ib29rcycpO1xuICAgICAgYXdhaXQgb25TdWJtaXNzaW9uU3RhdHNVcGRhdGUoc3VibWlzc2lvbi5pZCwgcHJpc21hKTtcblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgc3VibWlzc2lvbklkOiBzdWJtaXNzaW9uLmlkIH07XG4gICAgfSksXG5cbiAgZGVsZXRlU3VibWlzc2lvbjogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgc3VibWlzc2lvbklkOiB6LnN0cmluZygpXG4gICAgfSkpXG4gICAgLm11dGF0aW9uKGFzeW5jICh7IGlucHV0LCBjdHggfSkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gY3R4LnVzZXI/LmlkO1xuICAgICAgaWYgKCF1c2VySWQpIHRocm93IG5ldyBFcnJvcihcIlVOQVVUSE9SSVpFRFwiKTtcblxuICAgICAgLy8gMS4gVmVyaWZ5IG93bmVyc2hpcFxuICAgICAgY29uc3Qgc3VibWlzc2lvbiA9IGF3YWl0IHByaXNtYS5zdWJtaXNzaW9uLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW5wdXQuc3VibWlzc2lvbklkIH0sXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGNyZWF0b3JJZDogdHJ1ZSxcbiAgICAgICAgICBjYW1wYWlnbklkOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzdWJtaXNzaW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJTVUJNSVNTSU9OX05PVF9GT1VORFwiKTtcbiAgICAgIGlmIChzdWJtaXNzaW9uLmNyZWF0b3JJZCAhPT0gdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG5cbiAgICAgIC8vIDIuIERvbid0IGFsbG93IGRlbGV0aW9uIG9mIGFwcHJvdmVkIHN1Ym1pc3Npb25zIChvcHRpb25hbCAtIHlvdSBjYW4gcmVtb3ZlIHRoaXMgY2hlY2spXG4gICAgICBpZiAoc3VibWlzc2lvbi5zdGF0dXMgPT09IFwiQVBQUk9WRURcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQU5OT1RfREVMRVRFX0FQUFJPVkVEX1NVQk1JU1NJT05cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIGNhbXBhaWduIElEIGJlZm9yZSBkZWxldGlvblxuICAgICAgY29uc3QgY2FtcGFpZ25JZCA9IHN1Ym1pc3Npb24uY2FtcGFpZ25JZDtcblxuICAgICAgLy8gMy4gRGVsZXRlIHRoZSBzdWJtaXNzaW9uXG4gICAgICBhd2FpdCBwcmlzbWEuc3VibWlzc2lvbi5kZWxldGUoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW5wdXQuc3VibWlzc2lvbklkIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyA0LiBSZWNhbGN1bGF0ZSBjYW1wYWlnbiBzdGF0cyAodG8gdXBkYXRlIHRvdGFsIHBvaW50cyBhbmQgb3RoZXIgc3VibWlzc2lvbnMnIHNoYXJlIHBlcmNlbnRhZ2VzKVxuICAgICAgY29uc3QgeyBDYWxjdWxhdGlvblNlcnZpY2UgfSA9IGF3YWl0IGltcG9ydCgnQC9zZXJ2ZXIvc2VydmljZXMvY2FsY3VsYXRpb25TZXJ2aWNlJyk7XG4gICAgICBhd2FpdCBDYWxjdWxhdGlvblNlcnZpY2UudXBkYXRlQ2FtcGFpZ25Ub3RhbFBvaW50cyhjYW1wYWlnbklkLCBwcmlzbWEpO1xuICAgICAgYXdhaXQgQ2FsY3VsYXRpb25TZXJ2aWNlLnJlY2FsY3VsYXRlQ2FtcGFpZ25TdWJtaXNzaW9ucyhjYW1wYWlnbklkLCBwcmlzbWEpO1xuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSksXG5cbiAgY3JlYXRlQ2FtcGFpZ246IHQucHJvY2VkdXJlXG4gICAgLmlucHV0KHoub2JqZWN0KHtcbiAgICAgIHRpa3Rva1VybDogei5zdHJpbmcoKS51cmwoKSxcbiAgICAgIHRpdGxlOiB6LnN0cmluZygpLm1pbigxKSxcbiAgICAgIGRlc2NyaXB0aW9uOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICBidWRnZXQ6IHoubnVtYmVyKCkubWluKDE1MDAwMCksIC8vIE1pbmltdW0gMTUsMDAwIFRMIGJ1ZGdldCAoaW4gVFA6IDE1MCwwMDApXG4gICAgICBtaW5WaWRlb0R1cmF0aW9uOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgICBzdGFydERhdGU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgIGVuZERhdGU6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KSlcbiAgICAubXV0YXRpb24oYXN5bmMgKHsgaW5wdXQsIGN0eCB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBjdHgudXNlcj8uaWQ7XG4gICAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEltcG9ydCB0aWVyIHV0aWxpdGllc1xuICAgICAgY29uc3QgeyBnZXRDYW1wYWlnblRpZXJGcm9tQnVkZ2V0LCBnZXRNaW5Gb2xsb3dlcnNGb3JUaWVyLCBnZXRNYXhTdWJtaXNzaW9uc0Zyb21CdWRnZXQgfSA9XG4gICAgICAgIGF3YWl0IGltcG9ydChcIkAvc2VydmVyL2xpYi90aWVyVXRpbHNcIik7XG5cbiAgICAgIC8vIDEuIEZldGNoIFNvbmcgRGF0YSBmcm9tIFRpa1RvayAodXNpbmcgc2hhcmVkIHNjcmFwZXIpXG4gICAgICBjb25zdCB7IHRpa3Rva1NjcmFwZXIgfSA9IGF3YWl0IGltcG9ydChcIkAvbGliL3Rpa3Rvay1zY3JhcGVyXCIpO1xuXG4gICAgICBsZXQgc29uZ0RhdGE7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGZldGNoZXMgc29uZyBtZXRhZGF0YSAodGl0bGUsIGFydGlzdCwgY292ZXIpXG4gICAgICAgIHNvbmdEYXRhID0gYXdhaXQgdGlrdG9rU2NyYXBlci5mZXRjaFNvbmdEZXRhaWxzKGlucHV0LnRpa3Rva1VybCk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJTlZBTElEX1NPVU5EOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gRmluZCBvciBDcmVhdGUgU29uZ1xuICAgICAgbGV0IHNvbmcgPSBhd2FpdCBwcmlzbWEuc29uZy5maW5kRmlyc3Qoe1xuICAgICAgICB3aGVyZTogeyB0aWt0b2tVcmw6IGlucHV0LnRpa3Rva1VybCB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFzb25nKSB7XG4gICAgICAgIHNvbmcgPSBhd2FpdCBwcmlzbWEuc29uZy5jcmVhdGUoe1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRpdGxlOiBzb25nRGF0YS50aXRsZSxcbiAgICAgICAgICAgIHRpa3Rva1VybDogaW5wdXQudGlrdG9rVXJsLFxuICAgICAgICAgICAgZHVyYXRpb246IHNvbmdEYXRhLmR1cmF0aW9uLFxuICAgICAgICAgICAgY292ZXJJbWFnZTogc29uZ0RhdGEuY292ZXJJbWFnZSxcbiAgICAgICAgICAgIGFydGlzdElkOiB1c2VySWQsXG4gICAgICAgICAgICBhdXRob3JOYW1lOiBzb25nRGF0YS5hdXRob3JOYW1lLFxuICAgICAgICAgICAgc3RhdHNMYXN0RmV0Y2hlZDogbmV3IERhdGUoKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgZGF0ZXNcbiAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IGlucHV0LnN0YXJ0RGF0ZSA/IG5ldyBEYXRlKGlucHV0LnN0YXJ0RGF0ZSkgOiBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IGlucHV0LmVuZERhdGUgPyBuZXcgRGF0ZShpbnB1dC5lbmREYXRlKSA6IG5ldyBEYXRlKERhdGUubm93KCkgKyAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApO1xuXG4gICAgICAvLyAzLiBDYWxjdWxhdGUgdGllci1iYXNlZCB2YWx1ZXNcbiAgICAgIGNvbnN0IGJ1ZGdldFRQID0gaW5wdXQuYnVkZ2V0O1xuICAgICAgY29uc3QgYnVkZ2V0VEwgPSBidWRnZXRUUCAvIDEwOyAvLyAxMCBUUCA9IDEgVEwgQ29udmVyc2lvblxuXG4gICAgICAvLyBDYWxjdWxhdGUgY2FtcGFpZ24gdGllciBhbmQgYXV0by1zZXQgcmVxdWlyZW1lbnRzXG4gICAgICBjb25zdCBjYW1wYWlnblRpZXIgPSBnZXRDYW1wYWlnblRpZXJGcm9tQnVkZ2V0KGJ1ZGdldFRMKTtcbiAgICAgIGNvbnN0IG1pbkZvbGxvd2VycyA9IGdldE1pbkZvbGxvd2Vyc0ZvclRpZXIoY2FtcGFpZ25UaWVyKTtcbiAgICAgIGNvbnN0IG1heFN1Ym1pc3Npb25zID0gZ2V0TWF4U3VibWlzc2lvbnNGcm9tQnVkZ2V0KGJ1ZGdldFRMKTtcblxuICAgICAgLy8gNC4gRGVkdWN0aW9uICYgQ3JlYXRpb24gKFRyYW5zYWN0aW9uKVxuICAgICAgY29uc3QgY2FtcGFpZ24gPSBhd2FpdCBwcmlzbWEuJHRyYW5zYWN0aW9uKGFzeW5jICh0eCkgPT4ge1xuICAgICAgICAvLyBDaGVjayBCYWxhbmNlXG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0eC51c2VyLmZpbmRVbmlxdWUoeyB3aGVyZTogeyBpZDogdXNlcklkIH0gfSk7XG4gICAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVVNFUl9OT1RfRk9VTkRcIik7XG5cbiAgICAgICAgaWYgKE51bWJlcih1c2VyLmJhbGFuY2UpIDwgYnVkZ2V0VEwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlNVRkZJQ0lFTlRfQkFMQU5DRVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZHVjdCBmcm9tIFdhbGxldFxuICAgICAgICBhd2FpdCB0eC51c2VyLnVwZGF0ZSh7XG4gICAgICAgICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9LFxuICAgICAgICAgIGRhdGE6IHsgYmFsYW5jZTogeyBkZWNyZW1lbnQ6IGJ1ZGdldFRMIH0gfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWNvcmQgU3BlbmRpbmcgVHJhbnNhY3Rpb25cbiAgICAgICAgYXdhaXQgdHgudHJhbnNhY3Rpb24uY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICB0eXBlOiBcIlNQRU5EXCIsXG4gICAgICAgICAgICBhbW91bnQ6IGJ1ZGdldFRMLFxuICAgICAgICAgICAgc3RhdHVzOiBcIkNPTVBMRVRFRFwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBLYW1wYW55YSBPbHXFn3R1cm1hOiAke2lucHV0LnRpdGxlfWBcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBDYW1wYWlnbiB3aXRoIHRpZXJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHR4LmNhbXBhaWduLmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGl0bGU6IGlucHV0LnRpdGxlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGlucHV0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgdG90YWxCdWRnZXQ6IGJ1ZGdldFRMLCAvLyBTdG9yZSBhcyBUTFxuICAgICAgICAgICAgcmVtYWluaW5nQnVkZ2V0OiBidWRnZXRUTCxcbiAgICAgICAgICAgIHN0YXR1czogXCJQRU5ESU5HX0FQUFJPVkFMXCIsIC8vIFJlcXVpcmUgYWRtaW4gYXBwcm92YWxcbiAgICAgICAgICAgIHRpZXI6IGNhbXBhaWduVGllciwgLy8gQXV0by1jYWxjdWxhdGVkIHRpZXJcbiAgICAgICAgICAgIHNvbmdJZDogc29uZy5pZCxcbiAgICAgICAgICAgIGFydGlzdElkOiB1c2VySWQsXG4gICAgICAgICAgICBtaW5Gb2xsb3dlcnM6IG1pbkZvbGxvd2VycywgLy8gQXV0by1jYWxjdWxhdGVkIGZyb20gdGllclxuICAgICAgICAgICAgbWluVmlkZW9EdXJhdGlvbjogaW5wdXQubWluVmlkZW9EdXJhdGlvbixcbiAgICAgICAgICAgIG1heFN1Ym1pc3Npb25zOiBtYXhTdWJtaXNzaW9ucywgLy8gQXV0by1jYWxjdWxhdGVkIGZyb20gYnVkZ2V0XG4gICAgICAgICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIGVuZERhdGU6IGVuZERhdGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGNhbXBhaWduSWQ6IGNhbXBhaWduLmlkIH07XG4gICAgfSksXG5cbiAgZ2V0TXlDYW1wYWlnbnM6IHQucHJvY2VkdXJlXG4gICAgLmlucHV0KHoub2JqZWN0KHtcbiAgICAgIGN1cnNvcjogei5zdHJpbmcoKS5vcHRpb25hbCgpLCAvLyBDYW1wYWlnbiBJRCBmb3IgY3Vyc29yLWJhc2VkIHBhZ2luYXRpb25cbiAgICAgIGxpbWl0OiB6Lm51bWJlcigpLm1pbigxKS5tYXgoMTAwKS5kZWZhdWx0KDIwKSxcbiAgICAgIGVuZGVkT25seTogei5ib29sZWFuKCkub3B0aW9uYWwoKSAvLyBGaWx0ZXIgZm9yIGVuZGVkIGNhbXBhaWducyBvbmx5XG4gICAgfSkub3B0aW9uYWwoKSlcbiAgICAucXVlcnkoYXN5bmMgKHsgY3R4LCBpbnB1dCB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBjdHgudXNlcj8uaWQ7XG4gICAgICBpZiAoIXVzZXJJZCkgcmV0dXJuIHsgY2FtcGFpZ25zOiBbXSwgbmV4dEN1cnNvcjogbnVsbCB9O1xuXG4gICAgICBjb25zdCBsaW1pdCA9IGlucHV0Py5saW1pdCB8fCAyMDtcbiAgICAgIGNvbnN0IGVuZGVkT25seSA9IGlucHV0Py5lbmRlZE9ubHkgfHwgZmFsc2U7XG5cbiAgICAgIGNvbnN0IHdoZXJlOiBhbnkgPSB7IGFydGlzdElkOiB1c2VySWQgfTtcblxuICAgICAgLy8gRmlsdGVyIGZvciBlbmRlZCBjYW1wYWlnbnMgaWYgcmVxdWVzdGVkXG4gICAgICBpZiAoZW5kZWRPbmx5KSB7XG4gICAgICAgIHdoZXJlLk9SID0gW1xuICAgICAgICAgIHsgc3RhdHVzOiAnQ09NUExFVEVEJyB9LFxuICAgICAgICAgIHsgZW5kRGF0ZTogeyBsdDogbmV3IERhdGUoKSB9IH1cbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3Vyc29yLWJhc2VkIHBhZ2luYXRpb25cbiAgICAgIGlmIChpbnB1dD8uY3Vyc29yKSB7XG4gICAgICAgIHdoZXJlLmlkID0geyBsdDogaW5wdXQuY3Vyc29yIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbXBhaWducyA9IGF3YWl0IHByaXNtYS5jYW1wYWlnbi5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlLFxuICAgICAgICB0YWtlOiBsaW1pdCArIDEsIC8vIEZldGNoIG9uZSBleHRyYSB0byBkZXRlcm1pbmUgaWYgdGhlcmUgYXJlIG1vcmVcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgdGl0bGU6IHRydWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRydWUsXG4gICAgICAgICAgc3RhdHVzOiB0cnVlLFxuICAgICAgICAgIHRpZXI6IHRydWUsXG4gICAgICAgICAgdG90YWxCdWRnZXQ6IHRydWUsXG4gICAgICAgICAgbWF4U3VibWlzc2lvbnM6IHRydWUsXG4gICAgICAgICAgc3RhcnREYXRlOiB0cnVlLFxuICAgICAgICAgIGVuZERhdGU6IHRydWUsXG4gICAgICAgICAgbWluRm9sbG93ZXJzOiB0cnVlLFxuICAgICAgICAgIHBsYXRmb3JtRmVlUGVyY2VudDogdHJ1ZSxcbiAgICAgICAgICBzYWZldHlSZXNlcnZlUGVyY2VudDogdHJ1ZSxcbiAgICAgICAgICBhcnRpc3RJZDogdHJ1ZSxcbiAgICAgICAgICBzb25nOiB7XG4gICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgdGl0bGU6IHRydWUsXG4gICAgICAgICAgICAgIGNvdmVySW1hZ2U6IHRydWUsXG4gICAgICAgICAgICAgIGF1dGhvck5hbWU6IHRydWUsXG4gICAgICAgICAgICAgIGFydGlzdDogeyBzZWxlY3Q6IHsgbmFtZTogdHJ1ZSB9IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvb2xTdGF0czoge1xuICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgIHRvdGFsQ2FtcGFpZ25Qb2ludHM6IHRydWUsXG4gICAgICAgICAgICAgIHRvdGFsU3VibWlzc2lvbnM6IHRydWUsXG4gICAgICAgICAgICAgIGF2ZXJhZ2VQb2ludHM6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIF9jb3VudDogeyBzZWxlY3Q6IHsgc3VibWlzc2lvbnM6IHRydWUgfSB9XG4gICAgICAgIH0sXG4gICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIG1vcmUgcmVzdWx0c1xuICAgICAgY29uc3QgaGFzTW9yZSA9IGNhbXBhaWducy5sZW5ndGggPiBsaW1pdDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGhhc01vcmUgPyBjYW1wYWlnbnMuc2xpY2UoMCwgbGltaXQpIDogY2FtcGFpZ25zO1xuICAgICAgY29uc3QgbmV4dEN1cnNvciA9IGhhc01vcmUgPyByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLmlkIDogbnVsbDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FtcGFpZ25zOiByZXN1bHQsXG4gICAgICAgIG5leHRDdXJzb3JcbiAgICAgIH07XG4gICAgfSksXG5cbiAgZ2V0Q3JlYXRvclN0YXRzOiB0LnByb2NlZHVyZVxuICAgIC5xdWVyeShhc3luYyAoeyBjdHggfSkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gY3R4LnVzZXI/LmlkO1xuICAgICAgaWYgKCF1c2VySWQpIHRocm93IG5ldyBFcnJvcihcIlVOQVVUSE9SSVpFRFwiKTtcblxuICAgICAgLy8gRmV0Y2ggdXNlciBpbmZvIGZvciB0aWVyLCBmb2xsb3dlciBjb3VudCwgYW5kIHBsYW5cbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kVW5pcXVlKHtcbiAgICAgICAgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9LFxuICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICBjcmVhdG9yVGllcjogdHJ1ZSxcbiAgICAgICAgICBmb2xsb3dlckNvdW50OiB0cnVlLFxuICAgICAgICAgIHBsYW46IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE9QVElNSVpFRDogVXNlIHNlbGVjdCBpbnN0ZWFkIG9mIGluY2x1ZGUgdG8gZmV0Y2ggb25seSBuZWVkZWQgZmllbGRzXG4gICAgICAvLyBFbGltaW5hdGVzIGRlZXAgbmVzdGluZyBhbmQgcmVkdWNlcyBxdWVyeSB0aW1lIGJ5IDQwLTYwJVxuICAgICAgY29uc3Qgc3VibWlzc2lvbnMgPSBhd2FpdCBwcmlzbWEuc3VibWlzc2lvbi5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlOiB7IGNyZWF0b3JJZDogdXNlcklkIH0sXG4gICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgIGlkOiB0cnVlLFxuICAgICAgICAgIHN0YXR1czogdHJ1ZSxcbiAgICAgICAgICB0b3RhbEVhcm5pbmdzOiB0cnVlLFxuICAgICAgICAgIGVzdGltYXRlZEVhcm5pbmdzOiB0cnVlLFxuICAgICAgICAgIGxhc3RWaWV3Q291bnQ6IHRydWUsXG4gICAgICAgICAgc2hhcmVQZXJjZW50OiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRBdDogdHJ1ZSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IHRydWUsXG4gICAgICAgICAgLy8gT25seSBzZWxlY3QgbmVlZGVkIGNhbXBhaWduIGZpZWxkc1xuICAgICAgICAgIGNhbXBhaWduOiB7XG4gICAgICAgICAgICBzZWxlY3Q6IHtcbiAgICAgICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgICAgIHN0YXR1czogdHJ1ZSxcbiAgICAgICAgICAgICAgZW5kRGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgc29uZzoge1xuICAgICAgICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQWdncmVnYXRlIGNhbGN1bGF0aW9ucyAtIHNlcGFyYXRlIGVuZGVkIHZzIGFjdGl2ZSBjYW1wYWlnbnNcbiAgICAgIC8vIEZJWEVEOiB0b3RhbEVhcm5pbmdzIChUb3BsYW0pID0gc3VtIG9mIGZpbmFsaXplZCBlYXJuaW5ncyBmcm9tIEVOREVEIGNhbXBhaWducyBvbmx5XG4gICAgICBjb25zdCB0b3RhbEVhcm5pbmdzID0gc3VibWlzc2lvbnNcbiAgICAgICAgLmZpbHRlcihzID0+IHtcbiAgICAgICAgICBpZiAoIXMuY2FtcGFpZ24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAvLyBDYW1wYWlnbiBpcyBlbmRlZCBpZiBzdGF0dXMgaXMgQ09NUExFVEVEIE9SIGVuZERhdGUgaGFzIHBhc3NlZFxuICAgICAgICAgIGNvbnN0IGNhbXBhaWduRW5kZWQgPSBzLmNhbXBhaWduLnN0YXR1cyA9PT0gJ0NPTVBMRVRFRCcgfHwgbmV3IERhdGUocy5jYW1wYWlnbi5lbmREYXRlKSA8IG5ldyBEYXRlKCk7XG4gICAgICAgICAgcmV0dXJuIGNhbXBhaWduRW5kZWQ7IC8vIE9ubHkgZW5kZWQgY2FtcGFpZ25zXG4gICAgICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgTnVtYmVyKHMudG90YWxFYXJuaW5ncyksIDApO1xuXG4gICAgICAvLyBGSVhFRDogZXN0aW1hdGVkRWFybmluZ3MgKFRhaG1pbmkpID0gc3VtIG9mIGVzdGltYXRlZCBlYXJuaW5ncyBmcm9tIEFDVElWRSBjYW1wYWlnbnMgb25seVxuICAgICAgY29uc3QgZXN0aW1hdGVkRWFybmluZ3MgPSBzdWJtaXNzaW9uc1xuICAgICAgICAuZmlsdGVyKHMgPT4ge1xuICAgICAgICAgIGlmICghcy5jYW1wYWlnbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIC8vIENhbXBhaWduIGlzIGVuZGVkIGlmIHN0YXR1cyBpcyBDT01QTEVURUQgT1IgZW5kRGF0ZSBoYXMgcGFzc2VkXG4gICAgICAgICAgY29uc3QgY2FtcGFpZ25FbmRlZCA9IHMuY2FtcGFpZ24uc3RhdHVzID09PSAnQ09NUExFVEVEJyB8fCBuZXcgRGF0ZShzLmNhbXBhaWduLmVuZERhdGUpIDwgbmV3IERhdGUoKTtcbiAgICAgICAgICByZXR1cm4gIWNhbXBhaWduRW5kZWQ7IC8vIE9ubHkgYWN0aXZlIGNhbXBhaWduc1xuICAgICAgICB9KVxuICAgICAgICAucmVkdWNlKChzdW0sIHMpID0+IHN1bSArIE51bWJlcihzLmVzdGltYXRlZEVhcm5pbmdzKSwgMCk7XG5cbiAgICAgIGNvbnN0IHRvdGFsVmlld3MgPSBzdWJtaXNzaW9ucy5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgKHMubGFzdFZpZXdDb3VudCB8fCAwKSwgMCk7XG5cbiAgICAgIC8vIFVQREFURUQ6IEFjdGl2ZSB2aWRlb3MgY291bnQgLSBvbmx5IGFwcHJvdmVkIHN1Ym1pc3Npb25zIHdpdGggYWN0aXZlIChub3QgZW5kZWQpIGNhbXBhaWduc1xuICAgICAgY29uc3QgYWN0aXZlVmlkZW9zID0gc3VibWlzc2lvbnMuZmlsdGVyKHMgPT4ge1xuICAgICAgICBpZiAocy5zdGF0dXMgIT09IFwiQVBQUk9WRURcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXMuY2FtcGFpZ24pIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQ2FtcGFpZ24gaXMgZW5kZWQgaWYgc3RhdHVzIGlzIENPTVBMRVRFRCBPUiBlbmREYXRlIGhhcyBwYXNzZWRcbiAgICAgICAgY29uc3QgY2FtcGFpZ25FbmRlZCA9IHMuY2FtcGFpZ24uc3RhdHVzID09PSAnQ09NUExFVEVEJyB8fCBuZXcgRGF0ZShzLmNhbXBhaWduLmVuZERhdGUpIDwgbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuICFjYW1wYWlnbkVuZGVkOyAvLyBPbmx5IGNvdW50IGFjdGl2ZSBjYW1wYWlnbnNcbiAgICAgIH0pLmxlbmd0aDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIEF2ZXJhZ2UgQ29udHJpYnV0aW9uIFBlcmNlbnQgLSBPTkxZIGZvciBlbmRlZCBjYW1wYWlnbnNcbiAgICAgIC8vIE9QVElNSVpFRDogRmlsdGVyIGZyb20gYWxyZWFkeS1mZXRjaGVkIHN1Ym1pc3Npb25zIGluc3RlYWQgb2Ygc2VwYXJhdGUgcXVlcnlcbiAgICAgIGNvbnN0IGVuZGVkU3VibWlzc2lvbnMgPSBzdWJtaXNzaW9ucy5maWx0ZXIocyA9PiB7XG4gICAgICAgIGNvbnN0IGNhbXBhaWduID0gcy5jYW1wYWlnbjtcbiAgICAgICAgcmV0dXJuIGNhbXBhaWduICYmIChjYW1wYWlnbi5zdGF0dXMgPT09ICdDT01QTEVURUQnIHx8IG5ldyBEYXRlKGNhbXBhaWduLmVuZERhdGUpIDwgbmV3IERhdGUoKSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYXZnQ29udHJpYnV0aW9uUGVyY2VudCA9IGVuZGVkU3VibWlzc2lvbnMubGVuZ3RoID4gMFxuICAgICAgICA/IChlbmRlZFN1Ym1pc3Npb25zLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0gKyAocy5zaGFyZVBlcmNlbnQgfHwgMCksIDApIC8gZW5kZWRTdWJtaXNzaW9ucy5sZW5ndGgpICogMTAwIC8vIENvbnZlcnQgdG8gcGVyY2VudGFnZVxuICAgICAgICA6IDA7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBBdmVyYWdlIFZpZXdzIC0gT05MWSBmb3IgZW5kZWQgY2FtcGFpZ25zXG4gICAgICBjb25zdCBhdmdWaWV3cyA9IGVuZGVkU3VibWlzc2lvbnMubGVuZ3RoID4gMFxuICAgICAgICA/IE1hdGgucm91bmQoZW5kZWRTdWJtaXNzaW9ucy5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgKHMubGFzdFZpZXdDb3VudCB8fCAwKSwgMCkgLyBlbmRlZFN1Ym1pc3Npb25zLmxlbmd0aClcbiAgICAgICAgOiAwO1xuXG4gICAgICAvLyBGZXRjaCBSZWNlbnQgQWN0aXZpdHkgLSBTaG93IEVBUk5JTkcgYW5kIFNQRU5EIHRyYW5zYWN0aW9uc1xuICAgICAgY29uc3QgcmVjZW50VHJhbnNhY3Rpb25zID0gYXdhaXQgcHJpc21hLnRyYW5zYWN0aW9uLmZpbmRNYW55KHtcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgdHlwZTogeyBpbjogWydFQVJOSU5HJywgJ1NQRU5EJ10gfSAvLyBTaG93IGVhcm5pbmdzL3BheW91dHMgYW5kIHB1cmNoYXNlcy9zdWJzY3JpcHRpb25zXG4gICAgICAgIH0sXG4gICAgICAgIHRha2U6IDIwLFxuICAgICAgICBvcmRlckJ5OiB7IGNyZWF0ZWRBdDogXCJkZXNjXCIgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE9QVElNSVpFRDogVXNlIGFscmVhZHktZmV0Y2hlZCBzdWJtaXNzaW9ucyBpbnN0ZWFkIG9mIHNlcGFyYXRlIHF1ZXJ5XG4gICAgICAvLyBGaWx0ZXIgZm9yIGZpbmlzaGVkIGNhbXBhaWducyBmcm9tIHRoZSBzdWJtaXNzaW9ucyB3ZSBhbHJlYWR5IGhhdmVcbiAgICAgIGNvbnN0IGZpbmlzaGVkU3VibWlzc2lvbnMgPSBzdWJtaXNzaW9ucy5maWx0ZXIocyA9PlxuICAgICAgICBzLnN0YXR1cyA9PT0gJ0FQUFJPVkVEJyAmJlxuICAgICAgICBzLmNhbXBhaWduICYmXG4gICAgICAgIG5ldyBEYXRlKHMuY2FtcGFpZ24uZW5kRGF0ZSkgPCBuZXcgRGF0ZSgpXG4gICAgICApLnNsaWNlKDAsIDIwKTtcblxuICAgICAgY29uc3QgcmVjZW50QWN0aXZpdHkgPSBbXG4gICAgICAgIC8vIENhbXBhaWduIGVhcm5pbmdzIC0gb25seSBmcm9tIGZpbmlzaGVkIGNhbXBhaWduc1xuICAgICAgICAuLi5maW5pc2hlZFN1Ym1pc3Npb25zLm1hcChzID0+ICh7XG4gICAgICAgICAgaWQ6IHMuaWQsXG4gICAgICAgICAgdHlwZTogJ0NBTVBBSUdOJyxcbiAgICAgICAgICBhbW91bnQ6IChOdW1iZXIocy5lc3RpbWF0ZWRFYXJuaW5ncykgfHwgMCkgKiAxMCwgLy8gQ29udmVydCBEZWNpbWFsIHRvIE51bWJlciwgdGhlbiBUTCB0byBUUFxuICAgICAgICAgIGRhdGU6IHMudXBkYXRlZEF0LCAvLyBVc2UgdXBkYXRlZEF0IGZvciB3aGVuIGl0IHdhcyBmaW5hbGl6ZWRcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7cy5jYW1wYWlnbj8uc29uZz8udGl0bGUgfHwgJ0thbXBhbnlhJ30gLSBLYXphbsOnYCxcbiAgICAgICAgICBzdGF0dXM6ICdDT01QTEVURUQnLFxuICAgICAgICAgIGlzUGx1czogdHJ1ZVxuICAgICAgICB9KSksXG4gICAgICAgIC8vIFRyYW5zYWN0aW9ucyAocGF5b3V0cywgd2l0aGRyYXdhbHMsIHB1cmNoYXNlcylcbiAgICAgICAgLi4ucmVjZW50VHJhbnNhY3Rpb25zLm1hcCh0ID0+ICh7XG4gICAgICAgICAgaWQ6IHQuaWQsXG4gICAgICAgICAgdHlwZTogdC50eXBlLFxuICAgICAgICAgIGFtb3VudDogTnVtYmVyKHQuYW1vdW50KSAqIDEwLCAvLyBUTCB0byBUUFxuICAgICAgICAgIGRhdGU6IHQuY3JlYXRlZEF0LFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0LmRlc2NyaXB0aW9uIHx8ICfDlmRlbWUnLFxuICAgICAgICAgIHN0YXR1czogdC5zdGF0dXMsXG4gICAgICAgICAgaXNQbHVzOiB0LnR5cGUgPT09ICdFQVJOSU5HJyAvLyBFQVJOSU5HIGlzIHBvc2l0aXZlLCBTUEVORCBpcyBuZWdhdGl2ZVxuICAgICAgICB9KSlcbiAgICAgIF0uc29ydCgoYSwgYikgPT4gYi5kYXRlLmdldFRpbWUoKSAtIGEuZGF0ZS5nZXRUaW1lKCkpLnNsaWNlKDAsIDIwKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG90YWxFYXJuaW5ncyxcbiAgICAgICAgZXN0aW1hdGVkRWFybmluZ3MsXG4gICAgICAgIHRvdGFsVmlld3MsXG4gICAgICAgIGFjdGl2ZVZpZGVvcyxcbiAgICAgICAgYXZnQ29udHJpYnV0aW9uUGVyY2VudCxcbiAgICAgICAgYXZnVmlld3MsXG4gICAgICAgIHRvdGFsVmlkZW9zOiBzdWJtaXNzaW9ucy5sZW5ndGgsXG4gICAgICAgIHJlY2VudEFjdGl2aXR5LFxuICAgICAgICByZWNlbnRTdWJtaXNzaW9uczogc3VibWlzc2lvbnNcbiAgICAgICAgICAuZmlsdGVyKHMgPT4ge1xuICAgICAgICAgICAgaWYgKCFzLmNhbXBhaWduKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBPbmx5IGluY2x1ZGUgc3VibWlzc2lvbnMgZnJvbSBhY3RpdmUgY2FtcGFpZ25zXG4gICAgICAgICAgICBjb25zdCBjYW1wYWlnbkVuZGVkID0gcy5jYW1wYWlnbi5zdGF0dXMgPT09ICdDT01QTEVURUQnIHx8IG5ldyBEYXRlKHMuY2FtcGFpZ24uZW5kRGF0ZSkgPCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuICFjYW1wYWlnbkVuZGVkO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNsaWNlKDAsIDEwKSxcbiAgICAgICAgLy8gVXNlciBpbmZvXG4gICAgICAgIGNyZWF0b3JUaWVyOiB1c2VyPy5jcmVhdG9yVGllcixcbiAgICAgICAgZm9sbG93ZXJDb3VudDogdXNlcj8uZm9sbG93ZXJDb3VudCB8fCAwLFxuICAgICAgICBwbGFuOiB1c2VyPy5wbGFuIHx8ICdGUkVFJ1xuICAgICAgfTtcbiAgICB9KSxcblxuICBnZXRBcnRpc3RTdGF0czogdC5wcm9jZWR1cmVcbiAgICAucXVlcnkoYXN5bmMgKHsgY3R4IH0pID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG5cbiAgICAgIC8vIE9QVElNSVpFRDogUGFyYWxsZWxpemUgYWxsIGluZGVwZW5kZW50IHF1ZXJpZXNcbiAgICAgIGNvbnN0IFtcbiAgICAgICAgYnVkZ2V0U3RhdHMsXG4gICAgICAgIHZpZXdTdGF0cyxcbiAgICAgICAgcmVjZW50VHJhbnNhY3Rpb25zLFxuICAgICAgICBhY3RpdmVDYW1wYWlnbnNcbiAgICAgIF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIC8vIDEuIENhbGN1bGF0ZSBBY3RpdmUgQnVkZ2V0ICYgQ2FtcGFpZ24gQ291bnQgKEFnZ3JlZ2F0aW9uKVxuICAgICAgICBwcmlzbWEuY2FtcGFpZ24uYWdncmVnYXRlKHtcbiAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgYXJ0aXN0SWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIHN0YXR1czogXCJBQ1RJVkVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3N1bToge1xuICAgICAgICAgICAgcmVtYWluaW5nQnVkZ2V0OiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfY291bnQ6IHRydWVcbiAgICAgICAgfSksXG5cbiAgICAgICAgLy8gMi4gQ2FsY3VsYXRlIFRvdGFsIFZpZXdzIChBZ2dyZWdhdGlvbilcbiAgICAgICAgcHJpc21hLnN1Ym1pc3Npb24uYWdncmVnYXRlKHtcbiAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgY2FtcGFpZ246IHtcbiAgICAgICAgICAgICAgYXJ0aXN0SWQ6IHVzZXJJZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3N1bToge1xuICAgICAgICAgICAgbGFzdFZpZXdDb3VudDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG5cbiAgICAgICAgLy8gMy4gUmVjZW50IFRyYW5zYWN0aW9uc1xuICAgICAgICBwcmlzbWEudHJhbnNhY3Rpb24uZmluZE1hbnkoe1xuICAgICAgICAgIHdoZXJlOiB7IHVzZXJJZCB9LFxuICAgICAgICAgIHRha2U6IDIwLFxuICAgICAgICAgIG9yZGVyQnk6IHsgY3JlYXRlZEF0OiBcImRlc2NcIiB9XG4gICAgICAgIH0pLFxuXG4gICAgICAgIC8vIDQuIEFjdGl2ZSBDYW1wYWlnbnMgTGlzdCAoZm9yIGRpc3BsYXkpXG4gICAgICAgIHByaXNtYS5jYW1wYWlnbi5maW5kTWFueSh7XG4gICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgIGFydGlzdElkOiB1c2VySWQsXG4gICAgICAgICAgICBzdGF0dXM6IFwiQUNUSVZFXCIsXG4gICAgICAgICAgICBlbmREYXRlOiB7IGd0OiBuZXcgRGF0ZSgpIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlbGVjdDoge1xuICAgICAgICAgICAgaWQ6IHRydWUsXG4gICAgICAgICAgICB0aXRsZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXR1czogdHJ1ZSxcbiAgICAgICAgICAgIHRpZXI6IHRydWUsXG4gICAgICAgICAgICB0b3RhbEJ1ZGdldDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbWFpbmluZ0J1ZGdldDogdHJ1ZSxcbiAgICAgICAgICAgIG1heFN1Ym1pc3Npb25zOiB0cnVlLFxuICAgICAgICAgICAgc3RhcnREYXRlOiB0cnVlLFxuICAgICAgICAgICAgZW5kRGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIHNvbmc6IHtcbiAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY292ZXJJbWFnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhdXRob3JOYW1lOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY291bnQ6IHtcbiAgICAgICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICAgICAgc3VibWlzc2lvbnM6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3JkZXJCeTogeyBjcmVhdGVkQXQ6IFwiZGVzY1wiIH0sXG4gICAgICAgICAgdGFrZTogMTBcbiAgICAgICAgfSlcbiAgICAgIF0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBiYWxhbmNlOiBSRU1PVkVEIChGcm9udGVuZCB1c2VzIGdldFVzZXIoKS0+YmFsYW5jZSlcbiAgICAgICAgdG90YWxWaWV3czogdmlld1N0YXRzLl9zdW0ubGFzdFZpZXdDb3VudCB8fCAwLFxuICAgICAgICBhY3RpdmVCdWRnZXQ6IE51bWJlcihidWRnZXRTdGF0cy5fc3VtLnJlbWFpbmluZ0J1ZGdldCB8fCAwKSxcbiAgICAgICAgYWN0aXZlQ2FtcGFpZ25zQ291bnQ6IGJ1ZGdldFN0YXRzLl9jb3VudCxcbiAgICAgICAgcmVjZW50VHJhbnNhY3Rpb25zLFxuICAgICAgICBhY3RpdmVDYW1wYWlnbnNcbiAgICAgIH07XG4gICAgfSksXG5cbiAgZ2V0QWN0aXZpdHk6IHQucHJvY2VkdXJlXG4gICAgLnF1ZXJ5KGFzeW5jICh7IGN0eCB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBjdHgudXNlcj8uaWQ7XG4gICAgICBpZiAoIXVzZXJJZCkgdGhyb3cgbmV3IEVycm9yKFwiVU5BVVRIT1JJWkVEXCIpO1xuXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJpc21hLnVzZXIuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiB1c2VySWQgfSB9KTtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVVNFUl9OT1RfRk9VTkRcIik7XG5cbiAgICAgIGlmICh1c2VyLnJvbGUgPT09IFwiQVJUSVNUXCIpIHtcbiAgICAgICAgLy8gRm9yIEFydGlzdDogU2hvdyBzdWJtaXNzaW9ucyB0byBUSEVJUiBjYW1wYWlnbnNcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByaXNtYS5zdWJtaXNzaW9uLmZpbmRNYW55KHtcbiAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgY2FtcGFpZ246IHtcbiAgICAgICAgICAgICAgYXJ0aXN0SWQ6IHVzZXJJZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5jbHVkZToge1xuICAgICAgICAgICAgY2FtcGFpZ246IHtcbiAgICAgICAgICAgICAgc2VsZWN0OiB7IHRpdGxlOiB0cnVlLCBzb25nOiB7IHNlbGVjdDogeyB0aXRsZTogdHJ1ZSwgY292ZXJJbWFnZTogdHJ1ZSB9IH0gfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IHdhbnQgY3JlYXRvciBkZXRhaWxzIGhlcmVcbiAgICAgICAgICAgIC8vIGNyZWF0b3I6IHsgc2VsZWN0OiB7IG5hbWU6IHRydWUsIGF2YXRhcjogdHJ1ZSB9IH0gXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcmRlckJ5OiB7IGNyZWF0ZWRBdDogXCJkZXNjXCIgfSxcbiAgICAgICAgICB0YWtlOiAyMFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBDcmVhdG9yOiBTaG93IFRIRUlSIHN1Ym1pc3Npb25zXG4gICAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEuc3VibWlzc2lvbi5maW5kTWFueSh7XG4gICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgIGNyZWF0b3JJZDogdXNlcklkXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmNsdWRlOiB7XG4gICAgICAgICAgICBjYW1wYWlnbjoge1xuICAgICAgICAgICAgICBzZWxlY3Q6IHsgdGl0bGU6IHRydWUsIHNvbmc6IHsgc2VsZWN0OiB7IHRpdGxlOiB0cnVlLCBjb3ZlckltYWdlOiB0cnVlLCBhcnRpc3Q6IHsgc2VsZWN0OiB7IG5hbWU6IHRydWUgfSB9IH0gfSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcmRlckJ5OiB7IGNyZWF0ZWRBdDogXCJkZXNjXCIgfSxcbiAgICAgICAgICB0YWtlOiAyMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSxcblxuICB1cGdyYWRlVG9Qcm86IHQucHJvY2VkdXJlXG4gICAgLm11dGF0aW9uKGFzeW5jICh7IGN0eCB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBjdHgudXNlcj8uaWQ7XG4gICAgICBpZiAoIXVzZXJJZCkgdGhyb3cgbmV3IEVycm9yKFwiVU5BVVRIT1JJWkVEXCIpO1xuICAgICAgLy8gTW9jayBzdWNjZXNzIGZvciBjcmVkaXQgY2FyZCBmbG93XG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IHByaXNtYS51c2VyLnVwZGF0ZSh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgICAgZGF0YTogeyBwbGFuOiBcIlBST1wiIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdXNlcjogdXBkYXRlZFVzZXIgfTtcbiAgICB9KSxcblxuICB1cGdyYWRlVG9Qcm9XaXRoVFA6IHQucHJvY2VkdXJlXG4gICAgLm11dGF0aW9uKGFzeW5jICh7IGN0eCB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBjdHgudXNlcj8uaWQ7XG4gICAgICBpZiAoIXVzZXJJZCkgdGhyb3cgbmV3IEVycm9yKFwiVU5BVVRIT1JJWkVEXCIpO1xuXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgcHJpc21hLnVzZXIuZmluZFVuaXF1ZSh7IHdoZXJlOiB7IGlkOiB1c2VySWQgfSB9KTtcbiAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVVNFUl9OT1RfRk9VTkRcIik7XG5cbiAgICAgIC8vIDEgVEwgPSAxMCBUUC4gUHJpY2UgaXMgMzAwMCBUUCA9PiAzMDAgVEwuXG4gICAgICBjb25zdCBDT1NUX1RMID0gMzAwO1xuICAgICAgY29uc3QgQ09VUE9OX1JFV0FSRCA9IDIwOyAvLyBHcmFudCAyMCBjb3Vwb25zIHdpdGggZWFjaCBzdWJzY3JpcHRpb25cblxuICAgICAgaWYgKE51bWJlcih1c2VyLmJhbGFuY2UpIDwgQ09TVF9UTCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlNVRkZJQ0lFTlRfQkFMQU5DRVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIDMwIGRheXMgdG8gY3VycmVudCB0aW1lXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgZXhwaXJlc0F0LnNldERhdGUoZXhwaXJlc0F0LmdldERhdGUoKSArIDMwKTtcblxuICAgICAgY29uc3QgW3VwZGF0ZWRVc2VyXSA9IGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oW1xuICAgICAgICBwcmlzbWEudXNlci51cGRhdGUoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBiYWxhbmNlOiB7IGRlY3JlbWVudDogQ09TVF9UTCB9LFxuICAgICAgICAgICAgY291cG9uQmFsYW5jZTogeyBpbmNyZW1lbnQ6IENPVVBPTl9SRVdBUkQgfSwgLy8gR3JhbnQgMjAgY291cG9uc1xuICAgICAgICAgICAgcGxhbjogXCJQUk9cIixcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbkVuZHNBdDogZXhwaXJlc0F0XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJpc21hLnRyYW5zYWN0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgdHlwZTogXCJTUEVORFwiLFxuICAgICAgICAgICAgYW1vdW50OiBDT1NUX1RMLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUHJvIMOceWVsaWsgKDMwIEfDvG4pICsgMjAgTWFya2V0IEt1cG9uXCIsXG4gICAgICAgICAgICBzdGF0dXM6IFwiQ09NUExFVEVEXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdKTtcblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdXNlcjogdXBkYXRlZFVzZXIgfTtcbiAgICB9KSxcblxuICAvLyBNYXJrZXRwbGFjZSBQcm9jZWR1cmVzXG4gIGJ1eUNvdXBvbnM6IHQucHJvY2VkdXJlXG4gICAgLmlucHV0KHoub2JqZWN0KHsgYW1vdW50OiB6Lm51bWJlcigpLm1pbigxKSB9KSlcbiAgICAubXV0YXRpb24oYXN5bmMgKHsgaW5wdXQsIGN0eCB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBjdHgudXNlcj8uaWQ7XG4gICAgICBpZiAoIXVzZXJJZCkgdGhyb3cgbmV3IEVycm9yKFwiVU5BVVRIT1JJWkVEXCIpO1xuXG4gICAgICBjb25zdCBDT1NUX1BFUl9DT1VQT04gPSAxMDA7IC8vIDEwMCBUUCBwZXIgY291cG9uXG4gICAgICBjb25zdCB0b3RhbENvc3QgPSBpbnB1dC5hbW91bnQgKiBDT1NUX1BFUl9DT1VQT047XG5cbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9IH0pO1xuICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoXCJVU0VSX05PVF9GT1VORFwiKTtcblxuICAgICAgaWYgKE51bWJlcih1c2VyLmJhbGFuY2UpIDwgdG90YWxDb3N0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklOU1VGRklDSUVOVF9CQUxBTkNFXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWR1Y3QgYmFsYW5jZSBhbmQgYWRkIGNvdXBvbnNcbiAgICAgIGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oW1xuICAgICAgICBwcmlzbWEudXNlci51cGRhdGUoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBiYWxhbmNlOiB7IGRlY3JlbWVudDogdG90YWxDb3N0IH0sXG4gICAgICAgICAgICBjb3Vwb25CYWxhbmNlOiB7IGluY3JlbWVudDogaW5wdXQuYW1vdW50IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwcmlzbWEudHJhbnNhY3Rpb24uY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICB0eXBlOiBcIlNQRU5EXCIsXG4gICAgICAgICAgICBhbW91bnQ6IHRvdGFsQ29zdCxcbiAgICAgICAgICAgIHN0YXR1czogXCJDT01QTEVURURcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgS3Vwb24gU2F0xLFuIEFsbWE6ICR7aW5wdXQuYW1vdW50fSBrdXBvbmBcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdKTtcblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH0pLFxuXG4gIHVzZUNvdXBvbjogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3Qoe1xuICAgICAgdG9vbDogei5lbnVtKFtcIlBST0ZJTEVcIiwgXCJIQVNIVEFHXCIsIFwiVkFMVUFUSU9OXCIsIFwiQVVESVRcIiwgXCJDT01QQVJFXCJdKSxcbiAgICAgIGlucHV0OiB6LnN0cmluZygpLm1pbigxKVxuICAgIH0pKVxuICAgIC5tdXRhdGlvbihhc3luYyAoeyBpbnB1dCwgY3R4IH0pID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG5cbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9IH0pO1xuICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoXCJVU0VSX05PVF9GT1VORFwiKTtcblxuICAgICAgaWYgKHVzZXIuY291cG9uQmFsYW5jZSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5TVUZGSUNJRU5UX0NPVVBPTlNcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1vY2sgQW5hbHlzaXMgTG9naWMgYmFzZWQgb24gVG9vbCBUeXBlXG4gICAgICBsZXQgcmVzdWx0RGF0YTogYW55ID0ge307XG5cbiAgICAgIGlmIChpbnB1dC50b29sID09PSBcIkhBU0hUQUdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkdPT0dMRV9BSV9BUElfS0VZO1xuXG4gICAgICAgICAgaWYgKCFhcGlLZXkpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgR29vZ2xlIEFJIEFQSSBLZXlcIik7XG5cbiAgICAgICAgICAvLyBEeW5hbWljYWxseSBpbXBvcnQgdG8gYXZvaWQgbG9hZC10aW1lIGVycm9yc1xuICAgICAgICAgIGNvbnN0IHsgR29vZ2xlR2VuZXJhdGl2ZUFJIH0gPSByZXF1aXJlKFwiQGdvb2dsZS9nZW5lcmF0aXZlLWFpXCIpO1xuICAgICAgICAgIGNvbnN0IGdlbkFJID0gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSShhcGlLZXkpO1xuICAgICAgICAgIGNvbnN0IG1vZGVsID0gZ2VuQUkuZ2V0R2VuZXJhdGl2ZU1vZGVsKHsgbW9kZWw6IFwiZ2VtaW5pLTIuNS1mbGFzaFwiIH0pO1xuXG4gICAgICAgICAgY29uc3QgcHJvbXB0ID0gYEFuYWx5emUgdGhpcyBUaWtUb2sgdmlkZW8gdG9waWMgZm9yIGEgVHVya2lzaCBhdWRpZW5jZTogXCIke2lucHV0LmlucHV0fVwiLlxuICAgICAgICAgICAgR2VuZXJhdGUgYSBKU09OIG9iamVjdCB3aXRoIGhpZ2gtcGVyZm9ybWluZyBUdXJraXNoIGhhc2h0YWdzLlxuICAgICAgICAgICAgRm9ybWF0OiB7IFxuICAgICAgICAgICAgICBcImJyb2FkXCI6IFtcIiN0YWcxXCIsIFwiI3RhZzJcIiwgLi4uXSwgLy8gNi04IFBvcHVsYXIvR2VuZXJhbCB0YWdzIChtb3N0bHkgVHVya2lzaClcbiAgICAgICAgICAgICAgXCJuaWNoZVwiOiBbXCIjdGFnM1wiLCBcIiN0YWc0XCIsIC4uLl0sIC8vIDYtOCBTcGVjaWZpYy9OaWNoZSB0YWdzIChtb3N0bHkgVHVya2lzaClcbiAgICAgICAgICAgICAgXCJ2aXJhbGl0eVNjb3JlXCI6IDg1LCAvLyAwLTEwMCBzY29yZSBiYXNlZCBvbiB0cmVuZCBwb3RlbnRpYWxcbiAgICAgICAgICAgICAgXCJiZXN0VGltZVwiOiBcIjE5OjAwXCIgLy8gQmVzdCB0aW1lIHRvIHBvc3QgaW4gVHVya2V5IChISDpNTSlcbiAgICAgICAgICAgIH0uIFxuICAgICAgICAgICAgT25seSByZXR1cm4gdGhlIEpTT04uYDtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vZGVsLmdlbmVyYXRlQ29udGVudChwcm9tcHQpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzdWx0LnJlc3BvbnNlO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICAvLyBDbGVhbiBtYXJrZG93biBoZWxwZXJzIGlmIHByZXNlbnRcbiAgICAgICAgICBjb25zdCBjbGVhbkpzb24gPSB0ZXh0LnJlcGxhY2UoL2BgYGpzb258YGBgL2csIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICByZXN1bHREYXRhID0gSlNPTi5wYXJzZShjbGVhbkpzb24pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkdlbWluaSBFcnJvcjpcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgLy8gRmFsbGJhY2sgaWYgQVBJIGZhaWxzIGZvciBBTlkgcmVhc29uIChuZXR3b3JrLCBrZXksIHJlZ2lvbiwgcGFyc2luZylcbiAgICAgICAgICByZXN1bHREYXRhID0ge1xuICAgICAgICAgICAgYnJvYWQ6IFtcIiNmeXBcIiwgXCIja2VzZmV0XCIsIFwiI3Rpa3Rva1wiXSxcbiAgICAgICAgICAgIG5pY2hlOiBbYCMke2lucHV0LmlucHV0LnJlcGxhY2UoL1xccy9nLCBcIlwiKX1gLCBcIiN0cmVuZFwiXSxcbiAgICAgICAgICAgIHZpcmFsaXR5U2NvcmU6IDcwLFxuICAgICAgICAgICAgYmVzdFRpbWU6IFwiMjA6MDBcIixcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIC8vIE9wdGlvbmFsOiByZXR1cm4gZXJyb3IgdG8gVUkgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQudG9vbCA9PT0gXCJWQUxVQVRJT05cIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFJlYWwgRGF0YSB2aWEgVGlrQVBJXG4gICAgICAgICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuVElLX0FQSV9LRVk7XG4gICAgICAgICAgaWYgKCFhcGlLZXkpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgVGlrQVBJIEtleSAoVElLX0FQSV9LRVkpXCIpO1xuXG4gICAgICAgICAgLy8gMS4gRmV0Y2ggVXNlciBJbmZvIChmb3IgRm9sbG93ZXIgQ291bnQpXG4gICAgICAgICAgY29uc3QgdXNlclJlcyA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS50aWthcGkuaW8vcHVibGljL2NoZWNrP3VzZXJuYW1lPSR7aW5wdXQuaW5wdXR9YCwge1xuICAgICAgICAgICAgaGVhZGVyczogeyBcIlgtQVBJLUtFWVwiOiBhcGlLZXkgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghdXNlclJlcy5vaykgdGhyb3cgbmV3IEVycm9yKGBUaWtBUEkgQ2hlY2sgRXJyb3I6ICR7dXNlclJlcy5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgdXNlclJlcy5qc29uKCk7XG4gICAgICAgICAgY29uc3QgdXNlckluZm8gPSB1c2VyRGF0YS51c2VySW5mbztcbiAgICAgICAgICBpZiAoIXVzZXJJbmZvKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKTtcblxuICAgICAgICAgIGNvbnN0IGZvbGxvd2VycyA9IHVzZXJJbmZvLnN0YXRzPy5mb2xsb3dlckNvdW50IHx8IDA7XG5cbiAgICAgICAgICAvLyAyLiBGZXRjaCBVc2VyIFBvc3RzIChmb3IgVmlld3MvRW5nYWdlbWVudCkgLSBSZWNlbnQgQmF0Y2hcbiAgICAgICAgICAvLyBUaWtBUEkgcHVibGljL3Bvc3RzIHJlcXVpcmVzICdzZWNVaWQnIGZvciByZWxpYWJpbGl0eS5cbiAgICAgICAgICBjb25zdCBzZWNVaWQgPSB1c2VySW5mby51c2VyPy5zZWNVaWQ7XG4gICAgICAgICAgaWYgKCFzZWNVaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIHNlY1VpZCBmb3VuZCwgdHJ5aW5nIHVzZXJuYW1lIGZhbGxiYWNrIGJ1dCBsaWtlbHkgdG8gZmFpbCBpZiBBUEkgZGVtYW5kcyBzZWNVaWRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ29uc3RydWN0IHF1ZXJ5IC0gcHJlZmVyIHNlY1VpZFxuICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW0gPSBzZWNVaWQgPyBgc2VjVWlkPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlY1VpZCl9YCA6IGB1c2VybmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudCh1c2VySW5mby51c2VyPy51bmlxdWVJZCB8fCBpbnB1dC5pbnB1dCl9YDtcblxuICAgICAgICAgIGNvbnN0IHBvc3RzUmVzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLnRpa2FwaS5pby9wdWJsaWMvcG9zdHM/JHtxdWVyeVBhcmFtfWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJYLUFQSS1LRVlcIjogYXBpS2V5IH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghcG9zdHNSZXMub2spIHtcbiAgICAgICAgICAgIC8vIElmIGJhZCByZXF1ZXN0LCBsb2cgbW9yZSBkZXRhaWxzIGlmIHBvc3NpYmxlIChUaWtBUEkgZXJyb3JzIGFyZSBzb21ldGltZXMgaW4gYm9keSlcbiAgICAgICAgICAgIGNvbnN0IGVyclRleHQgPSBhd2FpdCBwb3N0c1Jlcy50ZXh0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGlrQVBJIFBvc3RzIEVycm9yIGRldGFpbHM6XCIsIGVyclRleHQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaWtBUEkgUG9zdHMgRXJyb3I6ICR7cG9zdHNSZXMuc3RhdHVzfSAke3Bvc3RzUmVzLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcG9zdHNEYXRhID0gYXdhaXQgcG9zdHNSZXMuanNvbigpO1xuICAgICAgICAgIGNvbnN0IHBvc3RzID0gcG9zdHNEYXRhLml0ZW1MaXN0IHx8IFtdO1xuXG4gICAgICAgICAgLy8gRmlsdGVyIExhc3QgMTAgRGF5c1xuICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgY29uc3QgdGVuRGF5c0FnbyA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSAoMTAgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG5cbiAgICAgICAgICBjb25zdCByZWNlbnRQb3N0cyA9IHBvc3RzLmZpbHRlcigocDogYW55KSA9PiBuZXcgRGF0ZShwLmNyZWF0ZVRpbWUgKiAxMDAwKSA+IHRlbkRheXNBZ28pO1xuXG4gICAgICAgICAgbGV0IGF2Z1ZpZXdzID0gMDtcbiAgICAgICAgICBsZXQgc2FmZUVyID0gMDtcblxuICAgICAgICAgIGlmIChyZWNlbnRQb3N0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFZpZXdzID0gcmVjZW50UG9zdHMucmVkdWNlKChhY2M6IG51bWJlciwgcDogYW55KSA9PiBhY2MgKyAocC5zdGF0cz8ucGxheUNvdW50IHx8IDApLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTGlrZXMgPSByZWNlbnRQb3N0cy5yZWR1Y2UoKGFjYzogbnVtYmVyLCBwOiBhbnkpID0+IGFjYyArIChwLnN0YXRzPy5kaWdnQ291bnQgfHwgMCksIDApO1xuICAgICAgICAgICAgY29uc3QgdG90YWxDb21tZW50cyA9IHJlY2VudFBvc3RzLnJlZHVjZSgoYWNjOiBudW1iZXIsIHA6IGFueSkgPT4gYWNjICsgKHAuc3RhdHM/LmNvbW1lbnRDb3VudCB8fCAwKSwgMCk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFNoYXJlcyA9IHJlY2VudFBvc3RzLnJlZHVjZSgoYWNjOiBudW1iZXIsIHA6IGFueSkgPT4gYWNjICsgKHAuc3RhdHM/LnNoYXJlQ291bnQgfHwgMCksIDApO1xuXG4gICAgICAgICAgICAvLyBXZWlnaHRlZCBFbmdhZ2VtZW50OiBMaWtlcygxKSArIENvbW1lbnRzKDIpICsgU2hhcmVzKDMpXG4gICAgICAgICAgICBjb25zdCB3ZWlnaHRlZEVuZ2FnZW1lbnRzID0gdG90YWxMaWtlcyArICh0b3RhbENvbW1lbnRzICogMikgKyAodG90YWxTaGFyZXMgKiAzKTtcblxuICAgICAgICAgICAgYXZnVmlld3MgPSBNYXRoLmZsb29yKHRvdGFsVmlld3MgLyByZWNlbnRQb3N0cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyBSZWFsIEVSIENhbGN1bGF0aW9uIChObyBGbG9vcilcbiAgICAgICAgICAgIGNvbnN0IHJlYWxFciA9IHRvdGFsVmlld3MgPiAwID8gKHdlaWdodGVkRW5nYWdlbWVudHMgLyB0b3RhbFZpZXdzKSAqIDEwMCA6IDA7XG4gICAgICAgICAgICAvLyBObyBmbG9vciBtaW5pbXVtIG9mIDEwJVxuICAgICAgICAgICAgc2FmZUVyID0gTWF0aC5taW4ocmVhbEVyLCAxMDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayBpZiBubyBwb3N0cyBpbiBsYXN0IDEwIGRheXM6IFVzZSBsYXN0IDMgcG9zdHMgZ2VuZXJhbGx5XG4gICAgICAgICAgICBpZiAocG9zdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0MyA9IHBvc3RzLnNsaWNlKDAsIDMpO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbFZpZXdzID0gbGFzdDMucmVkdWNlKChhY2M6IG51bWJlciwgcDogYW55KSA9PiBhY2MgKyAocC5zdGF0cz8ucGxheUNvdW50IHx8IDApLCAwKTtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxMaWtlcyA9IGxhc3QzLnJlZHVjZSgoYWNjOiBudW1iZXIsIHA6IGFueSkgPT4gYWNjICsgKHAuc3RhdHM/LmRpZ2dDb3VudCB8fCAwKSwgMCk7XG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsQ29tbWVudHMgPSBsYXN0My5yZWR1Y2UoKGFjYzogbnVtYmVyLCBwOiBhbnkpID0+IGFjYyArIChwLnN0YXRzPy5jb21tZW50Q291bnQgfHwgMCksIDApO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbFNoYXJlcyA9IGxhc3QzLnJlZHVjZSgoYWNjOiBudW1iZXIsIHA6IGFueSkgPT4gYWNjICsgKHAuc3RhdHM/LnNoYXJlQ291bnQgfHwgMCksIDApO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHdlaWdodGVkRW5nYWdlbWVudHMgPSB0b3RhbExpa2VzICsgKHRvdGFsQ29tbWVudHMgKiAyKSArICh0b3RhbFNoYXJlcyAqIDMpO1xuXG4gICAgICAgICAgICAgIGF2Z1ZpZXdzID0gTWF0aC5mbG9vcih0b3RhbFZpZXdzIC8gbGFzdDMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgY29uc3QgcmVhbEVyID0gdG90YWxWaWV3cyA+IDAgPyAod2VpZ2h0ZWRFbmdhZ2VtZW50cyAvIHRvdGFsVmlld3MpICogMTAwIDogMDtcbiAgICAgICAgICAgICAgc2FmZUVyID0gTWF0aC5taW4ocmVhbEVyLCAxMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXZnVmlld3MgPSAwOyAvLyBUcnVseSBpbmFjdGl2ZSBhY2NvdW50XG4gICAgICAgICAgICAgIHNhZmVFciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRHluYW1pYyBDUE0gQWxnb3JpdGhtXG4gICAgICAgICAgbGV0IGNwbSA9IDIwOyAvLyBCYXNlIDIwIFRMXG4gICAgICAgICAgbGV0IGVyTXVsdGlwbGllciA9IDE7XG5cbiAgICAgICAgICBpZiAoc2FmZUVyID49IDEwKSB7XG4gICAgICAgICAgICBlck11bHRpcGxpZXIgPSAxLjI1OyAvLyBCYXNlIGJvb3N0ICgrMjUlKSBmb3IgaGl0dGluZyAxMCVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2Vzc0VyID0gc2FmZUVyIC0gMTA7XG4gICAgICAgICAgICBpZiAoZXhjZXNzRXIgPiAwKSB7XG4gICAgICAgICAgICAgIC8vICsyJSBib29zdCBmb3IgZWFjaCAlMSBFUiBhYm92ZSAxMFxuICAgICAgICAgICAgICBlck11bHRpcGxpZXIgKz0gKGV4Y2Vzc0VyICogMC4wMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNwbSAqPSBlck11bHRpcGxpZXI7XG5cbiAgICAgICAgICBpZiAoZm9sbG93ZXJzID4gNTAwMDApIGNwbSAqPSAxLjE7XG5cbiAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRQcmljZSA9IChhdmdWaWV3cyAvIDEwMDApICogY3BtO1xuXG4gICAgICAgICAgcmVzdWx0RGF0YSA9IHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VySW5mby51c2VyPy51bmlxdWVJZCB8fCBpbnB1dC5pbnB1dCxcbiAgICAgICAgICAgIHByaWNlUGVyUG9zdDogZXN0aW1hdGVkUHJpY2UsXG4gICAgICAgICAgICBlbmdhZ2VtZW50UmF0ZTogc2FmZUVyLnRvRml4ZWQoMiksXG4gICAgICAgICAgICBhdmdWaWV3czogYXZnVmlld3MsXG4gICAgICAgICAgICBmb2xsb3dlcnM6IGZvbGxvd2VycyxcbiAgICAgICAgICAgIGNwbWRVc2VkOiBjcG1cbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGlrQVBJIFZhbHVhdGlvbiBFcnJvcjpcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5hbGl6IHPEsXJhc8SxbmRhIGJpciBoYXRhIG9sdcWfdHU6IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChpbnB1dC50b29sID09PSBcIlBST0ZJTEVcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LlRJS19BUElfS0VZO1xuICAgICAgICAgIGlmICghYXBpS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIFRpa0FQSSBLZXlcIik7XG5cbiAgICAgICAgICAvLyAxLiBDaGVjayBVc2VyXG4gICAgICAgICAgY29uc3QgdXNlclJlcyA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS50aWthcGkuaW8vcHVibGljL2NoZWNrP3VzZXJuYW1lPSR7aW5wdXQuaW5wdXR9YCwgeyBoZWFkZXJzOiB7IFwiWC1BUEktS0VZXCI6IGFwaUtleSB9IH0pO1xuICAgICAgICAgIGlmICghdXNlclJlcy5vaykgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBDaGVjayBGYWlsZWRcIik7XG4gICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCB1c2VyUmVzLmpzb24oKTtcbiAgICAgICAgICBjb25zdCB1c2VySW5mbyA9IHVzZXJEYXRhLnVzZXJJbmZvO1xuICAgICAgICAgIGlmICghdXNlckluZm8pIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpO1xuXG4gICAgICAgICAgLy8gMi4gRmV0Y2ggUG9zdHNcbiAgICAgICAgICBjb25zdCBzZWNVaWQgPSB1c2VySW5mby51c2VyPy5zZWNVaWQ7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VjVWlkID8gYHNlY1VpZD0ke2VuY29kZVVSSUNvbXBvbmVudChzZWNVaWQpfWAgOiBgdXNlcm5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQodXNlckluZm8udXNlcj8udW5pcXVlSWQgfHwgaW5wdXQuaW5wdXQpfWA7XG5cbiAgICAgICAgICBjb25zdCBwb3N0c1JlcyA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS50aWthcGkuaW8vcHVibGljL3Bvc3RzPyR7dGFyZ2V0fSZjb3VudD0xNWAsIHsgaGVhZGVyczogeyBcIlgtQVBJLUtFWVwiOiBhcGlLZXkgfSB9KTsgLy8gRmV0Y2ggYSBmZXcgbW9yZSB0byBlbnN1cmUgd2UgZ2V0IDEwIHZhbGlkXG4gICAgICAgICAgaWYgKCFwb3N0c1Jlcy5vaykgdGhyb3cgbmV3IEVycm9yKFwiUG9zdHMgRmV0Y2ggRmFpbGVkXCIpO1xuICAgICAgICAgIGNvbnN0IHBvc3RzRGF0YSA9IGF3YWl0IHBvc3RzUmVzLmpzb24oKTtcbiAgICAgICAgICBjb25zdCBhbGxQb3N0cyA9IHBvc3RzRGF0YS5pdGVtTGlzdCB8fCBbXTtcblxuICAgICAgICAgIC8vIDMuIEFuYWx5emUgTGFzdCAxMCBWaWRlb3NcbiAgICAgICAgICBjb25zdCBsYXN0MTAgPSBhbGxQb3N0cy5zbGljZSgwLCAxMCk7XG5cbiAgICAgICAgICBpZiAobGFzdDEwLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVjZW50IHZpZGVvcyBmb3VuZCB0byBhbmFseXplLlwiKTtcblxuICAgICAgICAgIGNvbnN0IGFuYWx5emVkVmlkZW9zID0gbGFzdDEwLm1hcCgocDogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2aWV3cyA9IHAuc3RhdHM/LnBsYXlDb3VudCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgbGlrZXMgPSBwLnN0YXRzPy5kaWdnQ291bnQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRzID0gcC5zdGF0cz8uY29tbWVudENvdW50IHx8IDA7XG4gICAgICAgICAgICBjb25zdCBzaGFyZXMgPSBwLnN0YXRzPy5zaGFyZUNvdW50IHx8IDA7XG5cbiAgICAgICAgICAgIC8vIFdlaWdodGVkIEVSOiAoKExpa2VzICsgQ29tbWVudHMqMiArIFNoYXJlcyozKSAvIFZpZXdzKSAqIDEwMFxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ZWRFbmcgPSBsaWtlcyArIChjb21tZW50cyAqIDIpICsgKHNoYXJlcyAqIDMpO1xuICAgICAgICAgICAgY29uc3QgZXIgPSB2aWV3cyA+IDAgPyAod2VpZ2h0ZWRFbmcgLyB2aWV3cykgKiAxMDAgOiAwO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpZDogcC5pZCxcbiAgICAgICAgICAgICAgZGVzYzogcC5kZXNjIHx8IFwiXCIsXG4gICAgICAgICAgICAgIGNvdmVyOiBwLnZpZGVvPy5jb3ZlciB8fCBcIlwiLFxuICAgICAgICAgICAgICBjcmVhdGVUaW1lOiBwLmNyZWF0ZVRpbWUsXG4gICAgICAgICAgICAgIHN0YXRzOiB7IHZpZXdzLCBsaWtlcywgY29tbWVudHMsIHNoYXJlcywgZXIgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIDQuIEF2ZXJhZ2VzXG4gICAgICAgICAgY29uc3QgYXZnU3RhdHMgPSB7XG4gICAgICAgICAgICB2aWV3czogTWF0aC5mbG9vcihhbmFseXplZFZpZGVvcy5yZWR1Y2UoKGFjYzogbnVtYmVyLCB2OiBhbnkpID0+IGFjYyArIHYuc3RhdHMudmlld3MsIDApIC8gYW5hbHl6ZWRWaWRlb3MubGVuZ3RoKSxcbiAgICAgICAgICAgIGxpa2VzOiBNYXRoLmZsb29yKGFuYWx5emVkVmlkZW9zLnJlZHVjZSgoYWNjOiBudW1iZXIsIHY6IGFueSkgPT4gYWNjICsgdi5zdGF0cy5saWtlcywgMCkgLyBhbmFseXplZFZpZGVvcy5sZW5ndGgpLFxuICAgICAgICAgICAgY29tbWVudHM6IE1hdGguZmxvb3IoYW5hbHl6ZWRWaWRlb3MucmVkdWNlKChhY2M6IG51bWJlciwgdjogYW55KSA9PiBhY2MgKyB2LnN0YXRzLmNvbW1lbnRzLCAwKSAvIGFuYWx5emVkVmlkZW9zLmxlbmd0aCksXG4gICAgICAgICAgICBzaGFyZXM6IE1hdGguZmxvb3IoYW5hbHl6ZWRWaWRlb3MucmVkdWNlKChhY2M6IG51bWJlciwgdjogYW55KSA9PiBhY2MgKyB2LnN0YXRzLnNoYXJlcywgMCkgLyBhbmFseXplZFZpZGVvcy5sZW5ndGgpLFxuICAgICAgICAgICAgZXI6IHBhcnNlRmxvYXQoKGFuYWx5emVkVmlkZW9zLnJlZHVjZSgoYWNjOiBudW1iZXIsIHY6IGFueSkgPT4gYWNjICsgdi5zdGF0cy5lciwgMCkgLyBhbmFseXplZFZpZGVvcy5sZW5ndGgpLnRvRml4ZWQoMikpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIDUuIENvbnNpc3RlbmN5IFNjb3JlIChCYXNlZCBvbiBWYXJpYW5jZSBvZiBHYXBzIGJldHdlZW4gcG9zdHMpXG4gICAgICAgICAgLy8gSWYgZ2FwcyBhcmUgdW5pZm9ybSwgY29uc2lzdGVuY3kgaXMgaGlnaC5cbiAgICAgICAgICBsZXQgY29uc2lzdGVuY3lTY29yZSA9IDUwO1xuICAgICAgICAgIGlmIChhbmFseXplZFZpZGVvcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBnYXBzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmFseXplZFZpZGVvcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgZ2FwSHJzID0gTWF0aC5hYnMoYW5hbHl6ZWRWaWRlb3NbaV0uY3JlYXRlVGltZSAtIGFuYWx5emVkVmlkZW9zW2kgKyAxXS5jcmVhdGVUaW1lKSAvIDM2MDA7XG4gICAgICAgICAgICAgIGdhcHMucHVzaChnYXBIcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIENvZWZmaWNpZW50IG9mIFZhcmlhdGlvbiAoQ1YpID0gU3RkRGV2IC8gTWVhblxuICAgICAgICAgICAgY29uc3QgbWVhbkdhcCA9IGdhcHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBnYXBzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbmNlID0gZ2Fwcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBNYXRoLnBvdyhiIC0gbWVhbkdhcCwgMiksIDApIC8gZ2Fwcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuXG4gICAgICAgICAgICBjb25zdCBjdiA9IHN0ZERldiAvIChtZWFuR2FwIHx8IDEpO1xuICAgICAgICAgICAgLy8gTG93ZXIgQ1YgaXMgYmV0dGVyLiBJZiBDViA8IDAuMiAtPiBFeGNlbGxlbnQgKDEwMCkuIElmIENWID4gMS41IC0+IEJhZCAoMjApLlxuICAgICAgICAgICAgLy8gTWFwIDAuMi4uLjEuNSB0byAxMDAuLi4yMCByb3VnaGx5LlxuICAgICAgICAgICAgY29uc2lzdGVuY3lTY29yZSA9IE1hdGgubWF4KDIwLCBNYXRoLm1pbigxMDAsIDEwMCAtIChjdiAqIDUwKSkpO1xuXG4gICAgICAgICAgICAvLyBQZW5hbHR5IGZvciBpbmFjdGl2aXR5OiBJZiBtZWFuIGdhcCA+IDcgZGF5cyAoMTY4IGhycyksIHJlZHVjZSBzY29yZS5cbiAgICAgICAgICAgIGlmIChtZWFuR2FwID4gMTY4KSBjb25zaXN0ZW5jeVNjb3JlICo9IDAuNztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA2LiBDb21tdW5pdHkgSGVhbHRoIChJbnRlcmFjdGlvbiBSYXRpb3MpXG4gICAgICAgICAgLy8gQ29tbWVudHMvTGlrZXMgcmF0aW86IDAuNSUgaXMgZ29vZC4gU2hhcmVzL0xpa2VzIHJhdGlvOiAxMCUgaXMgdmlyYWwuXG4gICAgICAgICAgY29uc3QgY29tbWVudFJhdGlvID0gYXZnU3RhdHMubGlrZXMgPiAwID8gKGF2Z1N0YXRzLmNvbW1lbnRzIC8gYXZnU3RhdHMubGlrZXMpICogMTAwIDogMDtcbiAgICAgICAgICBjb25zdCBzaGFyZVJhdGlvID0gYXZnU3RhdHMubGlrZXMgPiAwID8gKGF2Z1N0YXRzLnNoYXJlcyAvIGF2Z1N0YXRzLmxpa2VzKSAqIDEwMCA6IDA7XG5cbiAgICAgICAgICBsZXQgY29tbXVuaXR5U2NvcmUgPSA1MDsgLy8gQmFzZVxuICAgICAgICAgIGlmIChjb21tZW50UmF0aW8gPiAwLjUpIGNvbW11bml0eVNjb3JlICs9IDIwOyAvLyBHb29kIHRhbGthdGl2ZSBhdWRpZW5jZVxuICAgICAgICAgIGlmIChjb21tZW50UmF0aW8gPiAxLjUpIGNvbW11bml0eVNjb3JlICs9IDEwO1xuICAgICAgICAgIGlmIChzaGFyZVJhdGlvID4gNSkgY29tbXVuaXR5U2NvcmUgKz0gMTU7IC8vIEhpZ2ggc2hhcmFiaWxpdHlcbiAgICAgICAgICBpZiAoc2hhcmVSYXRpbyA+IDEwKSBjb21tdW5pdHlTY29yZSArPSAxNTsgLy8gVmVyeSBWaXJhbFxuICAgICAgICAgIGNvbW11bml0eVNjb3JlID0gTWF0aC5taW4oMTAwLCBjb21tdW5pdHlTY29yZSk7XG5cblxuICAgICAgICAgIHJlc3VsdERhdGEgPSB7XG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VySW5mby51c2VyLnVuaXF1ZUlkLFxuICAgICAgICAgICAgICBuaWNrbmFtZTogdXNlckluZm8udXNlci5uaWNrbmFtZSxcbiAgICAgICAgICAgICAgYXZhdGFyOiB1c2VySW5mby51c2VyLmF2YXRhclRodW1iLFxuICAgICAgICAgICAgICBmb2xsb3dlcnM6IHVzZXJJbmZvLnN0YXRzLmZvbGxvd2VyQ291bnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdmVyYWdlczogYXZnU3RhdHMsXG4gICAgICAgICAgICB2aWRlb3M6IGFuYWx5emVkVmlkZW9zLFxuICAgICAgICAgICAgc2NvcmVzOiB7XG4gICAgICAgICAgICAgIGNvbnNpc3RlbmN5OiBNYXRoLnJvdW5kKGNvbnNpc3RlbmN5U2NvcmUpLFxuICAgICAgICAgICAgICBjb21tdW5pdHk6IE1hdGgucm91bmQoY29tbXVuaXR5U2NvcmUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlByb2ZpbGUgQW5hbHlzaXMgRXJyb3I6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuYWxpeiBCYcWfYXLEsXPEsXo6IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChpbnB1dC50b29sID09PSBcIkFVRElUXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5USUtfQVBJX0tFWTtcbiAgICAgICAgICBpZiAoIWFwaUtleSkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBUaWtBUEkgS2V5XCIpO1xuXG4gICAgICAgICAgLy8gRXh0cmFjdCBWaWRlbyBJRCBmcm9tIExpbmtcbiAgICAgICAgICBsZXQgdmlkZW9JZCA9IGlucHV0LmlucHV0O1xuICAgICAgICAgIGlmIChpbnB1dC5pbnB1dC5pbmNsdWRlcyhcInRpa3Rvay5jb21cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gaW5wdXQuaW5wdXQubWF0Y2goL1xcL3ZpZGVvXFwvKFxcZCspLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHZpZGVvSWQgPSBtYXRjaFsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGZXRjaCBWaWRlbyBEZXRhaWxzXG4gICAgICAgICAgY29uc3QgdmlkUmVzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLnRpa2FwaS5pby9wdWJsaWMvdmlkZW8/aWQ9JHt2aWRlb0lkfWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJYLUFQSS1LRVlcIjogYXBpS2V5IH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdmlkUmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJWaWRlbyBub3QgZm91bmQgb3IgQVBJIGVycm9yXCIpO1xuICAgICAgICAgIGNvbnN0IHZpZERhdGEgPSBhd2FpdCB2aWRSZXMuanNvbigpO1xuICAgICAgICAgIGNvbnN0IHZpZGVvID0gdmlkRGF0YS5pdGVtSW5mbz8uaXRlbVN0cnVjdDtcbiAgICAgICAgICBpZiAoIXZpZGVvKSB0aHJvdyBuZXcgRXJyb3IoXCJWaWRlbyBkYXRhIGlzIGVtcHR5XCIpO1xuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIFN0YXRzXG4gICAgICAgICAgY29uc3Qgc3RhdHMgPSB2aWRlby5zdGF0cztcbiAgICAgICAgICBjb25zdCB2aWV3cyA9IHN0YXRzLnBsYXlDb3VudCB8fCAxO1xuICAgICAgICAgIGNvbnN0IGxpa2VzID0gc3RhdHMuZGlnZ0NvdW50IHx8IDA7XG4gICAgICAgICAgY29uc3QgY29tbWVudHMgPSBzdGF0cy5jb21tZW50Q291bnQgfHwgMDtcbiAgICAgICAgICBjb25zdCBzaGFyZXMgPSBzdGF0cy5zaGFyZUNvdW50IHx8IDA7XG4gICAgICAgICAgY29uc3Qgc2F2ZXMgPSBzdGF0cy5jb2xsZWN0Q291bnQgfHwgMDtcbiAgICAgICAgICBjb25zdCBkb3dubG9hZHMgPSBzdGF0cy5kb3dubG9hZENvdW50IHx8IDA7XG5cbiAgICAgICAgICAvLyBVc2VyIEZvcm11bGE6IChsaWtlcyoyICsgY29tbWVudHMqMyArIHNoYXJlcyo0KVxuICAgICAgICAgIGNvbnN0IHdlaWdodGVkRW5nYWdlbWVudCA9IChsaWtlcyAqIDIpICsgKGNvbW1lbnRzICogMykgKyAoc2hhcmVzICogNCk7XG4gICAgICAgICAgLy8gUGVyY2VudGFnZVxuICAgICAgICAgIGNvbnN0IGN1c3RvbUVyID0gKHdlaWdodGVkRW5nYWdlbWVudCAvIHZpZXdzKSAqIDEwMDtcblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBWaXJhbGl0eSBTY29yZSAoMC0xMDApXG4gICAgICAgICAgY29uc3QgZXJTY29yZSA9IE1hdGgubWluKChjdXN0b21FciAvIDI1KSAqIDEwMCwgMTAwKTtcbiAgICAgICAgICBjb25zdCB2aWV3U2NvcmUgPSBNYXRoLm1pbigodmlld3MgLyAxMDAwMDApICogMTAwLCAxMDApO1xuICAgICAgICAgIGNvbnN0IHZpcmFsaXR5U2NvcmUgPSBNYXRoLnJvdW5kKChlclNjb3JlICogMC43KSArICh2aWV3U2NvcmUgKiAwLjMpKTtcblxuICAgICAgICAgIC8vIEFzc2lnbiBHcmFkZVxuICAgICAgICAgIGxldCBncmFkZSA9IFwiQ1wiO1xuICAgICAgICAgIGlmICh2aXJhbGl0eVNjb3JlID49IDkwKSBncmFkZSA9IFwiU1wiO1xuICAgICAgICAgIGVsc2UgaWYgKHZpcmFsaXR5U2NvcmUgPj0gNzUpIGdyYWRlID0gXCJBXCI7XG4gICAgICAgICAgZWxzZSBpZiAodmlyYWxpdHlTY29yZSA+PSA1MCkgZ3JhZGUgPSBcIkJcIjtcbiAgICAgICAgICBlbHNlIGlmICh2aXJhbGl0eVNjb3JlIDwgMzApIGdyYWRlID0gXCJGXCI7XG5cbiAgICAgICAgICByZXN1bHREYXRhID0ge1xuICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgaWQ6IHZpZGVvLmlkLFxuICAgICAgICAgICAgICBkZXNjOiB2aWRlby5kZXNjLFxuICAgICAgICAgICAgICBjb3ZlcjogdmlkZW8udmlkZW8/LmNvdmVyLFxuICAgICAgICAgICAgICBhdXRob3I6IHZpZGVvLmF1dGhvcj8udW5pcXVlSWQsXG4gICAgICAgICAgICAgIGF1dGhvckF2YXRhcjogdmlkZW8uYXV0aG9yPy5hdmF0YXJMYXJnZXIsXG4gICAgICAgICAgICAgIGNyZWF0ZVRpbWU6IHZpZGVvLmNyZWF0ZVRpbWUsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB2aWRlby52aWRlbz8uZHVyYXRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgICAgdmlld3MsIGxpa2VzLCBjb21tZW50cywgc2hhcmVzLCBzYXZlcywgZG93bmxvYWRzLCBlcjogY3VzdG9tRXIudG9GaXhlZCgxKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjb3Jlczoge1xuICAgICAgICAgICAgICB2aXJhbGl0eTogdmlyYWxpdHlTY29yZSxcbiAgICAgICAgICAgICAgZ3JhZGUsXG4gICAgICAgICAgICAgIGN1c3RvbUVyOiBjdXN0b21Fci50b0ZpeGVkKDEpLFxuICAgICAgICAgICAgICBhaUFuYWx5c2lzOiBcIkFuYWxpeiBoYXrEsXJsYW7EsXlvci4uLlwiIC8vIFBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEdlbmVyYXRlIEFJIEFuYWx5c2lzXG4gICAgICAgICAgLy8gR2VuZXJhdGUgQUkgQW5hbHlzaXNcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuR09PR0xFX0FJX0FQSV9LRVk7XG4gICAgICAgICAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJHT09HTEVfQUlfQVBJX0tFWSBpcyBtaXNzaW5nL2VtcHR5LlwiKTtcbiAgICAgICAgICAgICAgcmVzdWx0RGF0YS5zY29yZXMuYWlBbmFseXNpcyA9IFwiQVBJIGFuYWh0YXLEsSBla3NpaywgYW5hbGl6IHlhcMSxbGFtYWTEsS5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGdlbkFJID0gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSShhcGlLZXkpO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IGdlbkFJLmdldEdlbmVyYXRpdmVNb2RlbCh7IG1vZGVsOiBcImdlbWluaS0yLjUtZmxhc2hcIiB9KTtcblxuICAgICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBgXG4gICAgICAgICAgICAgICAgUm9sZTogVGlrVG9rIEtvw6d1XG4gICAgICAgICAgICAgICAgR8O2cmV2OiBCdSB2aWRlbyBpw6dpbiAyIGPDvG1sZWxpayBhbmFsaXogeWFwLlxuICAgICAgICAgICAgICAgIFZlcmlsZXI6IE5vdDogJHtncmFkZX0sIEV0a2lsZcWfaW06ICUke2N1c3RvbUVyLnRvRml4ZWQoMSl9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgRm9ybWF0IChTYWRlY2UgMiBjw7xtbGUpOlxuICAgICAgICAgICAgICAgIDEuIEPDvG1sZTogVmlkZW9udW4gbmVkZW4gYnUgbm90dSBhbGTEscSfxLFuxLEgYcOnxLFrbGEgKGV0a2lsZcWfaW0vaXpsZW5tZSBkZW5nZXNpKS5cbiAgICAgICAgICAgICAgICAyLiBDw7xtbGU6IERhaGEgaXlpIG9sbWFzxLEgacOnaW4gbmV0IGJpciB0YWt0aWsgdmVyLlxuXG4gICAgICAgICAgICAgICAgS3VyYWxsYXI6XG4gICAgICAgICAgICAgICAgLSBSYWthbSBrdWxsYW5tYS5cbiAgICAgICAgICAgICAgICAtIEJhc2l0IHZlIG5ldCBvbC5cbiAgICAgICAgICAgICAgICAtIFwiQnUgbm90dSBhbGTEsSDDp8O8bmvDvC4uLlwiIGRlbWUsIGRpcmVrdCBhbmFsaXppIHPDtnlsZS5cbiAgICAgICAgICAgICAgICBgO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vZGVsLmdlbmVyYXRlQ29udGVudChwcm9tcHQpO1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3VsdC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgaWYgKHRleHQpIHJlc3VsdERhdGEuc2NvcmVzLmFpQW5hbHlzaXMgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChhaUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQUkgR2VuIEVycm9yOlwiLCBhaUVycm9yKTtcbiAgICAgICAgICAgIHJlc3VsdERhdGEuc2NvcmVzLmFpQW5hbHlzaXMgPSBgJHtncmFkZX0gbm90dSBhbGTEsW4uIEV0a2lsZcWfaW0gb3JhbmxhcsSxbsSxIGFydMSxcm1heWEgb2Rha2xhbm1hbMSxc8Sxbi4gKEFJIEhhdGFzxLEpYDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBVURJVCBUb29sIEVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UgfHwgXCJWaWRlbyBhbmFseXNpcyBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQudG9vbCA9PT0gXCJDT01QQVJFXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5USUtfQVBJX0tFWTtcbiAgICAgICAgICBpZiAoIWFwaUtleSkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBUaWtBUEkgS2V5XCIpO1xuXG4gICAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFuYWx5emUgYSB1c2VyXG4gICAgICAgICAgY29uc3QgYW5hbHl6ZVVzZXIgPSBhc3luYyAodXNlcm5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gMS4gQ2hlY2sgVXNlciB0byBnZXQgc3RhdHMgYW5kIHNlY1VpZFxuICAgICAgICAgICAgY29uc3QgdXNlclJlcyA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS50aWthcGkuaW8vcHVibGljL2NoZWNrP3VzZXJuYW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lLnRyaW0oKSl9YCwge1xuICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiWC1BUEktS0VZXCI6IGFwaUtleSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghdXNlclJlcy5vaykgdGhyb3cgbmV3IEVycm9yKGBVc2VyICR7dXNlcm5hbWV9IGNoZWNrIGZhaWxlZGApO1xuICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCB1c2VyUmVzLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJJbmZvID0gdXNlckRhdGEudXNlckluZm87XG4gICAgICAgICAgICBpZiAoIXVzZXJJbmZvKSB0aHJvdyBuZXcgRXJyb3IoYFVzZXIgJHt1c2VybmFtZX0gbm90IGZvdW5kYCk7XG5cbiAgICAgICAgICAgIC8vIDIuIEZldGNoIExhc3QgMTAgUG9zdHNcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHVzZXJJbmZvLnVzZXI/LnNlY1VpZFxuICAgICAgICAgICAgICA/IGBzZWNVaWQ9JHtlbmNvZGVVUklDb21wb25lbnQodXNlckluZm8udXNlci5zZWNVaWQpfWBcbiAgICAgICAgICAgICAgOiBgdXNlcm5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQodXNlckluZm8udXNlci51bmlxdWVJZCl9YDtcblxuICAgICAgICAgICAgY29uc3QgcG9zdHNSZXMgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hcGkudGlrYXBpLmlvL3B1YmxpYy9wb3N0cz8ke3RhcmdldH0mY291bnQ9MTVgLCB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJYLUFQSS1LRVlcIjogYXBpS2V5IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcG9zdHNEYXRhID0gYXdhaXQgcG9zdHNSZXMuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgYWxsUG9zdHMgPSBwb3N0c0RhdGEuaXRlbUxpc3QgfHwgW107XG4gICAgICAgICAgICBjb25zdCBsYXN0MTAgPSBhbGxQb3N0cy5zbGljZSgwLCAxMCk7XG5cbiAgICAgICAgICAgIC8vIDMuIENhbGMgTWV0cmljc1xuICAgICAgICAgICAgLy8gQmFzaWMgUHJvZmlsZSBTdGF0c1xuICAgICAgICAgICAgY29uc3QgZm9sbG93ZXJzID0gdXNlckluZm8uc3RhdHM/LmZvbGxvd2VyQ291bnQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTGlrZXMgPSB1c2VySW5mby5zdGF0cz8uaGVhcnRDb3VudCB8fCAwOyAvLyBMaWZldGltZSBsaWtlcyB1c3VhbGx5IGluIHN0YXRzXG5cbiAgICAgICAgICAgIGxldCBhdmdWaWV3cyA9IDA7XG4gICAgICAgICAgICBsZXQgc2FmZUVyID0gMDtcbiAgICAgICAgICAgIGxldCBjb25zaXN0ZW5jeVNjb3JlID0gNTA7XG4gICAgICAgICAgICBsZXQgY29tbXVuaXR5U2NvcmUgPSA1MDtcblxuICAgICAgICAgICAgaWYgKGxhc3QxMC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIEF2ZyBWaWV3cyArIEVSXG4gICAgICAgICAgICAgIGNvbnN0IHRvdGFsVmlld3MgPSBsYXN0MTAucmVkdWNlKChhY2M6IG51bWJlciwgcDogYW55KSA9PiBhY2MgKyAocC5zdGF0cz8ucGxheUNvdW50IHx8IDApLCAwKTtcbiAgICAgICAgICAgICAgYXZnVmlld3MgPSBNYXRoLmZsb29yKHRvdGFsVmlld3MgLyBsYXN0MTAubGVuZ3RoKTtcblxuICAgICAgICAgICAgICBjb25zdCB0b3RhbFdlaWdodGVkRW5nID0gbGFzdDEwLnJlZHVjZSgoYWNjOiBudW1iZXIsIHA6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyAocC5zdGF0cz8uZGlnZ0NvdW50IHx8IDApICsgKChwLnN0YXRzPy5jb21tZW50Q291bnQgfHwgMCkgKiAyKSArICgocC5zdGF0cz8uc2hhcmVDb3VudCB8fCAwKSAqIDMpO1xuICAgICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICAgICAgICBzYWZlRXIgPSB0b3RhbFZpZXdzID4gMCA/ICh0b3RhbFdlaWdodGVkRW5nIC8gdG90YWxWaWV3cykgKiAxMDAgOiAwO1xuICAgICAgICAgICAgICBzYWZlRXIgPSBNYXRoLm1pbihzYWZlRXIsIDEwMCk7XG5cbiAgICAgICAgICAgICAgLy8gQ29uc2lzdGVuY3lcbiAgICAgICAgICAgICAgaWYgKGxhc3QxMC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3QxMC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdhcEhycyA9IE1hdGguYWJzKGxhc3QxMFtpXS5jcmVhdGVUaW1lIC0gbGFzdDEwW2kgKyAxXS5jcmVhdGVUaW1lKSAvIDM2MDA7XG4gICAgICAgICAgICAgICAgICBnYXBzLnB1c2goZ2FwSHJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWVhbkdhcCA9IGdhcHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBnYXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IGdhcHMucmVkdWNlKChhLCBiKSA9PiBhICsgTWF0aC5wb3coYiAtIG1lYW5HYXAsIDIpLCAwKSAvIGdhcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKSAvIChtZWFuR2FwIHx8IDEpO1xuICAgICAgICAgICAgICAgIGNvbnNpc3RlbmN5U2NvcmUgPSBNYXRoLm1heCgyMCwgTWF0aC5taW4oMTAwLCAxMDAgLSAoY3YgKiA1MCkpKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhbkdhcCA+IDE2OCkgY29uc2lzdGVuY3lTY29yZSAqPSAwLjc7IC8vIEluYWN0aXZlIHBlbmFsdHlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENvbW11bml0eSAoQWdncmVnYXRlIG9mIGxhc3QgMTApXG4gICAgICAgICAgICAgIGNvbnN0IGFnZ0xpa2VzID0gbGFzdDEwLnJlZHVjZSgoYWNjOiBudW1iZXIsIHA6IGFueSkgPT4gYWNjICsgKHAuc3RhdHM/LmRpZ2dDb3VudCB8fCAwKSwgMCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFnZ0NvbW1lbnRzID0gbGFzdDEwLnJlZHVjZSgoYWNjOiBudW1iZXIsIHA6IGFueSkgPT4gYWNjICsgKHAuc3RhdHM/LmNvbW1lbnRDb3VudCB8fCAwKSwgMCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFnZ1NoYXJlcyA9IGxhc3QxMC5yZWR1Y2UoKGFjYzogbnVtYmVyLCBwOiBhbnkpID0+IGFjYyArIChwLnN0YXRzPy5zaGFyZUNvdW50IHx8IDApLCAwKTtcblxuICAgICAgICAgICAgICBjb25zdCBjb21tZW50UmF0aW8gPSBhZ2dMaWtlcyA+IDAgPyAoYWdnQ29tbWVudHMgLyBhZ2dMaWtlcykgKiAxMDAgOiAwO1xuICAgICAgICAgICAgICBjb25zdCBzaGFyZVJhdGlvID0gYWdnTGlrZXMgPiAwID8gKGFnZ1NoYXJlcyAvIGFnZ0xpa2VzKSAqIDEwMCA6IDA7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnRSYXRpbyA+IDAuNSkgY29tbXVuaXR5U2NvcmUgKz0gMjA7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50UmF0aW8gPiAxLjUpIGNvbW11bml0eVNjb3JlICs9IDEwO1xuICAgICAgICAgICAgICBpZiAoc2hhcmVSYXRpbyA+IDUpIGNvbW11bml0eVNjb3JlICs9IDE1O1xuICAgICAgICAgICAgICBpZiAoc2hhcmVSYXRpbyA+IDEwKSBjb21tdW5pdHlTY29yZSArPSAxNTtcbiAgICAgICAgICAgICAgY29tbXVuaXR5U2NvcmUgPSBNYXRoLm1pbigxMDAsIGNvbW11bml0eVNjb3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJJbmZvLnVzZXIudW5pcXVlSWQsXG4gICAgICAgICAgICAgIG5pY2tuYW1lOiB1c2VySW5mby51c2VyLm5pY2tuYW1lLFxuICAgICAgICAgICAgICBhdmF0YXI6IHVzZXJJbmZvLnVzZXIuYXZhdGFyVGh1bWIsXG4gICAgICAgICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgICAgICAgZm9sbG93ZXJzLFxuICAgICAgICAgICAgICAgIHRvdGFsTGlrZXMsXG4gICAgICAgICAgICAgICAgYXZnVmlld3MsXG4gICAgICAgICAgICAgICAgZXI6IHBhcnNlRmxvYXQoc2FmZUVyLnRvRml4ZWQoMikpLFxuICAgICAgICAgICAgICAgIGNvbnNpc3RlbmN5OiBNYXRoLnJvdW5kKGNvbnNpc3RlbmN5U2NvcmUpLFxuICAgICAgICAgICAgICAgIGNvbW11bml0eTogTWF0aC5yb3VuZChjb21tdW5pdHlTY29yZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gUGFyc2UgSW5wdXQgXCJ1c2VyMSx1c2VyMlwiXG4gICAgICAgICAgY29uc3QgW3VzZXIxQXJnLCB1c2VyMkFyZ10gPSBpbnB1dC5pbnB1dC5zcGxpdCgnLCcpLm1hcCgoczogc3RyaW5nKSA9PiBzLnRyaW0oKSk7XG4gICAgICAgICAgaWYgKCF1c2VyMUFyZyB8fCAhdXNlcjJBcmcpIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBlbnRlciB0d28gdXNlcm5hbWVzIHNlcGFyYXRlZCBieSBjb21tYS5cIik7XG4gICAgICAgICAgLy8gUnVuIFBhcmFsbGVsXG4gICAgICAgICAgY29uc3QgW3VzZXIxRGF0YSwgdXNlcjJEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGFuYWx5emVVc2VyKHVzZXIxQXJnKSxcbiAgICAgICAgICAgIGFuYWx5emVVc2VyKHVzZXIyQXJnKVxuICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgcmVzdWx0RGF0YSA9IHtcbiAgICAgICAgICAgIHVzZXIxOiB1c2VyMURhdGEsXG4gICAgICAgICAgICB1c2VyMjogdXNlcjJEYXRhXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbXBhcmlzb24gRXJyb3I6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkthcsWfxLFsYcWfdMSxcm1hIEJhxZ9hcsSxc8SxejogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZWR1Y3QgQ291cG9uIGFuZCBTYXZlIEhpc3RvcnlcbiAgICAgIGF3YWl0IHByaXNtYS4kdHJhbnNhY3Rpb24oW1xuICAgICAgICBwcmlzbWEudXNlci51cGRhdGUoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiB1c2VySWQgfSxcbiAgICAgICAgICBkYXRhOiB7IGNvdXBvbkJhbGFuY2U6IHsgZGVjcmVtZW50OiAxIH0gfVxuICAgICAgICB9KSxcbiAgICAgICAgcHJpc21hLm1hcmtldHBsYWNlVXNhZ2UuY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICB0b29sVHlwZTogaW5wdXQudG9vbCxcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dC5pbnB1dCxcbiAgICAgICAgICAgIHJlc3VsdFNuYXBzaG90OiByZXN1bHREYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgXSk7XG5cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHJlc3VsdDogcmVzdWx0RGF0YSB9O1xuICAgIH0pLFxuXG4gIGdldE1hcmtldHBsYWNlSGlzdG9yeTogdC5wcm9jZWR1cmVcbiAgICAucXVlcnkoYXN5bmMgKHsgY3R4IH0pID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG5cbiAgICAgIHJldHVybiBhd2FpdCBwcmlzbWEubWFya2V0cGxhY2VVc2FnZS5maW5kTWFueSh7XG4gICAgICAgIHdoZXJlOiB7IHVzZXJJZCB9LFxuICAgICAgICBvcmRlckJ5OiB7IGNyZWF0ZWRBdDogXCJkZXNjXCIgfVxuICAgICAgfSk7XG4gICAgfSksXG5cbiAgY29tcGxldGVDYW1wYWlnbjogdC5wcm9jZWR1cmVcbiAgICAuaW5wdXQoei5vYmplY3QoeyBjYW1wYWlnbklkOiB6LnN0cmluZygpIH0pKVxuICAgIC5tdXRhdGlvbihhc3luYyAoeyBpbnB1dCwgY3R4IH0pID0+IHtcbiAgICAgIC8vIDEuIEF1dGhvcml6YXRpb25cbiAgICAgIGNvbnN0IHVzZXJJZCA9IGN0eC51c2VyPy5pZDtcbiAgICAgIGlmICghdXNlcklkKSB0aHJvdyBuZXcgRXJyb3IoXCJVTkFVVEhPUklaRURcIik7XG5cbiAgICAgIGNvbnN0IGNhbXBhaWduID0gYXdhaXQgcHJpc21hLmNhbXBhaWduLmZpbmRVbmlxdWUoe1xuICAgICAgICB3aGVyZTogeyBpZDogaW5wdXQuY2FtcGFpZ25JZCB9LFxuICAgICAgICBpbmNsdWRlOiB7IHN1Ym1pc3Npb25zOiB7IHdoZXJlOiB7IHN0YXR1czogeyBub3Q6ICdSRUpFQ1RFRCcgfSB9IH0gfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY2FtcGFpZ24pIHRocm93IG5ldyBFcnJvcihcIkNBTVBBSUdOX05PVF9GT1VORFwiKTtcbiAgICAgIGlmIChjYW1wYWlnbi5hcnRpc3RJZCAhPT0gdXNlcklkICYmIGN0eC51c2VyPy5yb2xlICE9PSBcIkFETUlOXCIpIHRocm93IG5ldyBFcnJvcihcIkZPUkJJRERFTlwiKTtcbiAgICAgIGlmIChjYW1wYWlnbi5zdGF0dXMgPT09IFwiQ09NUExFVEVEXCIpIHRocm93IG5ldyBFcnJvcihcIkNBTVBBSUdOX0FMUkVBRFlfQ09NUExFVEVEXCIpO1xuXG4gICAgICAvLyAyLiBSZWZyZXNoIE1ldHJpY3MgKG91dHNpZGUgdHJhbnNhY3Rpb24gLSBjYW4gZmFpbCBncmFjZWZ1bGx5KVxuICAgICAgY29uc3QgeyB0aWt0b2tTY3JhcGVyIH0gPSBhd2FpdCBpbXBvcnQoXCJAL2xpYi90aWt0b2stc2NyYXBlclwiKTtcbiAgICAgIGNvbnN0IHN1Ym1pc3Npb25zID0gY2FtcGFpZ24uc3VibWlzc2lvbnM7XG4gICAgICBjb25zdCBDSFVOS19TSVpFID0gNTtcblxuICAgICAgY29uc3QgcmVmcmVzaGVkTWV0cmljczogeyBpZDogc3RyaW5nOyB2aWV3czogbnVtYmVyOyBsaWtlczogbnVtYmVyOyBjb21tZW50czogbnVtYmVyOyBzaGFyZXM6IG51bWJlciB9W10gPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJtaXNzaW9ucy5sZW5ndGg7IGkgKz0gQ0hVTktfU0laRSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IHN1Ym1pc3Npb25zLnNsaWNlKGksIGkgKyBDSFVOS19TSVpFKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2h1bmsubWFwKGFzeW5jIChzdWIpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHN1Yi50aWt0b2tVcmwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmlkZW9EYXRhID0gYXdhaXQgdGlrdG9rU2NyYXBlci52ZXJpZnlWaWRlbyhzdWIudGlrdG9rVXJsKTtcbiAgICAgICAgICAgICAgcmVmcmVzaGVkTWV0cmljcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogc3ViLmlkLFxuICAgICAgICAgICAgICAgIHZpZXdzOiB2aWRlb0RhdGEudmlld3MsXG4gICAgICAgICAgICAgICAgbGlrZXM6IHZpZGVvRGF0YS5saWtlcyxcbiAgICAgICAgICAgICAgICBjb21tZW50czogdmlkZW9EYXRhLmNvbW1lbnRzLFxuICAgICAgICAgICAgICAgIHNoYXJlczogdmlkZW9EYXRhLnNoYXJlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcmVmcmVzaCBzdWJtaXNzaW9uICR7c3ViLmlkfTpgLCBlKTtcbiAgICAgICAgICAgIC8vIFVzZSBvbGQgbWV0cmljcyBpZiByZWZyZXNoIGZhaWxzXG4gICAgICAgICAgICByZWZyZXNoZWRNZXRyaWNzLnB1c2goe1xuICAgICAgICAgICAgICBpZDogc3ViLmlkLFxuICAgICAgICAgICAgICB2aWV3czogc3ViLmxhc3RWaWV3Q291bnQgfHwgMCxcbiAgICAgICAgICAgICAgbGlrZXM6IHN1Yi5sYXN0TGlrZUNvdW50IHx8IDAsXG4gICAgICAgICAgICAgIGNvbW1lbnRzOiBzdWIubGFzdENvbW1lbnRDb3VudCB8fCAwLFxuICAgICAgICAgICAgICBzaGFyZXM6IHN1Yi5sYXN0U2hhcmVDb3VudCB8fCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gMy4gQUxMIGNhbGN1bGF0aW9ucyBhbmQgcGF5b3V0cyBpbiBPTkUgYXRvbWljIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB7IENhbGN1bGF0aW9uU2VydmljZSB9ID0gYXdhaXQgaW1wb3J0KCdAL3NlcnZlci9zZXJ2aWNlcy9jYWxjdWxhdGlvblNlcnZpY2UnKTtcblxuICAgICAgYXdhaXQgcHJpc21hLiR0cmFuc2FjdGlvbihhc3luYyAodHgpID0+IHtcbiAgICAgICAgLy8gM2EuIFVwZGF0ZSBtZXRyaWNzIGFuZCBjYWxjdWxhdGUgcG9pbnRzIGZvciBhbGwgc3VibWlzc2lvbnNcbiAgICAgICAgZm9yIChjb25zdCBtZXRyaWNzIG9mIHJlZnJlc2hlZE1ldHJpY3MpIHtcbiAgICAgICAgICBjb25zdCBwb2ludHMgPSBDYWxjdWxhdGlvblNlcnZpY2UuY2FsY3VsYXRlUG9pbnRzKFxuICAgICAgICAgICAgbWV0cmljcy52aWV3cyxcbiAgICAgICAgICAgIG1ldHJpY3MubGlrZXMsXG4gICAgICAgICAgICBtZXRyaWNzLnNoYXJlc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBhd2FpdCB0eC5zdWJtaXNzaW9uLnVwZGF0ZSh7XG4gICAgICAgICAgICB3aGVyZTogeyBpZDogbWV0cmljcy5pZCB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBsYXN0Vmlld0NvdW50OiBtZXRyaWNzLnZpZXdzLFxuICAgICAgICAgICAgICBsYXN0TGlrZUNvdW50OiBtZXRyaWNzLmxpa2VzLFxuICAgICAgICAgICAgICBsYXN0Q29tbWVudENvdW50OiBtZXRyaWNzLmNvbW1lbnRzLFxuICAgICAgICAgICAgICBsYXN0U2hhcmVDb3VudDogbWV0cmljcy5zaGFyZXMsXG4gICAgICAgICAgICAgIGxhc3RDaGVja2VkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIHZpZXdQb2ludHM6IHBvaW50cy52aWV3UG9pbnRzLFxuICAgICAgICAgICAgICBsaWtlUG9pbnRzOiBwb2ludHMubGlrZVBvaW50cyxcbiAgICAgICAgICAgICAgc2hhcmVQb2ludHM6IHBvaW50cy5zaGFyZVBvaW50cyxcbiAgICAgICAgICAgICAgdG90YWxQb2ludHM6IHBvaW50cy50b3RhbFBvaW50c1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gM2IuIFJlY2FsY3VsYXRlIGNhbXBhaWduIHRvdGFscyBhbmQgZGlzdHJpYnV0aW9uICh3aXRoIFJvYmluIEhvb2QgY2FwKVxuICAgICAgICBhd2FpdCBDYWxjdWxhdGlvblNlcnZpY2UudXBkYXRlQ2FtcGFpZ25Ub3RhbFBvaW50cyhpbnB1dC5jYW1wYWlnbklkLCBwcmlzbWEsIHR4KTtcbiAgICAgICAgYXdhaXQgQ2FsY3VsYXRpb25TZXJ2aWNlLnJlY2FsY3VsYXRlQ2FtcGFpZ25TdWJtaXNzaW9ucyhpbnB1dC5jYW1wYWlnbklkLCBwcmlzbWEsIHR4KTtcblxuICAgICAgICAvLyAzYy4gRGlzdHJpYnV0ZSBwYXlvdXRzIHRvIGNyZWF0b3JzXG4gICAgICAgIGNvbnN0IGZpbmFsU3VibWlzc2lvbnMgPSBhd2FpdCB0eC5zdWJtaXNzaW9uLmZpbmRNYW55KHtcbiAgICAgICAgICB3aGVyZToge1xuICAgICAgICAgICAgY2FtcGFpZ25JZDogaW5wdXQuY2FtcGFpZ25JZCxcbiAgICAgICAgICAgIHN0YXR1czogJ0FQUFJPVkVEJyxcbiAgICAgICAgICAgIHRvdGFsRWFybmluZ3M6IHsgZ3Q6IDAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICBpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0b3JJZDogdHJ1ZSxcbiAgICAgICAgICAgIHRvdGFsRWFybmluZ3M6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIGZpbmFsU3VibWlzc2lvbnMpIHtcbiAgICAgICAgICBjb25zdCBlYXJuaW5nc1RMID0gTnVtYmVyKHN1Yi50b3RhbEVhcm5pbmdzKTtcbiAgICAgICAgICBpZiAoZWFybmluZ3NUTCA+IDApIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjcmVhdG9yIGJhbGFuY2VcbiAgICAgICAgICAgIGF3YWl0IHR4LnVzZXIudXBkYXRlKHtcbiAgICAgICAgICAgICAgd2hlcmU6IHsgaWQ6IHN1Yi5jcmVhdG9ySWQgfSxcbiAgICAgICAgICAgICAgZGF0YTogeyBiYWxhbmNlOiB7IGluY3JlbWVudDogZWFybmluZ3NUTCB9IH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgZWFybmluZ3MgdHJhbnNhY3Rpb24gcmVjb3JkXG4gICAgICAgICAgICBhd2FpdCB0eC50cmFuc2FjdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBzdWIuY3JlYXRvcklkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdFQVJOSU5HJyxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IGVhcm5pbmdzVEwsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnQ09NUExFVEVEJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYEthbXBhbnlhIEthemFuY8SxOiAke2NhbXBhaWduLnRpdGxlfWAsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBzdWIuaWRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gM2QuIE1hcmsgY2FtcGFpZ24gYXMgY29tcGxldGVkXG4gICAgICAgIGF3YWl0IHR4LmNhbXBhaWduLnVwZGF0ZSh7XG4gICAgICAgICAgd2hlcmU6IHsgaWQ6IGlucHV0LmNhbXBhaWduSWQgfSxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBzdGF0dXM6IFwiQ09NUExFVEVEXCIsXG4gICAgICAgICAgICBjb21wbGV0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCB7XG4gICAgICAgIHRpbWVvdXQ6IDYwMDAwIC8vIDYwIHNlY29uZCB0aW1lb3V0IGZvciBsYXJnZSBjYW1wYWlnbnNcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgfSksXG5cbiAgcmVqZWN0Q2FtcGFpZ246IHQucHJvY2VkdXJlXG4gICAgLmlucHV0KHoub2JqZWN0KHsgY2FtcGFpZ25JZDogei5zdHJpbmcoKSwgcmVhc29uOiB6LnN0cmluZygpLm9wdGlvbmFsKCkgfSkpXG4gICAgLm11dGF0aW9uKGFzeW5jICh7IGlucHV0LCBjdHggfSkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gY3R4LnVzZXI/LmlkO1xuICAgICAgaWYgKCF1c2VySWQpIHRocm93IG5ldyBFcnJvcihcIlVOQVVUSE9SSVpFRFwiKTtcblxuICAgICAgY29uc3QgYWRtaW4gPSBhd2FpdCBwcmlzbWEudXNlci5maW5kVW5pcXVlKHsgd2hlcmU6IHsgaWQ6IHVzZXJJZCB9IH0pO1xuICAgICAgaWYgKGFkbWluPy5yb2xlICE9PSBcIkFETUlOXCIpIHRocm93IG5ldyBFcnJvcihcIkZPUkJJRERFTlwiKTtcblxuICAgICAgY29uc3QgY2FtcGFpZ24gPSBhd2FpdCBwcmlzbWEuY2FtcGFpZ24uZmluZFVuaXF1ZSh7XG4gICAgICAgIHdoZXJlOiB7IGlkOiBpbnB1dC5jYW1wYWlnbklkIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWNhbXBhaWduKSB0aHJvdyBuZXcgRXJyb3IoXCJDQU1QQUlHTl9OT1RfRk9VTkRcIik7XG5cbiAgICAgIGNvbnN0IHJlZnVuZEFtb3VudFRMID0gTnVtYmVyKGNhbXBhaWduLnRvdGFsQnVkZ2V0KTtcblxuICAgICAgLy8gUmVmdW5kICYgUmVqZWN0XG4gICAgICBhd2FpdCBwcmlzbWEuJHRyYW5zYWN0aW9uKGFzeW5jICh0eCkgPT4ge1xuICAgICAgICBhd2FpdCB0eC5jYW1wYWlnbi51cGRhdGUoe1xuICAgICAgICAgIHdoZXJlOiB7IGlkOiBpbnB1dC5jYW1wYWlnbklkIH0sXG4gICAgICAgICAgZGF0YTogeyBzdGF0dXM6IFwiUkVKRUNURURcIiB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHR4LnVzZXIudXBkYXRlKHtcbiAgICAgICAgICB3aGVyZTogeyBpZDogY2FtcGFpZ24uYXJ0aXN0SWQgfSxcbiAgICAgICAgICBkYXRhOiB7IGJhbGFuY2U6IHsgaW5jcmVtZW50OiByZWZ1bmRBbW91bnRUTCB9IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgdHgudHJhbnNhY3Rpb24uY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB1c2VySWQ6IGNhbXBhaWduLmFydGlzdElkLFxuICAgICAgICAgICAgdHlwZTogXCJERVBPU0lUXCIsXG4gICAgICAgICAgICBhbW91bnQ6IHJlZnVuZEFtb3VudFRMLFxuICAgICAgICAgICAgc3RhdHVzOiBcIkNPTVBMRVRFRFwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBLYW1wYW55YSDEsGFkZXNpOiAke2NhbXBhaWduLnRpdGxlfSAoJHtpbnB1dC5yZWFzb24gfHwgJ0FkbWluIFJlZGRpJ30pYFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgIH0pLFxufSk7XG5cbmV4cG9ydCB0eXBlIEFwcFJvdXRlciA9IHR5cGVvZiBhcHBSb3V0ZXI7XG4iXSwibmFtZXMiOlsiaW5pdFRSUEMiLCJzdXBlcmpzb24iLCJ6IiwicHJpc21hIiwiR29vZ2xlR2VuZXJhdGl2ZUFJIiwidGlrdG9rU2NyYXBlciIsImdldENyZWF0b3JUaWVyRnJvbUZvbGxvd2VycyIsImlzQ3JlYXRvckVsaWdpYmxlRm9yQ2FtcGFpZ24iLCJ0IiwiY29udGV4dCIsImNyZWF0ZSIsInRyYW5zZm9ybWVyIiwiYXBwUm91dGVyIiwicm91dGVyIiwiaGVhbHRoIiwicHJvY2VkdXJlIiwicXVlcnkiLCJnZXRVc2VyIiwiaW5wdXQiLCJvYmplY3QiLCJ1c2VySWQiLCJzdHJpbmciLCJ1c2VyIiwiZmluZFVuaXF1ZSIsIndoZXJlIiwiaWQiLCJzZWxlY3QiLCJuYW1lIiwiZW1haWwiLCJyb2xlIiwiYmFsYW5jZSIsImF2YXRhciIsInRpa3Rva0hhbmRsZSIsImNvdXBvbkJhbGFuY2UiLCJwbGFuIiwic3Vic2NyaXB0aW9uRW5kc0F0IiwiY3ljbGVTdGFydERhdGUiLCJ0b3RhbExpa2VzIiwidmlkZW9Db3VudCIsImZvbGxvd2luZ0NvdW50IiwiZm9sbG93ZXJDb3VudCIsImNyZWF0b3JUaWVyIiwibGFzdFN0YXRzRmV0Y2hlZEF0IiwidXBkYXRlUHJvZmlsZSIsIm9wdGlvbmFsIiwibXV0YXRpb24iLCJjdHgiLCJFcnJvciIsImN1cnJlbnRVc2VyIiwidGltZURpZmYiLCJEYXRlIiwiZ2V0VGltZSIsIm1pbnV0ZXNEaWZmIiwidXBkYXRlRGF0YSIsInRvQ2hlY2siLCJwcm9maWxlIiwiY2hlY2tVc2VyUHJvZmlsZSIsImlzVmFsaWQiLCJ1bmlxdWVJZCIsInVuZGVmaW5lZCIsImhlYXJ0Q291bnQiLCJlcnJvciIsImNvbnNvbGUiLCJ1cGRhdGVkVXNlciIsInVwZGF0ZSIsImRhdGEiLCJjcmVhdGVVc2VyIiwiZXhpc3RpbmciLCJwYXNzd29yZCIsImdldEFjdGl2ZUNhbXBhaWducyIsInNlYXJjaCIsInRpZXIiLCJlbnVtIiwibGltaXQiLCJudW1iZXIiLCJkZWZhdWx0Iiwic3RhdHVzIiwiZW5kRGF0ZSIsImd0IiwiT1IiLCJ0aXRsZSIsImNvbnRhaW5zIiwibW9kZSIsInNvbmciLCJhdXRob3JOYW1lIiwiY2FtcGFpZ25zIiwiY2FtcGFpZ24iLCJmaW5kTWFueSIsInRha2UiLCJ0b3RhbEJ1ZGdldCIsIm1heFN1Ym1pc3Npb25zIiwibWF4UGFydGljaXBhbnRzIiwiaXNQcm9Pbmx5IiwidGFyZ2V0VGllcnMiLCJtaW5Gb2xsb3dlcnMiLCJtaW5WaWRlb0R1cmF0aW9uIiwicGxhdGZvcm1GZWVQZXJjZW50Iiwic2FmZXR5UmVzZXJ2ZVBlcmNlbnQiLCJjb3ZlckltYWdlIiwiYXJ0aXN0IiwiX2NvdW50Iiwic3VibWlzc2lvbnMiLCJvcmRlckJ5IiwiY3JlYXRlZEF0IiwiZ2V0Sm9pbmVkQ2FtcGFpZ25zIiwiY3Vyc29yIiwibWluIiwibWF4IiwiZW5kZWRPbmx5IiwiYm9vbGVhbiIsIm5leHRDdXJzb3IiLCJzb21lIiwiY3JlYXRvcklkIiwibHQiLCJsYXN0Vmlld0NvdW50IiwibGFzdExpa2VDb3VudCIsImxhc3RTaGFyZUNvdW50Iiwidmlld1BvaW50cyIsImxpa2VQb2ludHMiLCJzaGFyZVBvaW50cyIsInRvdGFsUG9pbnRzIiwic2hhcmVQZXJjZW50IiwiZXN0aW1hdGVkRWFybmluZ3MiLCJwb29sU3RhdHMiLCJ0b3RhbENhbXBhaWduUG9pbnRzIiwidG90YWxTdWJtaXNzaW9ucyIsImF2ZXJhZ2VQb2ludHMiLCJ1cGRhdGVkQXQiLCJoYXNNb3JlIiwibGVuZ3RoIiwicmVzdWx0Iiwic2xpY2UiLCJnZXRDYW1wYWlnbkNvdW50cyIsImFjdGl2ZUNvdW50IiwibXlBY3RpdmVDb3VudCIsImpvaW5lZEFjdGl2ZUNvdW50IiwiUHJvbWlzZSIsImFsbCIsImNvdW50IiwiYXJ0aXN0SWQiLCJnZXRDYW1wYWlnbkJ5SWQiLCJpbmNsdWRlIiwiZHVyYXRpb24iLCJ0aWt0b2tVcmwiLCJ0aWt0b2tNdXNpY0lkIiwiYmlvIiwibXlTdWJtaXNzaW9uIiwic3VibWlzc2lvbiIsImZpbmRGaXJzdCIsImNhbXBhaWduSWQiLCJhZ2dyZWdhdGlvbnMiLCJhZ2dyZWdhdGUiLCJfc3VtIiwiYWxsU3VibWlzc2lvbnMiLCJyZWR1Y2UiLCJzdW0iLCJzdWIiLCJwb2ludHMiLCJ0b3RhbFZpZXdzIiwidG90YWxTaGFyZXMiLCJyZWNlbnRTdWJtaXNzaW9ucyIsImNyZWF0b3IiLCJfIiwibmV0QnVkZ2V0VFAiLCJfXyIsIm5ldE11bHRpcGxpZXIiLCJfX18iLCJjYW1wYWlnbkRhdGEiLCJtYXAiLCJnZXRDYW1wYWlnblN1Ym1pc3Npb25zIiwic29ydEJ5IiwibmV4dEl0ZW0iLCJwb3AiLCJ0cmVhdGVkU3VibWlzc2lvbnMiLCJnZXRDYW1wYWlnbkFuYWx5c2lzIiwicGVyaW9kIiwiZmlsdGVyZWRTdWJtaXNzaW9ucyIsIm5vdyIsInN0YXJ0RGF0ZSIsInNldEhvdXJzIiwiZ2V0SG91cnMiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImZpbHRlciIsInRvdGFscyIsImFjYyIsInZpZXdzIiwibGlrZXMiLCJzaGFyZXMiLCJ0aWVyQ291bnRzIiwiRCIsIkMiLCJCIiwiQSIsIlMiLCJmb3JFYWNoIiwidGllckRpc3RyaWJ1dGlvbiIsIk9iamVjdCIsImVudHJpZXMiLCJwZXJjZW50YWdlIiwiaXRlbSIsInNvcnQiLCJhIiwiYiIsIm9yZGVyIiwiZ3JvdXBlZCIsImxhYmVsIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91ciIsIm1pbnV0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImRheSIsIm1vbnRoIiwiZGF0ZSIsImNoYXJ0RGF0YSIsInZhbHVlcyIsImxvY2FsZUNvbXBhcmUiLCJkMSIsIm0xIiwic3BsaXQiLCJkMiIsIm0yIiwicGFyc2VJbnQiLCJnZXRTdWJtaXR0ZWRDYW1wYWlnbiIsImZpbmFsU3VibWlzc2lvbiIsImxhc3RDaGVja2VkIiwibGFzdENoZWNrZWRBdCIsImRpZmZIb3VycyIsInZpZGVvRGF0YSIsInZlcmlmeVZpZGVvIiwibGFzdENvbW1lbnRDb3VudCIsImNvbW1lbnRzIiwidmFsaWRhdGVWaWRlbyIsInVybCIsImUiLCJlcnJvcnMiLCJtZXNzYWdlIiwidmlkZW8iLCJjaGVja3MiLCJpc0FjY291bnRNYXRjaCIsImNyZWF0b3JVc2VybmFtZSIsInRvTG93ZXJDYXNlIiwicHVzaCIsIm11c2ljSWRNYXRjaCIsInNvdW5kSWQiLCJ0aXRsZU1hdGNoIiwidmVyaWZ5U29uZyIsImlzU29uZ01hdGNoIiwiZHVyYXRpb25NYXRjaCIsImZvbGxvd2VyTWF0Y2giLCJjcmVhdG9yRm9sbG93ZXJzIiwiYWNjb3VudE1hdGNoIiwic29uZ01hdGNoIiwic3VibWl0VmlkZW8iLCJjeWNsZVN0YXJ0IiwiZGF5c0luQ3ljbGUiLCJNYXRoIiwiZmxvb3IiLCJzdWJtaXNzaW9uQ291bnQiLCJndGUiLCJjYW1wYWlnbklkX2NyZWF0b3JJZCIsInRpZXJOYW1lcyIsInJlcXVpcmVkVGllciIsInVzZXJUaWVyIiwidGlrdG9rVmlkZW9JZCIsInZpZGVvSWQiLCJ2aWRlb0R1cmF0aW9uIiwib25TdWJtaXNzaW9uU3RhdHNVcGRhdGUiLCJzdWNjZXNzIiwic3VibWlzc2lvbklkIiwiZGVsZXRlU3VibWlzc2lvbiIsImRlbGV0ZSIsIkNhbGN1bGF0aW9uU2VydmljZSIsInVwZGF0ZUNhbXBhaWduVG90YWxQb2ludHMiLCJyZWNhbGN1bGF0ZUNhbXBhaWduU3VibWlzc2lvbnMiLCJjcmVhdGVDYW1wYWlnbiIsImRlc2NyaXB0aW9uIiwiYnVkZ2V0IiwiZ2V0Q2FtcGFpZ25UaWVyRnJvbUJ1ZGdldCIsImdldE1pbkZvbGxvd2Vyc0ZvclRpZXIiLCJnZXRNYXhTdWJtaXNzaW9uc0Zyb21CdWRnZXQiLCJzb25nRGF0YSIsImZldGNoU29uZ0RldGFpbHMiLCJzdGF0c0xhc3RGZXRjaGVkIiwiYnVkZ2V0VFAiLCJidWRnZXRUTCIsImNhbXBhaWduVGllciIsIiR0cmFuc2FjdGlvbiIsInR4IiwiTnVtYmVyIiwiZGVjcmVtZW50IiwidHJhbnNhY3Rpb24iLCJ0eXBlIiwiYW1vdW50IiwicmVtYWluaW5nQnVkZ2V0Iiwic29uZ0lkIiwiZ2V0TXlDYW1wYWlnbnMiLCJnZXRDcmVhdG9yU3RhdHMiLCJ0b3RhbEVhcm5pbmdzIiwicyIsImNhbXBhaWduRW5kZWQiLCJhY3RpdmVWaWRlb3MiLCJlbmRlZFN1Ym1pc3Npb25zIiwiYXZnQ29udHJpYnV0aW9uUGVyY2VudCIsImF2Z1ZpZXdzIiwicm91bmQiLCJyZWNlbnRUcmFuc2FjdGlvbnMiLCJpbiIsImZpbmlzaGVkU3VibWlzc2lvbnMiLCJyZWNlbnRBY3Rpdml0eSIsImlzUGx1cyIsInRvdGFsVmlkZW9zIiwiZ2V0QXJ0aXN0U3RhdHMiLCJidWRnZXRTdGF0cyIsInZpZXdTdGF0cyIsImFjdGl2ZUNhbXBhaWducyIsImFjdGl2ZUJ1ZGdldCIsImFjdGl2ZUNhbXBhaWduc0NvdW50IiwiZ2V0QWN0aXZpdHkiLCJ1cGdyYWRlVG9Qcm8iLCJ1cGdyYWRlVG9Qcm9XaXRoVFAiLCJDT1NUX1RMIiwiQ09VUE9OX1JFV0FSRCIsImV4cGlyZXNBdCIsImluY3JlbWVudCIsImJ1eUNvdXBvbnMiLCJDT1NUX1BFUl9DT1VQT04iLCJ0b3RhbENvc3QiLCJ1c2VDb3Vwb24iLCJ0b29sIiwicmVzdWx0RGF0YSIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJHT09HTEVfQUlfQVBJX0tFWSIsInJlcXVpcmUiLCJnZW5BSSIsIm1vZGVsIiwiZ2V0R2VuZXJhdGl2ZU1vZGVsIiwicHJvbXB0IiwiZ2VuZXJhdGVDb250ZW50IiwicmVzcG9uc2UiLCJ0ZXh0IiwiY2xlYW5Kc29uIiwicmVwbGFjZSIsInRyaW0iLCJKU09OIiwicGFyc2UiLCJicm9hZCIsIm5pY2hlIiwidmlyYWxpdHlTY29yZSIsImJlc3RUaW1lIiwiVElLX0FQSV9LRVkiLCJ1c2VyUmVzIiwiZmV0Y2giLCJoZWFkZXJzIiwib2siLCJzdGF0dXNUZXh0IiwidXNlckRhdGEiLCJqc29uIiwidXNlckluZm8iLCJmb2xsb3dlcnMiLCJzdGF0cyIsInNlY1VpZCIsIndhcm4iLCJxdWVyeVBhcmFtIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicG9zdHNSZXMiLCJlcnJUZXh0IiwicG9zdHNEYXRhIiwicG9zdHMiLCJpdGVtTGlzdCIsInRlbkRheXNBZ28iLCJyZWNlbnRQb3N0cyIsInAiLCJjcmVhdGVUaW1lIiwic2FmZUVyIiwicGxheUNvdW50IiwiZGlnZ0NvdW50IiwidG90YWxDb21tZW50cyIsImNvbW1lbnRDb3VudCIsInNoYXJlQ291bnQiLCJ3ZWlnaHRlZEVuZ2FnZW1lbnRzIiwicmVhbEVyIiwibGFzdDMiLCJjcG0iLCJlck11bHRpcGxpZXIiLCJleGNlc3NFciIsImVzdGltYXRlZFByaWNlIiwidXNlcm5hbWUiLCJwcmljZVBlclBvc3QiLCJlbmdhZ2VtZW50UmF0ZSIsInRvRml4ZWQiLCJjcG1kVXNlZCIsInRhcmdldCIsImFsbFBvc3RzIiwibGFzdDEwIiwiYW5hbHl6ZWRWaWRlb3MiLCJ3ZWlnaHRlZEVuZyIsImVyIiwiZGVzYyIsImNvdmVyIiwiYXZnU3RhdHMiLCJ2IiwicGFyc2VGbG9hdCIsImNvbnNpc3RlbmN5U2NvcmUiLCJnYXBzIiwiaSIsImdhcEhycyIsImFicyIsIm1lYW5HYXAiLCJ2YXJpYW5jZSIsInBvdyIsInN0ZERldiIsInNxcnQiLCJjdiIsImNvbW1lbnRSYXRpbyIsInNoYXJlUmF0aW8iLCJjb21tdW5pdHlTY29yZSIsIm5pY2tuYW1lIiwiYXZhdGFyVGh1bWIiLCJhdmVyYWdlcyIsInZpZGVvcyIsInNjb3JlcyIsImNvbnNpc3RlbmN5IiwiY29tbXVuaXR5IiwiaW5jbHVkZXMiLCJtYXRjaCIsInZpZFJlcyIsInZpZERhdGEiLCJpdGVtSW5mbyIsIml0ZW1TdHJ1Y3QiLCJzYXZlcyIsImNvbGxlY3RDb3VudCIsImRvd25sb2FkcyIsImRvd25sb2FkQ291bnQiLCJ3ZWlnaHRlZEVuZ2FnZW1lbnQiLCJjdXN0b21FciIsImVyU2NvcmUiLCJ2aWV3U2NvcmUiLCJncmFkZSIsImF1dGhvciIsImF1dGhvckF2YXRhciIsImF2YXRhckxhcmdlciIsInZpcmFsaXR5IiwiYWlBbmFseXNpcyIsImFpRXJyb3IiLCJhbmFseXplVXNlciIsInRvdGFsV2VpZ2h0ZWRFbmciLCJhZ2dMaWtlcyIsImFnZ0NvbW1lbnRzIiwiYWdnU2hhcmVzIiwidXNlcjFBcmciLCJ1c2VyMkFyZyIsInVzZXIxRGF0YSIsInVzZXIyRGF0YSIsInVzZXIxIiwidXNlcjIiLCJtYXJrZXRwbGFjZVVzYWdlIiwidG9vbFR5cGUiLCJyZXN1bHRTbmFwc2hvdCIsImdldE1hcmtldHBsYWNlSGlzdG9yeSIsImNvbXBsZXRlQ2FtcGFpZ24iLCJub3QiLCJDSFVOS19TSVpFIiwicmVmcmVzaGVkTWV0cmljcyIsImNodW5rIiwibWV0cmljcyIsImNhbGN1bGF0ZVBvaW50cyIsImZpbmFsU3VibWlzc2lvbnMiLCJlYXJuaW5nc1RMIiwicmVmZXJlbmNlIiwiY29tcGxldGVkQXQiLCJ0aW1lb3V0IiwicmVqZWN0Q2FtcGFpZ24iLCJyZWFzb24iLCJhZG1pbiIsInJlZnVuZEFtb3VudFRMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./server/routers/_app.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@trpc","vendor-chunks/superjson","vendor-chunks/copy-anything","vendor-chunks/is-what","vendor-chunks/zod","vendor-chunks/@supabase","vendor-chunks/@google","vendor-chunks/tslib","vendor-chunks/iceberg-js","vendor-chunks/set-cookie-parser"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&page=%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftrpc%2F%5Btrpc%5D%2Froute.ts&appDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5Cilker%5CDesktop%5Csesar-web&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();